{
  "name": "HumanEval_68_pluck",
  "language": "rs",
  "prompt": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let smallest_index = arr.find(x => x % 2 == 0)\n  let smallest_value_index = arr.find(x => x == smallest_value)\n  if smallest_value_index == -1 {\n    return []\n  } else {\n    return [smallest_value, smallest_index]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpkduddrjr.rs:27:42\n   |\n27 |   let smallest_value = arr.reduce((a, b) => a + b)\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = 0\n  let min_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even {\n        min_even = i\n        min_index = i\n      }\n    }\n  }\n  if min_even == 0 {\n    return []\n  }\n  return [min_even, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpauokpvb8.rs:27:19\n   |\n27 |   let min_even = 0\n   |                   ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpauokpvb8.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpauokpvb8.rs:32:21\n   |\n32 |         min_even = i\n   |                     ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpauokpvb8.rs:38:12\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n38 |     return []\n   |            ^^- help: try using a conversion method: `.to_vec()`\n   |            |\n   |            expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_value = arr.min()\n    let smallest_index = arr.index(smallest_value)\n    let smallest_even_value = smallest_value % 2\n    let smallest_even_index = smallest_index % 2\n    let smallest_even_value_index = smallest_even_index\n    if smallest_even_value == 0 {\n        smallest_even_value_index = smallest_even_index + 1\n    }\n    let smallest_value_index = smallest_even_value_index\n    if smallest_even_value == 0 {\n        smallest_value_index = smallest_even_index + 1\n    }\n    let smallest_value_index_vec = Vec::new(smallest_value_index)\n    return smallest_value_index_vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp2gjqg4tl.rs:27:35\n   |\n27 |     let smallest_value = arr.min()\n   |                                   ^ help: add `;` here\n28 |     let smallest_index = arr.index(smallest_value)\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2gjqg4tl.rs:28:51\n   |\n28 |     let smallest_index = arr.index(smallest_value)\n   |                                                   ^ help: add `;` here\n29 |     let smallest_even_value = smallest_value % 2\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2gjqg4tl.rs:29:49\n   |\n29 |     let smallest_even_value = smallest_value % 2\n   |                                                 ^ help: add `;` here\n30 |     let smallest_even_index = smallest_index % 2\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2gjqg4tl.rs:30:49\n   |\n30 |     let smallest_even_index = smallest_index % 2\n   |                                                 ^ help: add `;` here\n31 |     let smallest_even_value_index = smallest_even_index\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp2gjqg4tl.rs:31:56\n   |\n31 |     let smallest_even_value_index = smallest_even_index\n   |                                                        ^ help: add `;` here\n32 |     if smallest_even_value == 0 {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp2gjqg4tl.rs:35:57\n   |\n35 |     let smallest_value_index = smallest_even_value_index\n   |                                                         ^ help: add `;` here\n36 |     if smallest_even_value == 0 {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmp2gjqg4tl.rs:39:66\n   |\n39 |     let smallest_value_index_vec = Vec::new(smallest_value_index)\n   |                                                                  ^ help: add `;` here\n40 |     return smallest_value_index_vec\n   |     ------ unexpected token\n\nerr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return Vec::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_ym4jl2z.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_ym4jl2z.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp_ym4jl2z.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmp_ym4jl2z.rs:37:10\n    |\n37  |   return Vec::new(smallest_value, smallest_index)\n    |          ^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.filter(x => x % 2 == 0).min()\n  let index = arr.index_of(smallest_even)\n  let plucked = arr.filter(x => x == smallest_even).min()\n  return [plucked, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmps8fqp18e.rs:27:36\n   |\n27 |   let smallest_even = arr.filter(x => x % 2 == 0).min()\n   |                                    ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x % 2 == smallest_even_value)\n  let result = [smallest_even_value, smallest_index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpztn1lyas.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmps4f1ze4y.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value_index_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp0j5ww_q7.rs:27:42\n   |\n27 |   let smallest_value = arr.reduce((a, b) => a + b)\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n    let smallest_index = arr.reduce((a, b) => a + b)\n    let index = arr.find(x => x == smallest_even_value)\n    let value = arr[index]\n    return Vec::<isize>::new(value, index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpcfdi3e6k.rs:27:49\n   |\n27 |     let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                                 ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_value = arr[0]\n    let smallest_index = 0\n    for i in arr {\n        if i % 2 == 0 {\n            if i < smallest_value {\n                smallest_value = i\n                smallest_index = i\n            }\n        }\n    }\n    return [ smallest_value, smallest_index ]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpe7gydysa.rs:27:32\n   |\n27 |     let smallest_value = arr[0]\n   |                                ^ help: add `;` here\n28 |     let smallest_index = 0\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpe7gydysa.rs:28:27\n   |\n28 |     let smallest_index = 0\n   |                           ^ help: add `;` here\n29 |     for i in arr {\n   |     --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpe7gydysa.rs:32:35\n   |\n32 |                 smallest_value = i\n   |                                   ^ help: add `;` here\n33 |                 smallest_index = i\n   |                 -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7gydysa.rs:37:12\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |     return [ smallest_value, smallest_index ]\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |            |\n   |            expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpobpcphi9.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp_q1br6i_.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let index = arr.find(x => x % 2 == smallest_even_value)\n  return Vec::<isize>::new(smallest_even_value, index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpsnw9q3rz.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let min_even = arr.reduce((a, b) => a + b) % 2\n    let min_index = arr.reduce((a, b) => a + b)\n    let min_even_index = arr.reduce((a, b) => a + b) % 2\n    let min_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpsb17miy2.rs:27:38\n   |\n27 |     let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                      ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value)\n  if result.length == 0 {\n    return []\n  } else if result.length == 1 {\n    return [result[0], smallest_index]\n  } else {\n    let smallest_index_of_even_value = arr.filter((x) => x % 2 == smallest_even_value).reduce((a, b) => a + b)\n    return [smallest_index_of_even_value, smallest_index]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmptcfp2a37.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.find(x => x % 2 == 0)\n  let min_index = arr.find(x => x == min_even)\n  let min_value = min_even.value\n  let min_index_value = min_index.value\n  let min_index_index = min_index.index\n  let min_index_index_value = min_index_index.value\n  let min_index_index_index = min_index_index.index\n  let min_index_index_index_value = min_index_index_index.value\n  let min_index_index_index_index = min_index_index_index.index\n  let min_index_index_index_index_value = min_index_index_index_index.value\n  let min_index_index_index_index_index = min_index_index_index_index.index\n  let min_index_index_index_index_index_value = min_index_index_index_index_index.value\n  let min_index_index_index_index_index_index = min_index_index_index_index_index_index.index\n  let min_index_index_index_index_index_index_value = min_index_index_index_index_index_index_index.value\n  let min_index_index_index_index_index_index_index = min_index_index_index_index_index_index_index_index.index\n  let min_index_index_index_index_index_index_index_value = min_index_index_index_index_index_index_index_index_index.value\n  let min_index_index_index_index_index_index_index_index = min_index_index_index_index_index_index_index_index_index_index.index\n  let min_index_index_index_index_index_index_index_index_value = min_index_index_index_index_index_index_index_index_index_index_index.value\n  let min_index_index_index_index_index_index_index_index_index = min_index_index_index_index_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmprh5fogbj.rs:27:29\n   |\n27 |   let min_even = arr.find(x => x % 2 == 0)\n   |                             ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [smallest_value, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpblp8i4lq.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.find(x => x % 2 == 0)\n  let smallest_index = arr.find(x => x == smallest_even)\n  if smallest_even == arr.nth(0) {\n    return [smallest_even, smallest_index]\n  } else {\n    return [smallest_even, smallest_index - 1]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpxnow0tcx.rs:27:34\n   |\n27 |   let smallest_even = arr.find(x => x % 2 == 0)\n   |                                  ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpd0m42pvc.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = 0\n  let result = []\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      } else if i == smallest_value {\n        if i < smallest_index {\n          smallest_index = i\n        }\n      }\n    }\n  }\n  result = [ smallest_value, smallest_index ]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpjzazwfxz.rs:27:42\n   |\n27 |   let smallest_value = arr.reduce((a, b) => a + b)\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let min_even = arr.reduce((a, b) => a + b) % 2\n    let min_index = arr.reduce((a, b) => a + b)\n    let min_value = arr.reduce((a, b) => a + b)\n    let min_index_value = arr.reduce((a, b) => a + b)\n    let min_index_value_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpbep3cn96.rs:27:38\n   |\n27 |     let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                      ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpbep3cn96.rs:42:110\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |     let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n   |                                                                                                              ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [smallest_value, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpblp8i4lq.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, node) => acc + node, 0)\n  let smallest_index = arr.reduce((acc, node) => acc + node, 0)\n  let index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_even_value {\n        smallest_even_value = i\n        smallest_index = i\n      } else if i == smallest_even_value {\n        if i < smallest_index {\n          smallest_index = i\n        }\n      }\n    }\n  }\n  return [smallest_even_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpyez9djjv.rs:27:52\n   |\n27 |   let smallest_even_value = arr.reduce((acc, node) => acc + node, 0)\n   |                                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n    let smallest_index = arr.reduce((a, b) => a + b)\n    let result = []\n    for i in arr {\n        if i % 2 == smallest_even_value {\n            result.push(i)\n            if i < smallest_index {\n                smallest_index = i\n            }\n        }\n    }\n    return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmptne857zj.rs:27:49\n   |\n27 |     let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                                 ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if arr[i] == smallest_even_value {\n      result = [arr[i], i]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp5kio9r7c.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpobpcphi9.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_even = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val_even = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val_even_index = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val_even_index_val = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val_even_index_val_even = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val_even_index_val_even_index = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_even_index_val_even_index_val_even_index_val_even_index_val = arr.reduce\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp98prre8z.rs:27:51\n   |\n27 |   let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n   |                                                   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value).sort((a, b) => a - b)\n  if (result.length == 0) {\n    return Vec::new()\n  } else {\n    return Vec::new(result[0], smallest_index)\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpug2uo72q.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let min_value = arr[0]\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_value {\n        min_value = i\n        min_index = i\n      }\n    }\n  }\n  return [min_value, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfaiixwqw.rs:27:20\n   |\n27 |   let min_index = 0\n   |                    ^ help: add `;` here\n28 |   let min_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfaiixwqw.rs:28:25\n   |\n28 |   let min_value = arr[0]\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpfaiixwqw.rs:32:22\n   |\n32 |         min_value = i\n   |                      ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfaiixwqw.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [min_value, min_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  arr.remove(index)\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpee8x1163.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.find(x => x % 2 == 0)\n  let smallest_index = arr.find(x => x == smallest_even)\n  let smallest_value = smallest_even.value\n  let result = [smallest_value, smallest_index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpf82oi0_1.rs:27:34\n   |\n27 |   let smallest_even = arr.find(x => x % 2 == 0)\n   |                                  ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmps4f1ze4y.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpou_9q4f5.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpou_9q4f5.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index = arr.reduce((acc, val) => acc + val)\n  let result = []\n  for i in arr {\n    if i % 2 == 0 {\n      if smallest_even_value == i {\n        result = [i, smallest_index]\n        break\n      } else if smallest_even_value > i {\n        result = [i, smallest_index]\n        break\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpji_aryc7.rs:27:51\n   |\n27 |   let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n   |                                                   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value)\n  if result.length == 0 {\n    return []\n  } else if result.length == 1 {\n    return [result[0], smallest_index]\n  } else {\n    let smallest_index_of_result = result.reduce((a, b) => a + b)\n    return [result[smallest_index_of_result], smallest_index_of_result]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp5co2fweh.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((acc, val) => acc + val % 2)\n  let min_index = arr.reduce((acc, val) => acc + val)\n  let min_even_index = arr.reduce((acc, val) => acc + val * val)\n  let min_index_index = arr.reduce((acc, val) => acc + val * val)\n  if min_even == 0 {\n    return []\n  }\n  if min_even_index == min_index_index {\n    return [min_even, min_index]\n  }\n  return [min_even, min_index_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp6neit6gl.rs:27:40\n   |\n27 |   let min_even = arr.reduce((acc, val) => acc + val % 2)\n   |                                        ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let min_value = arr[0]\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_value {\n        min_value = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::<isize>::new(min_value, min_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp8lpzrhnt.rs:27:20\n   |\n27 |   let min_index = 0\n   |                    ^ help: add `;` here\n28 |   let min_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp8lpzrhnt.rs:28:25\n   |\n28 |   let min_value = arr[0]\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp8lpzrhnt.rs:32:22\n   |\n32 |         min_value = i\n   |                      ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmp8lpzrhnt.rs:37:10\n    |\n37  |   return Vec::<isize>::new(min_value, min_index)\n    |          ^^^^^^^^^^^^^^^^^ ---------  --------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.filter(x => x % 2 == 0).min()\n  let smallest_index = arr.index_of(smallest_even)\n  let smallest_value = arr[smallest_index]\n  let plucked = [ smallest_value, smallest_index ]\n  return plucked\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpl071xy7d.rs:27:36\n   |\n27 |   let smallest_even = arr.filter(x => x % 2 == 0).min()\n   |                                    ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = 0\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_even_value {\n        smallest_even_value = i\n        smallest_index = i\n      }\n    }\n  }\n  if smallest_even_value == 0 {\n    return []\n  }\n  return [smallest_even_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpf60azdo_.rs:27:30\n   |\n27 |   let smallest_even_value = 0\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpf60azdo_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpf60azdo_.rs:32:32\n   |\n32 |         smallest_even_value = i\n   |                                ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf60azdo_.rs:38:12\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n38 |     return []\n   |            ^^- help: try using a conversion method: `.to_vec()`\n   |            |\n   |            expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.reduce((acc, val) => {\n    if (val % 2 == 0) {\n      acc = val\n    }\n    return acc\n  })\n  let smallest_index = arr.reduce((acc, val) => {\n    if (val == smallest_even) {\n      acc = val\n    }\n    return acc\n  })\n  return [smallest_even, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp2x5mhm64.rs:27:45\n   |\n27 |   let smallest_even = arr.reduce((acc, val) => {\n   |                                             ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return Vec::<isize>::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfd04qlxk.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfd04qlxk.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpfd04qlxk.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpfd04qlxk.rs:37:10\n    |\n37  |   return Vec::<isize>::new(smallest_value, smallest_index)\n    |          ^^^^^^^^^^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value)\n  if result.length == 0 {\n    return []\n  } else if result.length == 1 {\n    return [result[0], smallest_index]\n  } else {\n    let smallest_index_of_smallest_even_value = arr.indexOf(result[0])\n    return [result[smallest_index_of_smallest_even_value], smallest_index]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpeoc71i52.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_value = arr[0];\n    let smallest_index = 0;\n    for i in arr {\n        if i % 2 == 0 {\n            if i < smallest_value {\n                smallest_value = i;\n                smallest_index = i;\n            }\n        }\n    }\n    return [smallest_value, smallest_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpsb222hny.rs:37:12\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |     return [smallest_value, smallest_index];\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |            |\n   |            expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpq08xdkdb.rs:27:41\n   |\n27 |   let smallest_even = arr.reduce((a, b) => a + b) % 2\n   |                                         ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.find(x => x % 2 == 0)\n  let min_index = arr.find(x => x == min_even)\n  if min_even == -1 || min_index == -1 {\n    return Vec::new()\n  }\n  return Vec::new(min_even, min_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpugm7aq9_.rs:27:29\n   |\n27 |   let min_even = arr.find(x => x % 2 == 0)\n   |                             ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min()\n  let smallest_index = arr.index_of(smallest_value)\n  let result = []\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      } else if i == smallest_value {\n        if i < smallest_index {\n          smallest_index = i\n        }\n      }\n    }\n  }\n  result = [ smallest_value, smallest_index ]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxqarp4ul.rs:27:33\n   |\n27 |   let smallest_value = arr.min()\n   |                                 ^ help: add `;` here\n28 |   let smallest_index = arr.index_of(smallest_value)\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxqarp4ul.rs:28:52\n   |\n28 |   let smallest_index = arr.index_of(smallest_value)\n   |                                                    ^ help: add `;` here\n29 |   let result = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxqarp4ul.rs:29:18\n   |\n29 |   let result = []\n   |                  ^ help: add `;` here\n30 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpxqarp4ul.rs:33:27\n   |\n33 |         smallest_value = i\n   |                           ^ help: add `;` here\n34 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmpxqarp4ul.rs:42:46\n   |\n42 |   result = [ smallest_value, smallest_index ]\n   |                                              ^ help: add `;` here\n43 |   return result\n   |   ------ unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpxqarp4ul.rs:27:28\n    |\n27  |   let smallest_value = arr.min()\n    |                            ^^^- supplied 0 arguments\n    |                            |\n    |                            expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpxqarp4ul.rs:28:28\n   |\n28 |   let smallest_index = arr.index_of(smallest_value)\n   |                            ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxqarp4ul.rs:32:14\n   |\n32 |       if i < smallest_value {\n   |              ^^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = arr.filter(x => x % 2 == 0).min()\n  let smallest_index = arr.indexOf(smallest_even)\n  let smallest_value = arr[smallest_index]\n  let result = [smallest_value, smallest_index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpuf05d0e8.rs:27:36\n   |\n27 |   let smallest_even = arr.filter(x => x % 2 == 0).min()\n   |                                    ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmps4f1ze4y.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) =>\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpgq7n3ac8.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgq7n3ac8.rs:45:58\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n45 |   let min_even_index_index_index_index_index = arr.reduce((a, b) =>\n   |                                                          ^ unclosed delimiter\n46 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let min_value = arr[0]\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_value {\n        min_value = i\n        min_index = i\n      }\n    }\n  }\n  return [min_value, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfaiixwqw.rs:27:20\n   |\n27 |   let min_index = 0\n   |                    ^ help: add `;` here\n28 |   let min_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfaiixwqw.rs:28:25\n   |\n28 |   let min_value = arr[0]\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpfaiixwqw.rs:32:22\n   |\n32 |         min_value = i\n   |                      ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfaiixwqw.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [min_value, min_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_value_index = arr.find(x => x % 2 == min_even_value)\n  let min_index_index = arr.find(x => x == min_index)\n  let min_even_value_index_index = arr.find(x => x == min_even_value_index)\n  if (min_even_value_index_index == -1) {\n    return []\n  } else {\n    return [min_even_value_index, min_index_index]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp6x_1iooo.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return Vec::new([value, index])\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp9vy2m74d.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_index_value = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_index_value)\n  let value = arr[index]\n  let index_value = arr[index]\n  let index_index = arr[index]\n  let index_index_value = arr[index]\n  let index_index_index = arr[index]\n  let index_index_index_value = arr[index]\n  let index_index_index_index = arr[index]\n  let index_index_index_index_value = arr[index]\n  let index_index_index_index_index = arr[index]\n  let index_index_index_index_index_value = arr[index]\n  let index_index_index_index_index_index = arr[index]\n  let index_index_index_index_index_index_value = arr[index]\n  let index_index_index_index_index_index_index = arr[index]\n  let index_index_index_index_index_index_index_value = arr[index]\n  let index_index_index_index_index_index_index_index = arr[index]\n  let index_index_index_index_index_index_index_index_value = arr[index]\n  let index_index_index_index_index_index_index_index_index = arr[index]\n  let index_index_index_index_index_index_index_index_index_value = arr[index]\n  let index_index_index_index_index_index_index_index_index_index = arr[index]\n  let index_index_index_index_index_index_index_index_index_index_value = arr[index]\n  let index_index_index_index_index_index_index_index_index_index_index = arr[index]\n  let index_index_index_index_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpcsrt0h6n.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value).sort((a, b) => a - b)\n  if (result.length == 0) {\n    return Vec::new()\n  } else {\n    return Vec::new(result[0], smallest_index)\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpug2uo72q.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if (i % 2 == smallest_even_value) {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpo39d_phe.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n    let smallest_index = arr.reduce((a, b) => a + b)\n    let index = arr.find(x => x == smallest_even_value)\n    let value = arr[index]\n    return Vec::<isize>::new(value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp1cjz1x_z.rs:27:49\n   |\n27 |     let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                                 ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpr11c1h75.rs:27:51\n   |\n27 |   let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n   |                                                   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even = 0\n  let smallest_index = 0\n  let result = []\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_even {\n        smallest_even = i\n        smallest_index = i\n      } else if i == smallest_even {\n        if i < smallest_index {\n          smallest_index = i\n        }\n      }\n    }\n  }\n  result = [smallest_even, smallest_index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp6ra48cjr.rs:27:24\n   |\n27 |   let smallest_even = 0\n   |                        ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp6ra48cjr.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   let result = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp6ra48cjr.rs:29:18\n   |\n29 |   let result = []\n   |                  ^ help: add `;` here\n30 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp6ra48cjr.rs:33:26\n   |\n33 |         smallest_even = i\n   |                          ^ help: add `;` here\n34 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmp6ra48cjr.rs:42:43\n   |\n42 |   result = [smallest_even, smallest_index]\n   |                                           ^ help: add `;` here\n43 |   return result\n   |   ------ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6ra48cjr.rs:42:12\n   |\n42 |   result = [smallest_even, smallest_index]\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an array with a fixed size of 0 elements, found one with 2 elements\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6ra48cjr.rs:43:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n43 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 0]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 0]`\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_value_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmphjmcr0x3.rs:27:51\n   |\n27 |   let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n   |                                                   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((acc, val) => acc + (val % 2 == 0), 0)\n  let min_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_index_val = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_index_val_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_index_val_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val_index_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_index_val_index_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val_index_index_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_index_val_index_index_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val_index_index_index_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_index_val_index_index_index_index_index = arr.reduce((acc, val) => acc + (val % 2 == 0) * val, 0)\n  let min_val_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpdpesk7r3.rs:27:40\n   |\n27 |   let min_even = arr.reduce((acc, val) => acc + (val % 2 == 0), 0)\n   |                                        ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp_q1br6i_.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_value = arr[0]\n    let smallest_index = 0\n    for i in arr {\n        if i % 2 == 0 {\n            if i < smallest_value {\n                smallest_value = i\n                smallest_index = i\n            }\n        }\n    }\n    return Vec::<isize>::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpscza7pr_.rs:27:32\n   |\n27 |     let smallest_value = arr[0]\n   |                                ^ help: add `;` here\n28 |     let smallest_index = 0\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpscza7pr_.rs:28:27\n   |\n28 |     let smallest_index = 0\n   |                           ^ help: add `;` here\n29 |     for i in arr {\n   |     --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpscza7pr_.rs:32:35\n   |\n32 |                 smallest_value = i\n   |                                   ^ help: add `;` here\n33 |                 smallest_index = i\n   |                 -------------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpscza7pr_.rs:37:12\n    |\n37  |     return Vec::<isize>::new(smallest_value, smallest_index)\n    |            ^^^^^^^^^^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |            |\n    |            expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value)\n  if result.length == 0 {\n    return Vec::new()\n  } else if result.length == 1 {\n    return Vec::new(result[0], smallest_index)\n  } else {\n    let smallest_index_of_even_value = arr.filter((x) => x % 2 == smallest_even_value).reduce((a, b) => a + b)\n    return Vec::new(result[smallest_index_of_even_value], smallest_index)\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpf_3gl4hq.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.reduce((a, b) => a if a % 2 == 0 else b)\n  let smallest_index = arr.reduce((a, b) => a if a % 2 == 0 else b)\n  let index = arr.find(x => x == smallest_index)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpfiyt32h4.rs:27:42\n   |\n27 |   let smallest_value = arr.reduce((a, b) => a if a % 2 == 0 else b)\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmps4f1ze4y.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value)\n  if result.length == 0 {\n    return []\n  } else {\n    return [smallest_index, smallest_even_value]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp2fmzy5_6.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpobpcphi9.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = 0\n  let min_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even {\n        min_even = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::new([min_even, min_index])\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk7_181_b.rs:27:19\n   |\n27 |   let min_even = 0\n   |                   ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk7_181_b.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpk7_181_b.rs:32:21\n   |\n32 |         min_even = i\n   |                     ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpk7_181_b.rs:37:10\n    |\n37  |   return Vec::new([min_even, min_index])\n    |          ^^^^^^^^ --------------------- supplied 1 argument\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min()\n  let smallest_index = 0\n  let smallest_even_value = smallest_value\n  let smallest_even_index = 0\n  let even_values = []\n  let even_indices = []\n  for i in arr {\n    if i % 2 == 0 {\n      even_values.append(i)\n      even_indices.append(i)\n    } else {\n      if i < smallest_even_value {\n        smallest_even_value = i\n        smallest_even_index = i\n      }\n    }\n  }\n  if even_values.length == 0 {\n    return []\n  }\n  if even_values.length == 1 {\n    return [smallest_even_value, smallest_even_index]\n  }\n  for i in even_indices {\n    if i < smallest_even_index {\n      smallest_even_index = i\n    }\n  }\n  return [smallest_even_value, smallest_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpng9s_j8t.rs:27:33\n   |\n27 |   let smallest_value = arr.min()\n   |                                 ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpng9s_j8t.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   let smallest_even_value = smallest_value\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpng9s_j8t.rs:29:43\n   |\n29 |   let smallest_even_value = smallest_value\n   |                                           ^ help: add `;` here\n30 |   let smallest_even_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpng9s_j8t.rs:30:30\n   |\n30 |   let smallest_even_index = 0\n   |                              ^ help: add `;` here\n31 |   let even_values = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpng9s_j8t.rs:31:23\n   |\n31 |   let even_values = []\n   |                       ^ help: add `;` here\n32 |   let even_indices = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpng9s_j8t.rs:32:24\n   |\n32 |   let even_indices = []\n   |                        ^ help: add `;` here\n33 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `even_indices`\n  --> /tmp/tmpng9s_j8t.rs:35:28\n   |\n35 |       even_values.append(i)\n   |                            ^ help: add `;` here\n36 |       even_indices.append(i)\n   |       ------------ unexpected token\n\nerror: expected `;`, found `smallest_even_index`\n  --> /tmp/tmpng9s_j8t.rs:39:32\n   |\n39 |         smallest_even_value = i\n   |                                ^ help: add `;` here\n40 |         smallest_even_index = i\n   |         ------------------- unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpng9s_j8t.rs:27:28\n    |\n27  |   let smallest_value = arr.min()\n    |           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = 0\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_even_value {\n        smallest_even_value = i\n        smallest_index = i\n      }\n    }\n  }\n  if smallest_even_value == 0 {\n    return Vec::new()\n  }\n  return Vec::new(smallest_index, smallest_even_value)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_t3d7b5q.rs:27:30\n   |\n27 |   let smallest_even_value = 0\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_t3d7b5q.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp_t3d7b5q.rs:32:32\n   |\n32 |         smallest_even_value = i\n   |                                ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmp_t3d7b5q.rs:40:10\n    |\n40  |   return Vec::new(smallest_index, smallest_even_value)\n    |          ^^^^^^^^ --------------  ------------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2 = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_mod_2_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2 = arr.reduce((acc, val) => acc + val % 2)\n  let smallest_index_val_mod_2_index_mod_2_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2 = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2_index_mod_2 = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2_index_mod_2_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2_index_mod_2_index_mod_2 = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2_index_mod_2_index_mod_2_index = arr.reduce((acc, val) => acc + val)\n  let smallest_index_val_mod_2_index_mod_2_index_mod_2_index_mod_2_index_mod_2_index_mod\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpp5a1pfq9.rs:27:51\n   |\n27 |   let smallest_even_value = arr.reduce((acc, val) => acc + val % 2)\n   |                                                   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_even_value = arr.reduce((a, b) => a + b)\n  let min_index_even_index = arr.reduce((a, b) => a + b) % 2\n\n  if min_even_value == 0 {\n    return Vec::new(min_index, min_index_even_index)\n  } else {\n    return Vec::new(min_index_even_index, min_index_even_value)\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpfkz1rkrk.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0];\n  let smallest_index = 0;\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i;\n        smallest_index = i;\n      }\n    }\n  }\n  return [smallest_value, smallest_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpdv8r0sps.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index];\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if i % 2 == smallest_even_value {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppj55bpe7.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let min_value = arr[0]\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_value {\n        min_value = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::new(min_value, min_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsm3yo1pn.rs:27:20\n   |\n27 |   let min_index = 0\n   |                    ^ help: add `;` here\n28 |   let min_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsm3yo1pn.rs:28:25\n   |\n28 |   let min_value = arr[0]\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsm3yo1pn.rs:32:22\n   |\n32 |         min_value = i\n   |                      ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpsm3yo1pn.rs:37:10\n    |\n37  |   return Vec::new(min_value, min_index)\n    |          ^^^^^^^^ ---------  --------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr.iter() {\n    if i.value % 2 == 0 {\n      if i.value < smallest_value {\n        smallest_value = i.value\n        smallest_index = i.index\n      }\n    }\n  }\n  return Vec::<isize>::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_i7b41it.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_i7b41it.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp_i7b41it.rs:32:33\n   |\n32 |         smallest_value = i.value\n   |                                 ^ help: add `;` here\n33 |         smallest_index = i.index\n   |         -------------- unexpected token\n\nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp_i7b41it.rs:30:10\n   |\n30 |     if i.value % 2 == 0 {\n   |          ^^^^^\n\nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp_i7b41it.rs:31:12\n   |\n31 |       if i.value < smallest_value {\n   |            ^^^^^\n\nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp_i7b41it.rs:32:28\n   |\n32 |         smallest_value = i.value\n   |                            ^^^^^\n\nerror[E0609]: no field `index` on type `&isize`\n  --> /tmp/tmp_i7b41it.rs:33:28\n   |\n33 |         smallest_index = i.index\n   |                            ^^^^^\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmp_i7b41it.rs:37:10\n    |\n37  |   return Vec::<isize>::new(smallest_value, smallest_index)\n    |          ^^^^^^^^^^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0061, E0609.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = 0\n  let min_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even {\n        min_even = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::new([min_even, min_index])\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk7_181_b.rs:27:19\n   |\n27 |   let min_even = 0\n   |                   ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk7_181_b.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpk7_181_b.rs:32:21\n   |\n32 |         min_even = i\n   |                     ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpk7_181_b.rs:37:10\n    |\n37  |   return Vec::new([min_even, min_index])\n    |          ^^^^^^^^ --------------------- supplied 1 argument\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if arr[i] == smallest_even_value {\n      result = [arr[i], i]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp4p8m6qmg.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_value = arr.min();\n    let smallest_index = arr.index(smallest_value);\n    let plucked_node = arr[smallest_index];\n    let plucked_index = smallest_index;\n    for i in arr {\n        if i == smallest_value {\n            continue;\n        }\n        if i % 2 == 0 {\n            if i < smallest_value {\n                smallest_value = i;\n                smallest_index = i;\n            }\n        } else {\n            if i < smallest_value {\n                smallest_value = i;\n                smallest_index = i;\n            }\n        }\n    }\n    return [smallest_value, smallest_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpzvxadcdo.rs:27:30\n    |\n27  |     let smallest_value = arr.min();\n    |                              ^^^- supplied 0 arguments\n    |                              |\n    |                              expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpzvxadcdo.rs:28:30\n   |\n28 |     let smallest_index = arr.index(smallest_value);\n   |                              ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvxadcdo.rs:32:17\n   |\n32 |         if i == smallest_value {\n   |                 ^^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvxadcdo.rs:36:20\n   |\n36 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvxadcdo.rs:37:34\n   |\n27 |     let smallest_value = arr.min();\n   |                          --------- expected due to this value\n...\n37 |                 smallest_value = i;\n   |                                  ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzvxadcdo.rs:29:24\n   |\n29 |     let plucked_node = arr[smallest_index];\n   |                        ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = 0\n  let min_index = 0\n  let min_value = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even_value {\n        min_even_value = i\n        min_index = i\n      }\n    }\n  }\n  if min_even_value == 0 {\n    return Vec::new()\n  }\n  return Vec::new(min_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpj8cqswu1.rs:27:25\n   |\n27 |   let min_even_value = 0\n   |                         ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpj8cqswu1.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   let min_value = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpj8cqswu1.rs:29:20\n   |\n29 |   let min_value = 0\n   |                    ^ help: add `;` here\n30 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpj8cqswu1.rs:33:27\n   |\n33 |         min_even_value = i\n   |                           ^ help: add `;` here\n34 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpj8cqswu1.rs:41:10\n    |\n41  |   return Vec::new(min_index)\n    |          ^^^^^^^^ --------- supplied 1 argument\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = 0\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_even_value {\n        smallest_even_value = i\n        smallest_index = i\n      } else if i == smallest_even_value {\n        if i < arr[smallest_index] {\n          smallest_index = i\n        }\n      }\n    }\n  }\n  return [smallest_even_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpr6xh5tc3.rs:27:30\n   |\n27 |   let smallest_even_value = 0\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpr6xh5tc3.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpr6xh5tc3.rs:32:32\n   |\n32 |         smallest_even_value = i\n   |                                ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpr6xh5tc3.rs:35:16\n   |\n35 |         if i < arr[smallest_index] {\n   |                ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr6xh5tc3.rs:41:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n41 |   return [smallest_even_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let min_value = arr[0]\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_value {\n        min_value = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::new(min_value, min_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsm3yo1pn.rs:27:20\n   |\n27 |   let min_index = 0\n   |                    ^ help: add `;` here\n28 |   let min_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsm3yo1pn.rs:28:25\n   |\n28 |   let min_value = arr[0]\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsm3yo1pn.rs:32:22\n   |\n32 |         min_value = i\n   |                      ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpsm3yo1pn.rs:37:10\n    |\n37  |   return Vec::new(min_value, min_index)\n    |          ^^^^^^^^ ---------  --------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = 0\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_even_value {\n        smallest_even_value = i\n        smallest_index = i\n      } else if i == smallest_even_value {\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_even_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpx1eh8ssc.rs:27:30\n   |\n27 |   let smallest_even_value = 0\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpx1eh8ssc.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpx1eh8ssc.rs:32:32\n   |\n32 |         smallest_even_value = i\n   |                                ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1eh8ssc.rs:39:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n39 |   return [smallest_even_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, val) => acc + val % 2, 0)\n  let smallest_index = arr.reduce((acc, val) => acc + val, 0)\n  let smallest_index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index_value_index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index_value_index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index_value_index_value_index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((acc, val) => acc + val, 0)\n  let index_value_index_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp0ty9ek2f.rs:27:51\n   |\n27 |   let smallest_even_value = arr.reduce((acc, val) => acc + val % 2, 0)\n   |                                                   ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = arr.filter((x) => x % 2 == smallest_even_value).sort((a, b) => a - b)\n  if (result.length == 0) {\n    return Vec::new()\n  }\n  return Vec::new(result[0], smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp_v79xr0q.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let result = arr.filter(x => x == smallest_even_value)\n  if (result.length == 0) {\n    return []\n  } else if (result.length == 1) {\n    return [smallest_even_value, smallest_index]\n  } else {\n    return [smallest_even_value, smallest_index]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp12wyhsqf.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  let result = [value, index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmps4f1ze4y.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  arr.remove(index)\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpee8x1163.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_even_index_value_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_value_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_value_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_value_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp5126poak.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [ smallest_value, smallest_index ]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppixffa3l.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppixffa3l.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmppixffa3l.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppixffa3l.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [ smallest_value, smallest_index ]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpobpcphi9.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = 0\n  let min_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even {\n        min_even = i\n        min_index = i\n      }\n    }\n  }\n  return [min_even, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3tyaquyp.rs:27:19\n   |\n27 |   let min_even = 0\n   |                   ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp3tyaquyp.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp3tyaquyp.rs:32:21\n   |\n32 |         min_even = i\n   |                     ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3tyaquyp.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [min_even, min_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpsvs9nc21.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpsvs9nc21.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min()\n  let smallest_index = 0\n  let smallest_index_value = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n        smallest_index_value = i\n      } else if i == smallest_value {\n        if i < smallest_index_value {\n          smallest_index_value = i\n          smallest_index = i\n        }\n      }\n    }\n  }\n  if smallest_index_value == 0 {\n    return Vec::new()\n  }\n  return Vec::new(smallest_index, smallest_index_value)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpuyku2361.rs:27:33\n   |\n27 |   let smallest_value = arr.min()\n   |                                 ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpuyku2361.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   let smallest_index_value = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpuyku2361.rs:29:31\n   |\n29 |   let smallest_index_value = 0\n   |                               ^ help: add `;` here\n30 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpuyku2361.rs:33:27\n   |\n33 |         smallest_value = i\n   |                           ^ help: add `;` here\n34 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror: expected `;`, found `smallest_index_value`\n  --> /tmp/tmpuyku2361.rs:34:27\n   |\n34 |         smallest_index = i\n   |                           ^ help: add `;` here\n35 |         smallest_index_value = i\n   |         -------------------- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpuyku2361.rs:38:35\n   |\n38 |           smallest_index_value = i\n   |                                   ^ help: add `;` here\n39 |           smallest_index = i\n   |           -------------- unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpuyku2361.rs:27:28\n    |\n27  |   let smallest_value = arr.min()\n    |                            ^^^- supplied 0 arguments\n    |                            |\n    |                            expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuyku2361.rs:32:14\n   |\n32 |       if i < smallest_value {\n   |              ^^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.reduce((a, b) => a if a % 2 == 0 else b)\n  let smallest_index = arr.reduce((a, b) => a if a % 2 == 0 else b)\n  let index = arr.find(x => x == smallest_value)\n  let value = arr[index]\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpwnkii95p.rs:27:42\n   |\n27 |   let smallest_value = arr.reduce((a, b) => a if a % 2 == 0 else b)\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_value = arr[0]\n    let smallest_index = 0\n    for i in arr {\n        if i % 2 == 0 {\n            if i < smallest_value {\n                smallest_value = i\n                smallest_index = i\n            }\n        }\n    }\n    return Vec::<isize>::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpscza7pr_.rs:27:32\n   |\n27 |     let smallest_value = arr[0]\n   |                                ^ help: add `;` here\n28 |     let smallest_index = 0\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpscza7pr_.rs:28:27\n   |\n28 |     let smallest_index = 0\n   |                           ^ help: add `;` here\n29 |     for i in arr {\n   |     --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpscza7pr_.rs:32:35\n   |\n32 |                 smallest_value = i\n   |                                   ^ help: add `;` here\n33 |                 smallest_index = i\n   |                 -------------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpscza7pr_.rs:37:12\n    |\n37  |     return Vec::<isize>::new(smallest_value, smallest_index)\n    |            ^^^^^^^^^^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |            |\n    |            expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp_q1br6i_.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return Vec::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_ym4jl2z.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_ym4jl2z.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp_ym4jl2z.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmp_ym4jl2z.rs:37:10\n    |\n37  |   return Vec::new(smallest_value, smallest_index)\n    |          ^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min();\n  let smallest_index = 0;\n  let smallest_index_found = false;\n  for i in arr {\n    if i % 2 == 0 {\n      if !smallest_index_found {\n        smallest_value = i;\n        smallest_index = i;\n        smallest_index_found = true;\n      } else if i < smallest_value {\n        smallest_value = i;\n        smallest_index = i;\n      }\n    }\n  }\n  if smallest_index_found {\n    return [smallest_value, smallest_index]\n  } else {\n    return []\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpss_gwrxz.rs:27:28\n    |\n27  |   let smallest_value = arr.min();\n    |                            ^^^- supplied 0 arguments\n    |                            |\n    |                            expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpss_gwrxz.rs:33:26\n   |\n27 |   let smallest_value = arr.min();\n   |                        --------- expected due to this value\n...\n33 |         smallest_value = i;\n   |                          ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpss_gwrxz.rs:36:21\n   |\n36 |       } else if i < smallest_value {\n   |                     ^^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpss_gwrxz.rs:37:26\n   |\n27 |   let smallest_value = arr.min();\n   |                        --------- expected due to this value\n...\n37 |         smallest_value = i;\n   |                          ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpss_gwrxz.rs:43:29\n   |\n43 |     return [smallest_value, smallest_index]\n   |                             ^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let smallest_value = arr.reduce((a, b) => a + b)\n  let index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if (i % 2 == smallest_even_value) {\n      result = [smallest_value, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp8g25ae28.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let min_even_value = arr.reduce((a, b) => a + b) % 2\n    let min_index = arr.reduce((a, b) => a + b)\n    let min_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_value = arr.reduce((a, b) => a + b)\n    let min_index_index_index_index_index_index_index_index_index = arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmprw8ka3xm.rs:27:44\n   |\n27 |     let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                            ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min()\n  let smallest_index = arr.index(smallest_value)\n  let result = []\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  result = [smallest_value, smallest_index]\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpghox7fs0.rs:27:33\n   |\n27 |   let smallest_value = arr.min()\n   |                                 ^ help: add `;` here\n28 |   let smallest_index = arr.index(smallest_value)\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpghox7fs0.rs:28:49\n   |\n28 |   let smallest_index = arr.index(smallest_value)\n   |                                                 ^ help: add `;` here\n29 |   let result = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpghox7fs0.rs:29:18\n   |\n29 |   let result = []\n   |                  ^ help: add `;` here\n30 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpghox7fs0.rs:33:27\n   |\n33 |         smallest_value = i\n   |                           ^ help: add `;` here\n34 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmpghox7fs0.rs:38:44\n   |\n38 |   result = [smallest_value, smallest_index]\n   |                                            ^ help: add `;` here\n39 |   return result\n   |   ------ unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpghox7fs0.rs:27:28\n    |\n27  |   let smallest_value = arr.min()\n    |                            ^^^- supplied 0 arguments\n    |                            |\n    |                            expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpghox7fs0.rs:28:28\n   |\n28 |   let smallest_index = arr.index(smallest_value)\n   |                            ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min()\n  let smallest_index = arr.index(smallest_value)\n  let plucked_node = arr[smallest_index]\n  let plucked_index = smallest_index\n  for i in arr {\n    if i == smallest_value {\n      continue\n    }\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpseml2gwx.rs:27:33\n   |\n27 |   let smallest_value = arr.min()\n   |                                 ^ help: add `;` here\n28 |   let smallest_index = arr.index(smallest_value)\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpseml2gwx.rs:28:49\n   |\n28 |   let smallest_index = arr.index(smallest_value)\n   |                                                 ^ help: add `;` here\n29 |   let plucked_node = arr[smallest_index]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpseml2gwx.rs:29:41\n   |\n29 |   let plucked_node = arr[smallest_index]\n   |                                         ^ help: add `;` here\n30 |   let plucked_index = smallest_index\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpseml2gwx.rs:30:37\n   |\n30 |   let plucked_index = smallest_index\n   |                                     ^ help: add `;` here\n31 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmpseml2gwx.rs:37:27\n   |\n37 |         smallest_value = i\n   |                           ^ help: add `;` here\n38 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpseml2gwx.rs:27:28\n    |\n27  |   let smallest_value = arr.min()\n    |                            ^^^- supplied 0 arguments\n    |                            |\n    |                            expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpseml2gwx.rs:28:28\n   |\n28 |   let smallest_index = arr.index(smallest_value)\n   |                            ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return Vec::<isize>::new([value, index])\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmplcbertik.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b) % 2\n  let min_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpp0qqd0f9.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_index = arr.reduce((a, b) => a + b)\n\n  let result = []\n  for i in arr {\n    if i % 2 == min_even_value {\n      result = [i, min_index]\n      break\n    }\n  }\n\n  if result == [] {\n    result = [0, 0]\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpfth7kr92.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmppswiljsq.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr.iter() {\n    if i.value % 2 == 0 {\n      if i.value < smallest_value {\n        smallest_value = i.value\n        smallest_index = i.index\n      }\n    }\n  }\n  return Vec::new(smallest_value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp89zlez69.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp89zlez69.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp89zlez69.rs:32:33\n   |\n32 |         smallest_value = i.value\n   |                                 ^ help: add `;` here\n33 |         smallest_index = i.index\n   |         -------------- unexpected token\n\nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp89zlez69.rs:30:10\n   |\n30 |     if i.value % 2 == 0 {\n   |          ^^^^^\n\nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp89zlez69.rs:31:12\n   |\n31 |       if i.value < smallest_value {\n   |            ^^^^^\n\nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp89zlez69.rs:32:28\n   |\n32 |         smallest_value = i.value\n   |                            ^^^^^\n\nerror[E0609]: no field `index` on type `&isize`\n  --> /tmp/tmp89zlez69.rs:33:28\n   |\n33 |         smallest_index = i.index\n   |                            ^^^^^\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmp89zlez69.rs:37:10\n    |\n37  |   return Vec::new(smallest_value, smallest_index)\n    |          ^^^^^^^^ --------------  -------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0061, E0609.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpou_9q4f5.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpou_9q4f5.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if (i % 2 == smallest_even_value) {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpo39d_phe.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return Vec::<isize>::new(value, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmphaq88r30.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpobpcphi9.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpegeetkhf.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpx_vs2vg3.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.min()\n  let smallest_index = arr.index(smallest_value)\n  let even_values = arr.filter((x) => x % 2 == 0)\n  let even_values_index = even_values.index(smallest_value)\n  let smallest_even_value = even_values[even_values_index]\n  let smallest_even_index = even_values.index(smallest_even_value)\n  let smallest_even_value_index = arr.index(smallest_even_value)\n  if smallest_even_value_index == smallest_index {\n    return [smallest_even_value, smallest_even_index]\n  } else {\n    return [smallest_value, smallest_index]\n  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5qsm40go.rs:27:33\n   |\n27 |   let smallest_value = arr.min()\n   |                                 ^ help: add `;` here\n28 |   let smallest_index = arr.index(smallest_value)\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5qsm40go.rs:28:49\n   |\n28 |   let smallest_index = arr.index(smallest_value)\n   |                                                 ^ help: add `;` here\n29 |   let even_values = arr.filter((x) => x % 2 == 0)\n   |   --- unexpected token\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp5qsm40go.rs:29:36\n   |\n29 |   let even_values = arr.filter((x) => x % 2 == 0)\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_value = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_value = arr.reduce((a, b) => a + b) % 2\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_even_index_index_index_index_index = arr.reduce((a, b) =>\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpgq7n3ac8.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgq7n3ac8.rs:45:58\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n45 |   let min_even_index_index_index_index_index = arr.reduce((a, b) =>\n   |                                                          ^ unclosed delimiter\n46 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((acc, node) => acc + node, 0)\n  let smallest_index = arr.reduce((acc, node) => acc + node, 0)\n  let smallest_node = arr.find(node => node % 2 == 0)\n  if smallest_even_value == 0 || arr.isEmpty() {\n    return Vec::new()\n  }\n  return Vec::new(smallest_node, smallest_index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpw3h5ncfy.rs:27:52\n   |\n27 |   let smallest_even_value = arr.reduce((acc, node) => acc + node, 0)\n   |                                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = 0\n  let min_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even {\n        min_even = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::new(min_index, min_even)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpkehj9lvk.rs:27:19\n   |\n27 |   let min_even = 0\n   |                   ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkehj9lvk.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpkehj9lvk.rs:32:21\n   |\n32 |         min_even = i\n   |                     ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpkehj9lvk.rs:37:10\n    |\n37  |   return Vec::new(min_index, min_even)\n    |          ^^^^^^^^ ---------  -------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr[0]\n  let smallest_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < smallest_value {\n        smallest_value = i\n        smallest_index = i\n      }\n    }\n  }\n  return [smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4foal37_.rs:27:30\n   |\n27 |   let smallest_value = arr[0]\n   |                              ^ help: add `;` here\n28 |   let smallest_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4foal37_.rs:28:25\n   |\n28 |   let smallest_index = 0\n   |                         ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `smallest_index`\n  --> /tmp/tmp4foal37_.rs:32:27\n   |\n32 |         smallest_value = i\n   |                           ^ help: add `;` here\n33 |         smallest_index = i\n   |         -------------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4foal37_.rs:37:10\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>` because of return type\n...\n37 |   return [smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array `[isize; 2]`\n   |\n   = note: expected struct `Vec<isize>`\n               found array `[isize; 2]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpou_9q4f5.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpou_9q4f5.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a,\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((a,\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7416s0v8.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp7416s0v8.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_value_index_value_index_value_index_value_index_value_index_value = arr.reduce((a,\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n    let smallest_index = arr.reduce((a, b) => a + b)\n    let index = arr.find(x => x == smallest_even_value)\n    let value = arr[index]\n    return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpdordz9t6.rs:27:49\n   |\n27 |     let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                                 ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x % 2 == smallest_even_value)\n  let value = arr[index]\n  return [value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpjey8mwwy.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_value = arr.reduce((a, b) => a + b)\n  let min_index_value = arr.reduce((a, b) => a + b)\n  let min_index_value_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp3x1pmi70.rs:27:42\n   |\n27 |   let min_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3x1pmi70.rs:42:108\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n42 |   let min_index_value_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((\n   |                                                                                                            ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let index = arr.find(x => x == smallest_even_value)\n  let value = arr[index]\n  return Vec::<isize>::new([value, index])\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmplcbertik.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even_value = 0\n  let min_index = 0\n  for i in arr {\n    if i % 2 == 0 {\n      if i < min_even_value {\n        min_even_value = i\n        min_index = i\n      }\n    }\n  }\n  return Vec::new(min_index, min_even_value)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjqb1o_wn.rs:27:25\n   |\n27 |   let min_even_value = 0\n   |                         ^ help: add `;` here\n28 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjqb1o_wn.rs:28:20\n   |\n28 |   let min_index = 0\n   |                    ^ help: add `;` here\n29 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpjqb1o_wn.rs:32:27\n   |\n32 |         min_even_value = i\n   |                           ^ help: add `;` here\n33 |         min_index = i\n   |         --------- unexpected token\n\nerror[E0061]: this function takes 0 arguments but 2 arguments were supplied\n   --> /tmp/tmpjqb1o_wn.rs:37:10\n    |\n37  |   return Vec::new(min_index, min_even_value)\n    |          ^^^^^^^^ ---------  -------------- supplied 2 arguments\n    |          |\n    |          expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_value = arr.reduce((a, b) => a if a % 2 == 0 else b)\n  let index = arr.find(x => x % 2 == 0)\n  return Vec::new(smallest_value, index)\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpr4caog1f.rs:27:42\n   |\n27 |   let smallest_value = arr.reduce((a, b) => a if a % 2 == 0 else b)\n   |                                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let smallest_even_value = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value_index_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_index_value_index_index_index_index_index_index = arr.reduce((a, b) => a + b) % 2;\n    let smallest_value_index_index_index_index_index_index_index = arr.reduce((a, b\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpn49qiptv.rs:27:49\n   |\n27 |     let smallest_even_value = arr.reduce((a, b) => a + b) % 2;\n   |                                                 ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpn49qiptv.rs:43:79\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                                         - closing delimiter possibly meant for this\n...\n43 |     let smallest_value_index_index_index_index_index_index_index = arr.reduce((a, b\n   |                                                                               ^ unclosed delimiter\n44 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n  let smallest_index = arr.reduce((a, b) => a + b)\n  let result = []\n  for i in arr {\n    if (i % 2 == smallest_even_value) {\n      result = [i, smallest_index]\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpo39d_phe.rs:27:47\n   |\n27 |   let smallest_even_value = arr.reduce((a, b) => a + b) % 2\n   |                                               ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n  let min_even = arr.reduce((a, b) => a + b) % 2\n  let min_index = arr.reduce((a, b) => a + b)\n  let min_even_index = arr.reduce((a, b) => a + b) % 2\n  let min_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.reduce((a, b) => a + b)\n  let min_index_index_index_index_index_index_index_index_index_index_index_index_index_index = arr.red\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp7r2bdu50.rs:27:36\n   |\n27 |   let min_even = arr.reduce((a, b) => a + b) % 2\n   |                                    ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}