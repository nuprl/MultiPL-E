{
  "name": "HumanEval_119_match_parens",
  "language": "rs",
  "prompt": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n",
  "tests": "}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = String::from(\"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpfu6bwneg.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpfu6bwneg.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpfu6bwneg.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpfu6bwneg.rs:29:5\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n29 |     res = String::from(\"Yes\");\n   |     ^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let ans = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        stack.push(s);\n      } else {\n        if (s == \")\") {\n          stack.pop();\n        } else {\n          stack.push(s);\n        }\n      }\n    } else {\n      if (stack.len() == 0) {\n        ans = String::from(\"Yes\");\n      }\n    }\n  }\n  return ans;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppetl2y_9.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmppetl2y_9.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmppetl2y_9.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmppetl2y_9.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppetl2y_9.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmppetl2y_9.rs:34:3\n   |\n34 |   return ans;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n34 |   { return ans; }\n   |   +             +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  for _ in lst {\n    if balance == 0 {\n      if lst[0].len() == 0 {\n        return \"Yes\"\n      }\n      return \"No\"\n    }\n    if lst[0].chars()[0] == '(' {\n      balance -= 1\n    } else {\n      balance += 1\n    }\n  }\n  return \"Yes\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpb1fr541f.rs:19:16\n   |\n19 |         return \"Yes\"\n   |                ^^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpb1fr541f.rs:23:8\n   |\n23 |     if lst[0].chars()[0] == '(' {\n   |        ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  for i in lst {\n    if i == \")()\" {\n      if stack.len == 0 {\n        return \"Yes\"\n      }\n      stack.pop();\n    } else if i == \"()\" {\n      stack.push(i);\n    } else {\n      return \"No\"\n    }\n  }\n  if stack.len == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpb5cnsj_m.rs:18:16\n   |\n18 |       if stack.len == 0 {\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n18 |       if stack.len() == 0 {\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb5cnsj_m.rs:19:16\n   |\n19 |         return \"Yes\"\n   |                ^^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpb5cnsj_m.rs:28:12\n   |\n28 |   if stack.len == 0 {\n   |            ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n28 |   if stack.len() == 0 {\n   |               ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let open = 0;\n  let close = 0;\n  let res = String::from(\"\");\n  for i in lst {\n    if i == \"(\" {\n      open += 1;\n      if open > close {\n        res += i;\n      }\n    } else if i == \")\" {\n      close += 1;\n      if open > close {\n        res += i;\n      }\n    }\n  }\n  if open == close {\n    return String::from(\"Yes\");\n  } else {\n    return String::from(\"No\");\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpv3fl_r1g.rs:23:16\n   |\n23 |         res += i;\n   |                ^\n   |                |\n   |                expected `&str`, found struct `String`\n   |                help: consider borrowing here: `&i`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv3fl_r1g.rs:28:16\n   |\n28 |         res += i;\n   |                ^\n   |                |\n   |                expected `&str`, found struct `String`\n   |                help: consider borrowing here: `&i`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_oxh6n91.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp_oxh6n91.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_oxh6n91.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp_oxh6n91.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  let result = String::from(\"No\");\n  for s in lst {\n    if s == \")()()\" {\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmpggvccprd.rs:114:3\n    |\n14  | fn match_parens(lst: Vec<String>) -> String {\n    |                                             - unclosed delimiter\n...\n17  |   for s in lst {\n    |                - unclosed delimiter\n18  |     if s == \")()()\" {\n    |                     - this delimiter might not be properly closed...\n...\n98  | }\n    | - ...as it matches this but it has different indentation\n...\n114 | }\n    |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpggvccprd.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpggvccprd.rs:17:3\n    |\n14  |   fn match_parens(lst: Vec<String>) -> String {\n    |                                        ------ expected `String` because of return type\n...\n17  | /   for s in lst {\n18  | |     if s == \")()()\" {\n19  | |       stack.pop();\n20  | |       stack.pop();\n...   |\n113 | |     assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n114 | | }\n    | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.push(\"(\")\n    } else if v == \"()\" {\n      if stack.is_empty() {\n        return \"No\"\n      } else {\n        stack.pop()\n      }\n    } else {\n      stack.push(v)\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp5i2vxfnu.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5i2vxfnu.rs:21:16\n   |\n21 |         return \"No\"\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.push(\"(()())\");\n      continue;\n    }\n    if s == \"()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()\" {\n      stack.push(\"()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.push(\"()()\");\n      continue;\n    }\n    if s == \"()()()\" {\n      stack.\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp67xwmam0.rs:107:3\n    |\n14  | fn match_parens(lst: Vec<String>) -> String {\n    |                                             - unclosed delimiter\n15  |   let stack = Stack::new();\n16  |   for s in lst {\n    |                - unclosed delimiter\n...\n89  |     if s == \"()()()\" {\n    |                      - this delimiter might not be properly closed...\n90  |       stack.\n91  | }\n    | - ...as it matches this but it has different indentation\n...\n107 | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp67xwmam0.rs:91:1\n   |\n91 | }\n   | ^\n\nerror[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp67xwmam0.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp67xwmam0.rs:16:3\n    |\n14  |   fn match_parens(lst: Vec<String>) -> String {\n    |                                        ------ expected `String` because of return type\n15  |     let stack = Stack::new();\n16  | /   for s in lst {\n17  | |     if s == \")()()\" {\n18  | |       stack.push(\"(()())\");\n19  | |       continue;\n...   |\n106 | |     assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n107 | | }\n    | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpwz3igey3.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpwz3igey3.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpwz3igey3.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  let result = String::from(\"No\");\n  for v in lst {\n    if v == \")()()\" {\n      stack.push(\"(()())\");\n    } else if v == \")()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"()\");\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop();\n    } else if v == \"()\" {\n      stack.pop\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpemfo1zeb.rs:90:3\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                             - unclosed delimiter\n...\n17 |   for v in lst {\n   |                - unclosed delimiter\n...\n72 |     } else if v == \"()\" {\n   |                         - this delimiter might not be properly closed...\n73 |       stack.pop\n74 | }\n   | - ...as it matches this but it has different indentation\n...\n90 | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpemfo1zeb.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpemfo1zeb.rs:17:3\n   |\n14 |   fn match_parens(lst: Vec<String>) -> String {\n   |                                        ------ expected `String` because of return type\n...\n17 | /   for v in lst {\n18 | |     if v == \")()()\" {\n19 | |       stack.push(\"(()())\");\n20 | |     } else if v == \")()\" {\n...  |\n89 | |     assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n90 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i.len() == 1 {\n      if i.get(0) == '(' {\n        stack.push(i);\n      } else if i.get(0) == ')' {\n        if stack.is_empty() {\n          return \"No\";\n        } else {\n          let top = stack.pop();\n          if top.len() != 1 || top.get(0) != '(' {\n            return \"No\";\n          }\n        }\n      }\n    } else {\n      if i.get(0) == '(' {\n        stack.push(i);\n      } else if i.get(0) == ')' {\n        if stack.is_empty() {\n          return \"No\";\n        } else {\n          let top = stack.pop();\n          if top.len() != 1 || top.get(0) != '(' {\n            return \"No\";\n          }\n        }\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpowx12mo2.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpowx12mo2.rs:18:16\n    |\n18  |       if i.get(0) == '(' {\n    |            --- ^ string indices are ranges of `usize`\n    |            |\n    |            required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpowx12mo2.rs:18:22\n   |\n18 |       if i.get(0) == '(' {\n   |                      ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&_>`\n              found type `char`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpowx12mo2.rs:20:23\n    |\n20  |       } else if i.get(0) == ')' {\n    |                   --- ^ string indices are ranges of `usize`\n    |                   |\n    |                   required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpowx12mo2.rs:20:29\n   |\n20 |       } else if i.get(0) == ')' {\n   |                             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&_>`\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for v in lst {\n    if v == \")\": {\n      if stack.is_empty(): {\n        return \"No\";\n      }\n      stack.pop();\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty(): {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmp_dp6t38x.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror: expected type, found `{`\n  --> /tmp/tmp_dp6t38x.rs:17:18\n   |\n17 |     if v == \")\": {\n   |                - ^ expected type\n   |                |\n   |                tried to parse a type due to this\n\nerror: expected type, found `{`\n  --> /tmp/tmp_dp6t38x.rs:26:24\n   |\n26 |   if stack.is_empty(): {\n   |                      - ^ expected type\n   |                      |\n   |                      tried to parse a type due to this\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  for i in lst {\n    if i == \"(\" {\n      left += 1;\n    } else if i == \")\" {\n      right += 1;\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpn3y6q6tx.rs:25:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n25 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for (let s of lst) {\n    if (s.len == 0) {\n      continue;\n    }\n    if (s.chars[0] == '(') {\n      stack.push(s);\n    } else {\n      if (stack.len == 0) {\n        result = String::from(\"No\");\n        break;\n      }\n      let top = stack.pop();\n      if (s.chars[0] == ')') {\n        if (top.chars[0] == '(') {\n          stack.push(top);\n        } else {\n          result = String::from(\"Yes\");\n          break;\n        }\n      } else {\n        result = String::from(\"No\");\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4a57s1_g.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp4a57s1_g.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp4a57s1_g.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp4a57s1_g.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4a57s1_g.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp4a57s1_g.rs:42:3\n   |\n42 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n42 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = \"No\";\n        break;\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:22:15\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n22 |         res = \"No\";\n   |               ^^^^- help: try using a conversion method: `.to_string()`\n   |               |\n   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:26:17\n   |\n26 |       if top != \"(\" {\n   |                 ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:27:15\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n27 |         res = \"No\";\n   |               ^^^^- help: try using a conversion method: `.to_string()`\n   |               |\n   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:33:11\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n33 |     res = \"Yes\";\n   |           ^^^^^- help: try using a conversion method: `.to_string()`\n   |           |\n   |           expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack: Vec<String> = Vec::new();\n  let result: String = String::from(\"No\");\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp9kj60il2.rs:19:7\n   |\n15 |   let stack: Vec<String> = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(s);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp9kj60il2.rs:22:9\n   |\n16 |   let result: String = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp9kj60il2.rs:24:9\n   |\n15 |   let stack: Vec<String> = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp9kj60il2.rs:29:5\n   |\n16 |   let result: String = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.push(\"()()\");\n    } else if s == \"()()\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpou1ovbcm.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpou1ovbcm.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = \"No\";\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        res = \"No\";\n        break;\n      }\n      let top = stack.pop();\n      if (top == \"(\" && s == \")\") {\n        res = \"Yes\";\n      } else {\n        stack.push(top);\n      }\n    } else {\n      stack.push(s);\n    }\n  }\n  if (stack.len() != 0) {\n    res = \"No\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpdlez5cxp.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpdlez5cxp.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpdlez5cxp.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpdlez5cxp.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdlez5cxp.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpdlez5cxp.rs:33:3\n   |\n33 |   if (stack.len() != 0) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n33 ~   { if (stack.len() != 0) {\n34 |     res = \"No\";\n35 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let res = String::from(\"No\");\n  for _ in lst {\n    if left == right {\n      res = String::from(\"Yes\");\n      break;\n    }\n    if left > right {\n      left += 1;\n    } else {\n      right += 1;\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpat92uvi1.rs:20:7\n   |\n17 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n20 |       res = String::from(\"Yes\");\n   |       ^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmpat92uvi1.rs:24:7\n   |\n15 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n24 |       left += 1;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `right`\n  --> /tmp/tmpat92uvi1.rs:26:7\n   |\n16 |   let right = 0;\n   |       -----\n   |       |\n   |       first assignment to `right`\n   |       help: consider making this binding mutable: `mut right`\n...\n26 |       right += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let balance = 0\n  for _ in lst {\n    if parens == 0 {\n      if balance == 0 {\n        return \"Yes\"\n      }\n      balance = 0\n    }\n    if parens == 0 {\n      balance += 1\n    } else {\n      balance -= 1\n    }\n    parens += 1\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxpahmxq3.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let balance = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxpahmxq3.rs:16:18\n   |\n16 |   let balance = 0\n   |                  ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpahmxq3.rs:20:16\n   |\n20 |         return \"Yes\"\n   |                ^^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for s in lst {\n    if s == \")\") {\n      if stack.len() == 0 {\n        res = \"No\";\n        break;\n      }\n      stack.pop();\n    } else if s == \"(\" {\n      stack.push(s);\n    }\n  }\n  if stack.len() == 0 {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp328d8pvk.rs:32:1\n   |\n28 |   if stack.len() == 0 {\n   |                       - this opening brace...\n29 |     res = \"Yes\";\n30 |   }\n   |   - ...matches this closing brace\n31 |   return res;\n32 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp328d8pvk.rs:17:16\n   |\n17 |   for s in lst {\n   |                ^ unclosed delimiter\n18 |     if s == \")\") {\n   |                ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = String::from(\"No\");\n  for _ in lst {\n    if balance == 0 {\n      res = String::from(\"Yes\");\n      break;\n    }\n    if balance == 1 {\n      balance = 0;\n    } else {\n      balance -= 1;\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmput7adq5n.rs:19:7\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n19 |       res = String::from(\"Yes\");\n   |       ^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmput7adq5n.rs:23:7\n   |\n15 |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n23 |       balance = 0;\n   |       ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmput7adq5n.rs:25:7\n   |\n15 |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n25 |       balance -= 1;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let last = 0\n  for i in lst {\n    if i == \"(\" {\n      parens += 1\n    } else if i == \")\" {\n      parens -= 1\n    }\n    if parens < 0 {\n      return \"No\"\n    }\n    last = i\n  }\n  if parens != 0 {\n    return \"No\"\n  }\n  return \"Yes\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5cj5o8sv.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let last = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp5cj5o8sv.rs:16:15\n   |\n16 |   let last = 0\n   |               ^ help: add `;` here\n17 |   for i in lst {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5cj5o8sv.rs:24:14\n   |\n24 |       return \"No\"\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5cj5o8sv.rs:26:12\n   |\n16 |   let last = 0\n   |              - expected due to this value\n...\n26 |     last = i\n   |            ^ expected integer, found struct `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for v in lst {\n    if v == \")\":\n      if stack.is_empty():\n        return \"No\";\n      stack.pop();\n    else:\n      stack.push(v);\n  }\n  if stack.is_empty():\n    return \"Yes\";\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpp_76l89z.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror: expected identifier, found keyword `if`\n  --> /tmp/tmpp_76l89z.rs:18:7\n   |\n18 |       if stack.is_empty():\n   |       ^^ expected identifier, found keyword\n\nerror: expected type, found keyword `if`\n  --> /tmp/tmpp_76l89z.rs:18:7\n   |\n17 |     if v == \")\":\n   |                - help: try using a semicolon: `;`\n18 |       if stack.is_empty():\n   |       ^^ expected type\n\nerror: expected identifier, found keyword `return`\n  --> /tmp/tmpp_76l89z.rs:25:5\n   |\n25 |     return \"Yes\";\n   |     ^^^^^^ expected identifier, found keyword\n\nerror: expected type, found keyword `return`\n  --> /tmp/tmpp_76l89z.rs:25:5\n   |\n24 |   if stack.is_empty():\n   |                      - help: try using a semicolon: `;`\n25 |     return \"Yes\";\n   |     ^^^^^^ expected type\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.pop();\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpnqb7k40c.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnqb7k40c.rs:31:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n31 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp3yt5zuwv.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let result = \"\";\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    } else {\n      result += i;\n    }\n  }\n  if parens == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpssksjxkl.rs:23:7\n   |\n23 |       result += i;\n   |       ------^--^^\n   |       |      |\n   |       |      `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpssksjxkl.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = \"No\";\n        break;\n      } else {\n        let top = stack.pop();\n        if top != \"(\" {\n          res = \"No\";\n          break;\n        }\n      }\n    }\n  }\n  if !stack.is_empty() {\n    res = \"No\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpx02cdyhe.rs:22:15\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n22 |         res = \"No\";\n   |               ^^^^- help: try using a conversion method: `.to_string()`\n   |               |\n   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx02cdyhe.rs:26:19\n   |\n26 |         if top != \"(\" {\n   |                   ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx02cdyhe.rs:27:17\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n27 |           res = \"No\";\n   |                 ^^^^- help: try using a conversion method: `.to_string()`\n   |                 |\n   |                 expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx02cdyhe.rs:34:11\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n34 |     res = \"No\";\n   |           ^^^^- help: try using a conversion method: `.to_string()`\n   |           |\n   |           expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        return \"No\";\n      }\n    }\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpvcdpr7jn.rs:18:13\n   |\n18 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpvcdpr7jn.rs:20:16\n   |\n20 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcdpr7jn.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let last_paren = 0;\n  let result = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      result = \"Yes\";\n      break;\n    }\n    if parens == 0 && last_paren != 0 {\n      result = \"Yes\";\n      break;\n    }\n    last_paren = i.len();\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpm_edwr6e.rs:34:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n34 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        res = String::from(\"Yes\");\n        break;\n      }\n      if (s == \")\") {\n        stack.pop();\n      } else {\n        stack.push(s);\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpb124s0u6.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpb124s0u6.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpb124s0u6.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpb124s0u6.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpb124s0u6.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpb124s0u6.rs:30:3\n   |\n30 |   return res;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n30 |   { return res; }\n   |   +             +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        result = String::from(\"Yes\");\n        break;\n      }\n      if (s == \"(\" && stack.last() == \")\") {\n        stack.pop();\n      } else {\n        stack.push(s);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp3p5zu9rg.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp3p5zu9rg.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp3p5zu9rg.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp3p5zu9rg.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp3p5zu9rg.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp3p5zu9rg.rs:30:3\n   |\n30 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n30 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.push(\"()()\");\n    } else if s == \"()()\" {\n      stack.pop();\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpg6pyjz37.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6pyjz37.rs:26:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n26 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let lst_idx = 0;\n  let res = String::from(\"No\");\n  while (lst_idx < lst_len) {\n    let lst_str = lst[lst_idx];\n    if (lst_str.len() == 1) {\n      lst_idx += 1;\n      continue;\n    }\n    let lst_str_idx = 0;\n    let res_idx = 0;\n    while (lst_str_idx < lst_str.len()) {\n      let lst_str_ch = lst_str[lst_str_idx];\n      if (lst_str_ch == '(') {\n        lst_str_idx += 1;\n        continue;\n      }\n      if (lst_str_ch == ')') {\n        lst_str_idx += 1;\n        continue;\n      }\n      if (lst_str_idx == 0) {\n        res_idx += 1;\n        continue;\n      }\n      if (lst_str_ch == '(') {\n        res_idx += 1;\n        lst_str_idx += 1;\n        continue;\n      }\n      if (lst_str_ch == ')') {\n        res_idx -= 1;\n        lst_str_idx += 1;\n        continue;\n      }\n      res_idx += 1;\n      lst_str_idx += 1;\n    }\n    if (res_idx == 0) {\n      res = String::from(\"Yes\");\n      break;\n    }\n    lst_idx += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpws9xnaif.rs:18:9\n   |\n18 |   while (lst_idx < lst_len) {\n   |         ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -   while (lst_idx < lst_len) {\n18 +   while lst_idx < lst_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpws9xnaif.rs:20:8\n   |\n20 |     if (lst_str.len() == 1) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (lst_str.len() == 1) {\n20 +     if lst_str.len() == 1 {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpws9xnaif.rs:26:11\n   |\n26 |     while (lst_str_idx < lst_str.len()) {\n   |           ^                           ^\n   |\nhelp: remove these parentheses\n   |\n26 -     while (lst_str_idx < lst_str.len()) {\n26 +     while lst_str_idx < lst_str.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpws9xnaif.rs:28:10\n   |\n28 |       if (lst_str_ch == '(') {\n   |          ^                 ^\n   |\nhelp: remove these parentheses\n   |\n28 -       if (lst_str_ch == '(') {\n28 +       if lst_str_ch == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpws9xnaif.rs:32:10\n   |\n32 |       if (lst_str_ch == ')') {\n   |          ^                 ^\n   |\nhelp: remove these parentheses\n   |\n32 -       if (lst_str_ch == ')') {\n32 +       if lst_str_ch == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpws9xnaif.rs:36:10\n   |\n36 |       if (lst_str_idx == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n36 -       if (lst_str_idx == 0) {\n36 +       if lst_str_idx == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpws9xnaif.rs:40:10\n   |\n40 |       if (lst_str_ch == '(') {\n   |          ^                 ^\n   |\nhelp: remove these parentheses\n   |\n40 -       if (lst_str_ch == '(') {\n40 +       if lst_str_ch == '(' {\n   | \n\nwa",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      left += 1;\n    } else if i == \")\" {\n      right += 1;\n    } else {\n      res += i;\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp6188e_81.rs:24:7\n   |\n24 |       res += i;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6188e_81.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0\n  let right = 0\n  for i in lst {\n    if i == \"(\" {\n      left += 1\n    } else {\n      right += 1\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpuvtcsgas.rs:15:15\n   |\n15 |   let left = 0\n   |               ^ help: add `;` here\n16 |   let right = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpuvtcsgas.rs:16:16\n   |\n16 |   let right = 0\n   |                ^ help: add `;` here\n17 |   for i in lst {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuvtcsgas.rs:25:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n25 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.is_empty() {\n        result = \"No\";\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = \"Yes\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp3bypzd08.rs:22:18\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n22 |         result = \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3bypzd08.rs:30:14\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n30 |     result = \"Yes\";\n   |              ^^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  if (lst_len == 0) {\n    return \"Yes\";\n  }\n  let left = 0;\n  let right = lst_len - 1;\n  let balance = 0;\n  let res = \"\";\n  while (left < right) {\n    if (lst[left] == \"(\" && lst[right] == \")\") {\n      balance += 1;\n    } else if (lst[left] == \")\" && lst[right] == \"(\" && balance > 0) {\n      balance -= 1;\n    } else {\n      res += lst[left];\n    }\n    left += 1;\n    right -= 1;\n  }\n  if (balance == 0) {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxqiq53ab.rs:16:6\n   |\n16 |   if (lst_len == 0) {\n   |      ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   if (lst_len == 0) {\n16 +   if lst_len == 0 {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxqiq53ab.rs:23:9\n   |\n23 |   while (left < right) {\n   |         ^            ^\n   |\nhelp: remove these parentheses\n   |\n23 -   while (left < right) {\n23 +   while left < right {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxqiq53ab.rs:24:8\n   |\n24 |     if (lst[left] == \"(\" && lst[right] == \")\") {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (lst[left] == \"(\" && lst[right] == \")\") {\n24 +     if lst[left] == \"(\" && lst[right] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxqiq53ab.rs:26:15\n   |\n26 |     } else if (lst[left] == \")\" && lst[right] == \"(\" && balance > 0) {\n   |               ^                                                    ^\n   |\nhelp: remove these parentheses\n   |\n26 -     } else if (lst[left] == \")\" && lst[right] == \"(\" && balance > 0) {\n26 +     } else if lst[left] == \")\" && lst[right] == \"(\" && balance > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxqiq53ab.rs:34:6\n   |\n34 |   if (balance == 0) {\n   |      ^            ^\n   |\nhelp: remove these parentheses\n   |\n34 -   if (balance == 0) {\n34 +   if balance == 0 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxqiq53ab.rs:17:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n17 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::concat(result, \"No\");\n        return result;\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        result = String::concat(result, \"No\");\n        return result;\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::concat(result, \"Yes\");\n    return result;\n  }\n  result = String::concat(result, \"No\");\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpsxdyc166.rs:22:26\n   |\n22 |         result = String::concat(result, \"No\");\n   |                          ^^^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxdyc166.rs:26:17\n   |\n26 |       if top != \"(\" {\n   |                 ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpsxdyc166.rs:27:26\n   |\n27 |         result = String::concat(result, \"No\");\n   |                          ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpsxdyc166.rs:33:22\n   |\n33 |     result = String::concat(result, \"Yes\");\n   |                      ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpsxdyc166.rs:36:20\n   |\n36 |   result = String::concat(result, \"No\");\n   |                    ^^^^^^ function or associated item not found in `String`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0\n  let right = 0\n  for _ in lst {\n    if left == right {\n      left += 1\n    } else if left > right {\n      right += 1\n    } else {\n      left -= 1\n    }\n  }\n  return left == right ? \"Yes\" : \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp8mvad26k.rs:15:15\n   |\n15 |   let left = 0\n   |               ^ help: add `;` here\n16 |   let right = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp8mvad26k.rs:16:16\n   |\n16 |   let right = 0\n   |                ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"Yes\"`\n  --> /tmp/tmp8mvad26k.rs:26:26\n   |\n26 |   return left == right ? \"Yes\" : \"No\"\n   |                          ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      parens += 1;\n    } else if s == \")\" {\n      parens -= 1;\n    } else {\n      res += s;\n    }\n  }\n  if parens == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpxqavsd1k.rs:23:7\n   |\n23 |       res += s;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxqavsd1k.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmplokgkd6h.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplokgkd6h.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return \"Yes\";\n  }\n  let left_parens = 0;\n  let right_parens = 0;\n  for i in 0..lst_len {\n    if lst[i] == \"(\" {\n      left_parens += 1;\n    } else if lst[i] == \")\" {\n      right_parens += 1;\n    }\n  }\n  if left_parens == right_parens {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpbfeijuyb.rs:17:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n17 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmplokgkd6h.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplokgkd6h.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    res += i;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpiacvfmds.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpiacvfmds.rs:26:5\n   |\n26 |     res += i;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      balance += 1;\n    } else if i == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      result = String::from(\"Yes\");\n      break;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpo4xrwhul.rs:19:7\n   |\n15 |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n19 |       balance += 1;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpo4xrwhul.rs:21:7\n   |\n15 |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n21 |       balance -= 1;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmpo4xrwhul.rs:24:7\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n24 |       result = String::from(\"Yes\");\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      left += 1;\n    } else if i == \")\" {\n      right += 1;\n    }\n    if left == right {\n      res += i;\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpd_onkr52.rs:25:7\n   |\n25 |       res += i;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_onkr52.rs:29:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n29 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let res = \"\"\n  for _ in lst {\n    if parens == 0 {\n      res += \"Yes\"\n    } else {\n      res += \"No\"\n    }\n    if s.chars[0] == \"(\" {\n      parens += 1\n    } else {\n      parens -= 1\n    }\n  }\n  return res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp7gx2ql__.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let res = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp7gx2ql__.rs:16:15\n   |\n16 |   let res = \"\"\n   |               ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmp7gx2ql__.rs:23:8\n   |\n23 |     if s.chars[0] == \"(\" {\n   |        ^ not found in this scope\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp7gx2ql__.rs:19:7\n   |\n19 |       res += \"Yes\"\n   |       ---^^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp7gx2ql__.rs:21:7\n   |\n21 |       res += \"No\"\n   |       ---^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gx2ql__.rs:29:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n29 |   return res\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpv518y8nm.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpv518y8nm.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpv518y8nm.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = \"No\";\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpkueb2axr.rs:22:15\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n22 |         res = \"No\";\n   |               ^^^^- help: try using a conversion method: `.to_string()`\n   |               |\n   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkueb2axr.rs:30:11\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n30 |     res = \"Yes\";\n   |           ^^^^^- help: try using a conversion method: `.to_string()`\n   |           |\n   |           expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let left = 0;\n  let right = lst_len - 1;\n  let res = String::from(\"No\");\n  while (left < right) {\n    if (lst[left] == \"(\" && lst[right] == \")\") {\n      left += 1;\n      right -= 1;\n    } else if (lst[left] == \")\") {\n      left += 1;\n    } else if (lst[right] == \"(\" && lst[left] == \")\") {\n      right -= 1;\n    } else if (lst[right] == \"(\" && lst[left] != \")\") {\n      left += 1;\n    } else {\n      return res;\n    }\n  }\n  return String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1wnpweas.rs:19:9\n   |\n19 |   while (left < right) {\n   |         ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -   while (left < right) {\n19 +   while left < right {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1wnpweas.rs:20:8\n   |\n20 |     if (lst[left] == \"(\" && lst[right] == \")\") {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (lst[left] == \"(\" && lst[right] == \")\") {\n20 +     if lst[left] == \"(\" && lst[right] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1wnpweas.rs:23:15\n   |\n23 |     } else if (lst[left] == \")\") {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n23 -     } else if (lst[left] == \")\") {\n23 +     } else if lst[left] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1wnpweas.rs:25:15\n   |\n25 |     } else if (lst[right] == \"(\" && lst[left] == \")\") {\n   |               ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n25 -     } else if (lst[right] == \"(\" && lst[left] == \")\") {\n25 +     } else if lst[right] == \"(\" && lst[left] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1wnpweas.rs:27:15\n   |\n27 |     } else if (lst[right] == \"(\" && lst[left] != \")\") {\n   |               ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n27 -     } else if (lst[right] == \"(\" && lst[left] != \")\") {\n27 +     } else if lst[right] == \"(\" && lst[left] != \")\" {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmp1wnpweas.rs:21:7\n   |\n16 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n21 |       left += 1;\n   |       ^^^^^^^^^ cannot assign twice to immutable ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        result = String::from(\"Yes\");\n        break;\n      }\n      if (s == \")\") {\n        stack.pop();\n      } else {\n        stack.push(s);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpqsfo3zgs.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpqsfo3zgs.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpqsfo3zgs.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpqsfo3zgs.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpqsfo3zgs.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpqsfo3zgs.rs:30:3\n   |\n30 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n30 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let last = 0\n  let res = \"\"\n  for i in lst {\n    if i == \"(\" {\n      parens += 1\n    } else if i == \")\" {\n      parens -= 1\n    }\n    if parens == 0 {\n      res += i\n    }\n  }\n  if parens == 0 {\n    return String::from(res)\n  }\n  return String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_y8f5xma.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let last = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp_y8f5xma.rs:16:15\n   |\n16 |   let last = 0\n   |               ^ help: add `;` here\n17 |   let res = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_y8f5xma.rs:17:15\n   |\n17 |   let res = \"\"\n   |               ^ help: add `;` here\n18 |   for i in lst {\n   |   --- unexpected token\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp_y8f5xma.rs:25:7\n   |\n25 |       res += i\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0368`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      left += 1;\n    } else if i == \")\" {\n      right += 1;\n    } else {\n      if left == right {\n        res += i;\n      }\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp_ryw5440.rs:25:9\n   |\n25 |         res += i;\n   |         ---^--^^\n   |         |   |\n   |         |   `+` cannot be used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ryw5440.rs:30:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return \"Yes\";\n  }\n  let left = 0;\n  let right = lst_len - 1;\n  let balance = 0;\n  while (left < right) {\n    if (lst[left] == \"(\" && lst[right] == \")\") {\n      balance += 1;\n    } else if (lst[left] == \")\" && lst[right] == \"(\" && balance > 0) {\n      balance -= 1;\n    }\n    left += 1;\n    right -= 1;\n  }\n  if (balance == 0) {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp70go2sn9.rs:22:9\n   |\n22 |   while (left < right) {\n   |         ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -   while (left < right) {\n22 +   while left < right {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp70go2sn9.rs:23:8\n   |\n23 |     if (lst[left] == \"(\" && lst[right] == \")\") {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n23 -     if (lst[left] == \"(\" && lst[right] == \")\") {\n23 +     if lst[left] == \"(\" && lst[right] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp70go2sn9.rs:25:15\n   |\n25 |     } else if (lst[left] == \")\" && lst[right] == \"(\" && balance > 0) {\n   |               ^                                                    ^\n   |\nhelp: remove these parentheses\n   |\n25 -     } else if (lst[left] == \")\" && lst[right] == \"(\" && balance > 0) {\n25 +     } else if lst[left] == \")\" && lst[right] == \"(\" && balance > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp70go2sn9.rs:31:6\n   |\n31 |   if (balance == 0) {\n   |      ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -   if (balance == 0) {\n31 +   if balance == 0 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp70go2sn9.rs:17:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n17 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let stack = Vec::new();\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n      stack.push(i);\n    } else if i == \")\" {\n      parens -= 1;\n      if parens < 0 {\n        return \"No\";\n      }\n      if parens == 0 {\n        stack.pop();\n      }\n    }\n  }\n  if parens == 0 {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmmgjhwif.rs:24:16\n   |\n24 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  if (lst_len == 0) {\n    return \"No\";\n  }\n  let left_parens = 0;\n  let right_parens = 0;\n  for (let i = 0; i < lst_len; i++) {\n    let s = lst[i];\n    if (s == \"(\") {\n      left_parens += 1;\n    } else if (s == \")\") {\n      right_parens += 1;\n    }\n  }\n  if (left_parens == right_parens) {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0307nd6x.rs:21:8\n   |\n21 |   for (let i = 0; i < lst_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp0307nd6x.rs:21:12\n   |\n21 |   for (let i = 0; i < lst_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0307nd6x.rs:21:14\n   |\n21 |   for (let i = 0; i < lst_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0307nd6x.rs:21:13\n   |\n21 |   for (let i = 0; i < lst_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0307nd6x.rs:21:14\n   |\n21 |   for (let i = 0; i < lst_len; i++) {\n   |              ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0307nd6x.rs:16:6\n   |\n16 |   if (lst_len == 0) {\n   |      ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   if (lst_len == 0) {\n16 +   if lst_len == 0 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0307nd6x.rs:17:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n17 |     return \"No\";\n   |            ^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  for i in lst {\n    if i.len == 1 {\n      if i.chars[0] == '(' {\n        stack.push(i);\n      } else if i.chars[0] == ')' {\n        if stack.len == 0 {\n          return \"No\";\n        }\n        let top = stack.pop();\n        if top.chars[0] != '(' {\n          return \"No\";\n        }\n      }\n    } else {\n      if i.chars[0] == '(' {\n        stack.push(i);\n      } else if i.chars[0] == ')' {\n        if stack.len == 0 {\n          return \"No\";\n        }\n        let top = stack.pop();\n        if top.chars[0] != '(' {\n          return \"No\";\n        }\n      }\n    }\n  }\n  if stack.len != 0 {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz5yrbbzd.rs:17:10\n   |\n17 |     if i.len == 1 {\n   |          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |     if i.len() == 1 {\n   |             ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpz5yrbbzd.rs:18:12\n   |\n18 |       if i.chars[0] == '(' {\n   |            ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n18 |       if i.chars()[0] == '(' {\n   |                 ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpz5yrbbzd.rs:20:19\n   |\n20 |       } else if i.chars[0] == ')' {\n   |                   ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n20 |       } else if i.chars()[0] == ')' {\n   |                        ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpz5yrbbzd.rs:21:18\n   |\n21 |         if stack.len == 0 {\n   |                  ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |         if stack.len() == 0 {\n   |                     ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz5yrbbzd.rs:22:18\n   |\n22 |           return \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror[E0609]: no field `chars` on type `Option<String>`\n  --> /tmp/tmpz5yrbbzd.rs:25:16\n   |\n25 |         if top.chars[0] != '(' {\n   |                ^^^^^\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpz5yrbbzd.rs:30:12\n   |\n30 |       if i.chars[0] == '(' {\n   |            ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n30 |       if i.chars()[0] == '(' {\n   |                 ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpz5yrbbzd.rs:32:19\n   |\n32 |       } else if i.chars[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let lst_idx = 0;\n  let res = String::from(\"No\");\n  while (lst_idx < lst_len) {\n    let curr = lst[lst_idx];\n    if (curr == \")\") {\n      if (lst_idx + 1 < lst_len && lst[lst_idx + 1] == \"(\") {\n        lst_idx += 2;\n      } else {\n        lst_idx += 1;\n      }\n    } else {\n      lst_idx += 1;\n    }\n  }\n  if (lst_idx == lst_len) {\n    res = String::from(\"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkk7ruooh.rs:18:9\n   |\n18 |   while (lst_idx < lst_len) {\n   |         ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -   while (lst_idx < lst_len) {\n18 +   while lst_idx < lst_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkk7ruooh.rs:20:8\n   |\n20 |     if (curr == \")\") {\n   |        ^           ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (curr == \")\") {\n20 +     if curr == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkk7ruooh.rs:21:10\n   |\n21 |       if (lst_idx + 1 < lst_len && lst[lst_idx + 1] == \"(\") {\n   |          ^                                                ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (lst_idx + 1 < lst_len && lst[lst_idx + 1] == \"(\") {\n21 +       if lst_idx + 1 < lst_len && lst[lst_idx + 1] == \"(\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkk7ruooh.rs:30:6\n   |\n30 |   if (lst_idx == lst_len) {\n   |      ^                  ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (lst_idx == lst_len) {\n30 +   if lst_idx == lst_len {\n   | \n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpkk7ruooh.rs:19:16\n   |\n19 |     let curr = lst[lst_idx];\n   |                ^^^^^^^^^^^^\n   |                |\n   |                move occurs because value has type `String`, which does not implement the `Copy` trait\n   |                help: consider borrowing here: `&lst[lst_idx]`\n\nerror[E0384]: cannot assign twice to immutable variable `lst_idx`\n  --> /tmp/tmpkk7ruooh.rs:22:9\n   |\n16 |   let lst_idx = 0;\n   |       -------\n   |       |\n   |       first assignment to `lst_idx`\n   |       help: consider making this binding mutable: `mut lst_idx`\n...\n22 |         lst_idx += 2;\n   |         ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `lst_idx`\n  --> /tmp/",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let str = String::from(\"\");\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    str += i;\n  }\n  if parens == 0 {\n    return String::from(\"Yes\");\n  }\n  return String::from(\"No\");\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp9nhukz79.rs:23:12\n   |\n23 |     str += i;\n   |            ^\n   |            |\n   |            expected `&str`, found struct `String`\n   |            help: consider borrowing here: `&i`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      stack.push(s);\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp4avttnqf.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4avttnqf.rs:31:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n31 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if v == \"()\" {\n      stack.push(v);\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp8_3z88gd.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_3z88gd.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let left = 0;\n  let right = 0;\n  let res = \"No\";\n  for (i in 0..lst_len) {\n    if (lst[i] == \"(\") {\n      left += 1;\n    } else {\n      right += 1;\n    }\n    if (left == right) {\n      res = \"Yes\";\n      break;\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp8pe9jkg8.rs:19:10\n   |\n19 |   for (i in 0..lst_len) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp8pe9jkg8.rs:19:7\n   |\n19 |   for (i in 0..lst_len) {\n   |       ^               ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n19 -   for (i in 0..lst_len) {\n19 +   for i in 0..lst_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8pe9jkg8.rs:20:8\n   |\n20 |     if (lst[i] == \"(\") {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (lst[i] == \"(\") {\n20 +     if lst[i] == \"(\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8pe9jkg8.rs:25:8\n   |\n25 |     if (left == right) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (left == right) {\n25 +     if left == right {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8pe9jkg8.rs:30:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmplokgkd6h.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplokgkd6h.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i.len == 1 {\n      if i.chars[0] == '(' {\n        stack.push(i);\n      } else if i.chars[0] == ')' {\n        if !stack.is_empty() && stack.peek().chars[0] == '(' {\n          stack.pop();\n        } else {\n          return \"No\";\n        }\n      }\n    } else {\n      return \"No\";\n    }\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp68tmza59.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp68tmza59.rs:17:10\n   |\n17 |     if i.len == 1 {\n   |          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |     if i.len() == 1 {\n   |             ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmp68tmza59.rs:18:12\n   |\n18 |       if i.chars[0] == '(' {\n   |            ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n18 |       if i.chars()[0] == '(' {\n   |                 ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmp68tmza59.rs:20:19\n   |\n20 |       } else if i.chars[0] == ')' {\n   |                   ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n20 |       } else if i.chars()[0] == ')' {\n   |                        ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp68tmza59.rs:24:18\n   |\n24 |           return \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0433, E0615.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.push(s);\n    } else if s == \"()\" {\n      if stack.is_empty() {\n        return \"No\";\n      }\n      let top = stack.pop();\n      if top != \"()\" {\n        return \"No\";\n      }\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmppez2284g.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppez2284g.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    } else {\n      res += s;\n    }\n  }\n  if balance == 0 {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpu2lbwtow.rs:23:7\n   |\n23 |       res += s;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu2lbwtow.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = String::from(\"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpfu6bwneg.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpfu6bwneg.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpfu6bwneg.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpfu6bwneg.rs:29:5\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n29 |     res = String::from(\"Yes\");\n   |     ^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let stack = [0];\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    if parens == 0 {\n      stack.pop();\n    }\n    stack.push(i);\n  }\n  if parens != 0 {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpan0__cw1.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpan0__cw1.rs:27:13\n   |\n27 |       stack.pop();\n   |             ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpan0__cw1.rs:29:11\n   |\n29 |     stack.push(i);\n   |           ^^^^ method not found in `[{integer}; 1]`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  for v in lst {\n    if v == \")()\" {\n      if !stack.is_empty() && stack.last() == \"(\" {\n        stack.pop();\n      } else {\n        stack.push(\"()\");\n      }\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpbdduzias.rs:18:47\n   |\n18 |       if !stack.is_empty() && stack.last() == \"(\" {\n   |                                               ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n18 |       if !stack.is_empty() && stack.last() == Some(\"(\") {\n   |                                               +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdduzias.rs:24:18\n   |\n24 |       stack.push(v);\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&v`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdduzias.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.is_empty() {\n        result = \"No\";\n        break;\n      } else {\n        result = \"Yes\";\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpbp2_mwnl.rs:22:18\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n22 |         result = \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp2_mwnl.rs:25:18\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n25 |         result = \"Yes\";\n   |                  ^^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = \"No\";\n        break;\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if !stack.is_empty() {\n    res = \"No\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmps91sgfry.rs:26:17\n   |\n26 |       if top != \"(\" {\n   |                 ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps91sgfry.rs:35:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n35 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpdll9or4a.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdll9or4a.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let res = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if stack.length == 0 {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmppi46czcp.rs:19:13\n   |\n19 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmppi46czcp.rs:21:16\n   |\n21 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0609]: no field `length` on type `[{integer}; 1]`\n  --> /tmp/tmppi46czcp.rs:27:12\n   |\n27 |   if stack.length == 0 {\n   |            ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppi46czcp.rs:30:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for v in lst {\n    if v == \")()\" {\n      if stack.len() == 0 {\n        res = String::from(\"Yes\");\n        break;\n      }\n      stack.pop();\n    } else {\n      stack.push(v);\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmp1q7ml_sn.rs:20:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n20 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp1q7ml_sn.rs:23:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n23 |       stack.pop();\n   |       ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp1q7ml_sn.rs:25:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  for _ in lst {\n    if parens == 0 {\n      parens += 1;\n    } else if parens == 1 {\n      parens -= 1;\n    } else {\n      return \"No\";\n    }\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp47hqiz81.rs:22:14\n   |\n22 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      parens += 1;\n    } else if s == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmprkl9sauv.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmprkl9sauv.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()()\" {\n      if stack.is_empty() {\n        return \"Yes\";\n      }\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      if stack.is_empty() {\n        return \"Yes\";\n      }\n      stack.pop();\n      stack.pop();\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpo6x54p4l.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6x54p4l.rs:19:16\n   |\n19 |         return \"Yes\";\n   |                ^^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i.len == 1 {\n      if i.chars[0] == '(' {\n        stack.push(i);\n      } else if i.chars[0] == ')' {\n        if stack.len == 0 {\n          res = String::from(\"No\");\n          break;\n        } else {\n          stack.pop();\n        }\n      }\n    } else {\n      if stack.len == 0 {\n        res = String::from(\"No\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.len != 0 {\n    res = String::from(\"No\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp679rq6y8.rs:18:10\n   |\n18 |     if i.len == 1 {\n   |          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n18 |     if i.len() == 1 {\n   |             ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmp679rq6y8.rs:19:12\n   |\n19 |       if i.chars[0] == '(' {\n   |            ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n19 |       if i.chars()[0] == '(' {\n   |                 ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmp679rq6y8.rs:21:19\n   |\n21 |       } else if i.chars[0] == ')' {\n   |                   ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n21 |       } else if i.chars()[0] == ')' {\n   |                        ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp679rq6y8.rs:22:18\n   |\n22 |         if stack.len == 0 {\n   |                  ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n22 |         if stack.len() == 0 {\n   |                     ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp679rq6y8.rs:30:16\n   |\n30 |       if stack.len == 0 {\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n30 |       if stack.len() == 0 {\n   |                   ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp679rq6y8.rs:38:12\n   |\n38 |   if stack.len != 0 {\n   |            ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n38 |   if stack.len() != 0 {\n   |               ++\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0615, E0616.\nFor more information about an error, try `rustc --explain E0615`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  for _ in lst {\n    if left == right {\n      left = 0;\n      right = 0;\n    }\n    if left > right {\n      left += 1;\n    } else if right > left {\n      right += 1;\n    } else {\n      left += 1;\n      right += 1;\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp7le92ong.rs:32:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n32 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = \"No\";\n  for s in lst {\n    if s == \")()\" {\n      if stack.len() == 0 {\n        res = \"Yes\";\n        break;\n      }\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpb7fzvr12.rs:30:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result += \"No\";\n        return result;\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        result += \"No\";\n        return result;\n      }\n    }\n  }\n  if stack.is_empty() {\n    result += \"Yes\";\n    return result;\n  }\n  result += \"No\";\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpagm6h9jb.rs:26:17\n   |\n26 |       if top != \"(\" {\n   |                 ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  for i in lst {\n    if i == \")()\" {\n      if stack.len() == 0 {\n        return \"No\"\n      }\n      stack.pop();\n    } else if i == \"()\" {\n      stack.push(i);\n    } else {\n      stack.push(i);\n    }\n  }\n  if stack.len() == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpekwgsjes.rs:19:16\n   |\n19 |         return \"No\"\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpdll9or4a.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdll9or4a.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      if !stack.is_empty() && stack.peek() == \"(\" {\n        stack.pop();\n      } else {\n        stack.push(\"(\", \")\");\n      }\n    } else if v == \"()\" {\n      stack.push(\"(\", \")\");\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw44tjv17.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw44tjv17.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp3yt5zuwv.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [];\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.pop() != \"(\":\n        return \"No\";\n    }\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `return`\n  --> /tmp/tmpf5s181al.rs:21:9\n   |\n21 |         return \"No\";\n   |         ^^^^^^ expected identifier, found keyword\n\nerror: expected type, found keyword `return`\n  --> /tmp/tmpf5s181al.rs:21:9\n   |\n20 |       if stack.pop() != \"(\":\n   |                            - help: try using a semicolon: `;`\n21 |         return \"No\";\n   |         ^^^^^^ expected type\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpf5s181al.rs:18:13\n   |\n18 |       stack.push(s);\n   |             ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5s181al.rs:24:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n24 |   return \"Yes\";\n   |          ^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpy3ca6dd6.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy3ca6dd6.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      left += 1;\n    } else if i == \")\" {\n      right += 1;\n    }\n    if left == right {\n      result = String::from(\"Yes\");\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmpppbqi6hj.rs:20:7\n   |\n15 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n20 |       left += 1;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `right`\n  --> /tmp/tmpppbqi6hj.rs:22:7\n   |\n16 |   let right = 0;\n   |       -----\n   |       |\n   |       first assignment to `right`\n   |       help: consider making this binding mutable: `mut right`\n...\n22 |       right += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmpppbqi6hj.rs:25:7\n   |\n17 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n25 |       result = String::from(\"Yes\");\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let left = 0;\n  let right = lst_len - 1;\n  let balance = 0;\n  let res = String::from(\"\");\n  while (left < right) {\n    if (lst[left] == \"(\" && lst[right] == \")\") {\n      balance += 1;\n      left += 1;\n      right -= 1;\n    } else if (lst[left] == \")\") {\n      balance -= 1;\n      left += 1;\n    } else if (lst[right] == \"(\" && balance == 0) {\n      balance += 1;\n      right -= 1;\n    } else if (lst[right] == \"(\" && balance == 1) {\n      balance -= 1;\n      right -= 1;\n    } else {\n      res = String::from(\"No\");\n      break;\n    }\n  }\n  if (balance == 0) {\n    res = String::from(\"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfu3_m_o_.rs:20:9\n   |\n20 |   while (left < right) {\n   |         ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -   while (left < right) {\n20 +   while left < right {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu3_m_o_.rs:21:8\n   |\n21 |     if (lst[left] == \"(\" && lst[right] == \")\") {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (lst[left] == \"(\" && lst[right] == \")\") {\n21 +     if lst[left] == \"(\" && lst[right] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu3_m_o_.rs:25:15\n   |\n25 |     } else if (lst[left] == \")\") {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n25 -     } else if (lst[left] == \")\") {\n25 +     } else if lst[left] == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu3_m_o_.rs:28:15\n   |\n28 |     } else if (lst[right] == \"(\" && balance == 0) {\n   |               ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n28 -     } else if (lst[right] == \"(\" && balance == 0) {\n28 +     } else if lst[right] == \"(\" && balance == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu3_m_o_.rs:31:15\n   |\n31 |     } else if (lst[right] == \"(\" && balance == 1) {\n   |               ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n31 -     } else if (lst[right] == \"(\" && balance == 1) {\n31 +     } else if lst[right] == \"(\" && balance == 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu3_m_o_.rs:39:6\n   |\n39 |   if (balance == 0) {\n   |      ^            ^\n   |\nhelp: remove these parentheses\n   |\n39 -   if (balance == 0) {\n39 +   if balance == 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpfu3_m_o_.rs:22:7\n   |\n18 |   let balance =",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = \"No\";\n        break;\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:22:15\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n22 |         res = \"No\";\n   |               ^^^^- help: try using a conversion method: `.to_string()`\n   |               |\n   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:26:17\n   |\n26 |       if top != \"(\" {\n   |                 ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:27:15\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n27 |         res = \"No\";\n   |               ^^^^- help: try using a conversion method: `.to_string()`\n   |               |\n   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22u5gzxb.rs:33:11\n   |\n16 |   let res = String::new();\n   |             ------------- expected due to this value\n...\n33 |     res = \"Yes\";\n   |           ^^^^^- help: try using a conversion method: `.to_string()`\n   |           |\n   |           expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmplokgkd6h.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplokgkd6h.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for (let s of lst) {\n    if (s.is_open_paren()) {\n      stack.push(s);\n    } else {\n      if (stack.is_empty()) {\n        result = String::from(\"Yes\");\n      } else {\n        let top = stack.last();\n        if (top.is_open_paren()) {\n          stack.pop();\n        } else {\n          result = String::from(\"No\");\n          break;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp473k1k78.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp473k1k78.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp473k1k78.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp473k1k78.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp473k1k78.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp473k1k78.rs:34:3\n   |\n34 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n34 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let str = \"\"\n  for s in lst {\n    if s == \"(\" {\n      parens += 1\n    } else if s == \")\" {\n      parens -= 1\n    }\n    str += s\n  }\n  if parens == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpd69ivh63.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let str = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpd69ivh63.rs:16:15\n   |\n16 |   let str = \"\"\n   |               ^ help: add `;` here\n17 |   for s in lst {\n   |   --- unexpected token\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpd69ivh63.rs:23:5\n   |\n23 |     str += s\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd69ivh63.rs:26:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n26 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let open = 0;\n  let close = 0;\n  for _ in lst {\n    if open > close {\n      open += 1;\n    } else if open < close {\n      close += 1;\n    } else {\n      open += 1;\n      close += 1;\n    }\n  }\n  if open == close {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpn4iiy8f8.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpwg9wdlk_.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg9wdlk_.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let res = \"\"\n  for _ in lst {\n    if parens == 0 {\n      res += \"Yes\"\n    } else {\n      res += \"No\"\n    }\n    if s.chars[0] == \"(\" {\n      parens += 1\n    } else {\n      parens -= 1\n    }\n  }\n  return res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp7gx2ql__.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let res = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp7gx2ql__.rs:16:15\n   |\n16 |   let res = \"\"\n   |               ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmp7gx2ql__.rs:23:8\n   |\n23 |     if s.chars[0] == \"(\" {\n   |        ^ not found in this scope\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp7gx2ql__.rs:19:7\n   |\n19 |       res += \"Yes\"\n   |       ---^^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp7gx2ql__.rs:21:7\n   |\n21 |       res += \"No\"\n   |       ---^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gx2ql__.rs:29:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n29 |   return res\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        return \"No\";\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpg9sgdxu4.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9sgdxu4.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      parens += 1;\n    } else if s == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmprkl9sauv.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmprkl9sauv.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let balance = 0;\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      balance += 1;\n    } else if parens > 0 {\n      balance -= 1;\n    }\n  }\n  if balance == 0 {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmi1zvrgm.rs:30:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else if stack.pop() != \"(\" {\n        return \"No\";\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpqmk8n8o5.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqmk8n8o5.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      parens += 1;\n    } else if s == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmprkl9sauv.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmprkl9sauv.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i == \")\") {\n      if stack.len() == 0 {\n        res = String::concat(res, \"No\");\n        break;\n      }\n      stack.pop();\n    } else {\n      stack.push(i);\n    }\n  }\n  if stack.len() != 0 {\n    res = String::concat(res, \"No\");\n  } else {\n    res = String::concat(res, \"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpc226mat0.rs:34:1\n   |\n30 |   } else {\n   |          - this opening brace...\n31 |     res = String::concat(res, \"Yes\");\n32 |   }\n   |   - ...matches this closing brace\n33 |   return res;\n34 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpc226mat0.rs:17:16\n   |\n17 |   for i in lst {\n   |                ^ unclosed delimiter\n18 |     if i == \")\") {\n   |                ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let stack = [];\n  for _ in lst {\n    if parens == 0 {\n      stack.push(String::from(\"\"));\n    }\n    if s := String::from(lst[i]); s.chars.len() == 1 {\n      if s.chars[0] == '(' {\n        parens += 1;\n      } else if s.chars[0] == ')' {\n        parens -= 1;\n      }\n    }\n    if parens == 0 {\n      stack.push(s);\n    }\n  }\n  if parens == 0 {\n    return String::from(\"Yes\");\n  }\n  return String::from(\"No\");\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected type, found `=`\n  --> /tmp/tmprcynvtyc.rs:21:11\n   |\n21 |     if s := String::from(lst[i]); s.chars.len() == 1 {\n   |          -^ expected type\n   |          |\n   |          tried to parse a type due to this\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmprcynvtyc.rs:19:13\n   |\n19 |       stack.push(String::from(\"\"));\n   |             ^^^^ method not found in `[_; 0]`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmplokgkd6h.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplokgkd6h.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp3yt5zuwv.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let balance = 0\n  for _ in lst {\n    if parens == 0 {\n      balance += 1\n    } else if balance == 0 {\n      balance -= 1\n    } else {\n      balance -= 1\n    }\n    if balance < 0 {\n      return \"No\"\n    }\n    parens += 1\n    if parens == 2 {\n      parens = 0\n    }\n  }\n  return \"Yes\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp1e93lsna.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let balance = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp1e93lsna.rs:16:18\n   |\n16 |   let balance = 0\n   |                  ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp1e93lsna.rs:28:16\n   |\n28 |     parens += 1\n   |                ^ help: add `;` here\n29 |     if parens == 2 {\n   |     -- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1e93lsna.rs:26:14\n   |\n26 |       return \"No\"\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let res = \"No\";\n  for s in lst {\n    if s == \"(\" {\n      stack.push(0);\n    } else if s == \")\" {\n      if stack.pop() == 0 {\n        res = \"Yes\";\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpohpxc4b1.rs:19:13\n   |\n19 |       stack.push(0);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpohpxc4b1.rs:21:16\n   |\n21 |       if stack.pop() == 0 {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpohpxc4b1.rs:26:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n26 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let left = 0;\n  let right = 0;\n  let result = String::from(\"No\");\n  for i in 0..lst_len {\n    if lst[i] == \"(\" {\n      left += 1;\n    } else {\n      right += 1;\n    }\n    if left == right {\n      result = String::from(\"Yes\");\n      break;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmp4lqdgw7m.rs:21:7\n   |\n16 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n21 |       left += 1;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `right`\n  --> /tmp/tmp4lqdgw7m.rs:23:7\n   |\n17 |   let right = 0;\n   |       -----\n   |       |\n   |       first assignment to `right`\n   |       help: consider making this binding mutable: `mut right`\n...\n23 |       right += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp4lqdgw7m.rs:26:7\n   |\n18 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n26 |       result = String::from(\"Yes\");\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \")\") {\n      if (stack.len() == 0) {\n        res = String::from(\"Yes\");\n        break;\n      }\n      stack.pop();\n    } else if (s == \"(\") {\n      stack.push(s);\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp888plae_.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp888plae_.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp888plae_.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp888plae_.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp888plae_.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp888plae_.rs:28:3\n   |\n28 |   return res;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n28 |   { return res; }\n   |   +             +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmplokgkd6h.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplokgkd6h.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpwz3igey3.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpwz3igey3.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpwz3igey3.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let lst_idx = 0;\n  let res = String::from(\"No\");\n  while (lst_idx < lst_len) {\n    let paren_idx = lst_idx;\n    while (paren_idx < lst_len && lst[paren_idx] != \")\") {\n      paren_idx += 1;\n    }\n    if (paren_idx == lst_len) {\n      return res;\n    }\n    if (lst[paren_idx] == \")\") {\n      lst_idx += 1;\n    } else {\n      return res;\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy1_ttgq0.rs:18:9\n   |\n18 |   while (lst_idx < lst_len) {\n   |         ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -   while (lst_idx < lst_len) {\n18 +   while lst_idx < lst_len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy1_ttgq0.rs:20:11\n   |\n20 |     while (paren_idx < lst_len && lst[paren_idx] != \")\") {\n   |           ^                                            ^\n   |\nhelp: remove these parentheses\n   |\n20 -     while (paren_idx < lst_len && lst[paren_idx] != \")\") {\n20 +     while paren_idx < lst_len && lst[paren_idx] != \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy1_ttgq0.rs:23:8\n   |\n23 |     if (paren_idx == lst_len) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n23 -     if (paren_idx == lst_len) {\n23 +     if paren_idx == lst_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy1_ttgq0.rs:26:8\n   |\n26 |     if (lst[paren_idx] == \")\") {\n   |        ^                     ^\n   |\nhelp: remove these parentheses\n   |\n26 -     if (lst[paren_idx] == \")\") {\n26 +     if lst[paren_idx] == \")\" {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `paren_idx`\n  --> /tmp/tmpy1_ttgq0.rs:21:7\n   |\n19 |     let paren_idx = lst_idx;\n   |         ---------\n   |         |\n   |         first assignment to `paren_idx`\n   |         help: consider making this binding mutable: `mut paren_idx`\n20 |     while (paren_idx < lst_len && lst[paren_idx] != \")\") {\n21 |       paren_idx += 1;\n   |       ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `lst_idx`\n  --> /tmp/tmpy1_ttgq0.rs:27:7\n   |\n16 |   let lst_idx = 0;\n   |       -------\n   |       |\n   |       first assignment to `lst_idx`\n   |       help: consider making this binding mutable: `mut lst_idx`\n...\n27 |       lst_idx += 1;\n   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    } else {\n      res += i;\n    }\n  }\n  if parens == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpp31zuzol.rs:23:7\n   |\n23 |       res += i;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp31zuzol.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()()\" {\n      stack.push(\"(()())\");\n    } else if v == \"()()\" {\n      stack.push(\"(()())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      stack.push(\"(())\");\n    } else if v == \"()\" {\n      \n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0demnzq8.rs:83:3\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                             - unclosed delimiter\n15 |   let stack = Stack::new();\n16 |   for v in lst {\n   |                - unclosed delimiter\n...\n65 |     } else if v == \"()\" {\n   |                         - this delimiter might not be properly closed...\n66 |       \n67 | }\n   | - ...as it matches this but it has different indentation\n...\n83 | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp0demnzq8.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0demnzq8.rs:16:3\n   |\n14 |   fn match_parens(lst: Vec<String>) -> String {\n   |                                        ------ expected `String` because of return type\n15 |     let stack = Stack::new();\n16 | /   for v in lst {\n17 | |     if v == \")()()\" {\n18 | |       stack.push(\"(()())\");\n19 | |     } else if v == \"()()\" {\n...  |\n82 | |     assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n83 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      if !stack.is_empty() {\n        stack.pop();\n      }\n      if stack.is_empty() {\n        return \"Yes\";\n      }\n    } else if v == \"()\" {\n      stack.push(v);\n    }\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpcis1ezt1.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcis1ezt1.rs:22:16\n   |\n22 |         return \"Yes\";\n   |                ^^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmphhaotqa2.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphhaotqa2.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for s in lst {\n    if s.len == 0 {\n      continue;\n    }\n    if s[0] == '(' {\n      stack.push(s);\n    } else if s[0] == ')' {\n      if stack.len == 0 {\n        result = String::from(\"No\");\n        break;\n      }\n      let top = stack.pop();\n      if top[0] != '(' {\n        result = String::from(\"No\");\n        break;\n      }\n    }\n  }\n  if stack.len != 0 {\n    result = String::from(\"No\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb5qro237.rs:18:10\n   |\n18 |     if s.len == 0 {\n   |          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n18 |     if s.len() == 0 {\n   |             ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpb5qro237.rs:21:8\n   |\n21 |     if s[0] == '(' {\n   |        ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpb5qro237.rs:23:15\n   |\n23 |     } else if s[0] == ')' {\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpb5qro237.rs:24:16\n   |\n24 |       if stack.len == 0 {\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n24 |       if stack.len() == 0 {\n   |                   ++\n\nerror[E0608]: cannot index into a value of type `Option<String>`\n  --> /tmp/tmpb5qro237.rs:29:10\n   |\n29 |       if top[0] != '(' {\n   |         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      parens += 1;\n    } else if s == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    res += s;\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmprkl9sauv.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmprkl9sauv.rs:26:5\n   |\n26 |     res += s;\n   |     ---^--^^\n   |     |   |\n   |     |   `+` cannot be used to concatenate a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let res = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if stack.len() == 0 {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp4fr_tybh.rs:19:13\n   |\n19 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp4fr_tybh.rs:21:16\n   |\n21 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fr_tybh.rs:30:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let ans = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        ans = \"No\";\n        break;\n      }\n    }\n  }\n  if stack.length == 0 {\n    ans = \"Yes\";\n  }\n  return ans;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp32vv8fa6.rs:19:13\n   |\n19 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp32vv8fa6.rs:21:16\n   |\n21 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0609]: no field `length` on type `[{integer}; 1]`\n  --> /tmp/tmp32vv8fa6.rs:27:12\n   |\n27 |   if stack.length == 0 {\n   |            ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp32vv8fa6.rs:30:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |   return ans;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i == \")\") {\n      if !stack.pop().is_empty() {\n        return \"No\";\n      }\n    } else {\n      stack.push(i);\n    }\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpemkf5yb6.rs:26:1\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                             - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n25 |   return \"Yes\";\n26 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpemkf5yb6.rs:16:16\n   |\n16 |   for i in lst {\n   |                ^ unclosed delimiter\n17 |     if i == \")\") {\n   |                ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let stack = []\n  for i in lst {\n    if i == \"(\" {\n      parens += 1\n      stack.push(i)\n    } else if i == \")\" {\n      parens -= 1\n      if parens < 0 {\n        return \"No\"\n      }\n      if parens == 0 {\n        stack.pop()\n      }\n    }\n  }\n  if parens == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpa__srrhf.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let stack = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpa__srrhf.rs:16:17\n   |\n16 |   let stack = []\n   |                 ^ help: add `;` here\n17 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found `stack`\n  --> /tmp/tmpa__srrhf.rs:19:18\n   |\n19 |       parens += 1\n   |                  ^ help: add `;` here\n20 |       stack.push(i)\n   |       ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpa__srrhf.rs:22:18\n   |\n22 |       parens -= 1\n   |                  ^ help: add `;` here\n23 |       if parens < 0 {\n   |       -- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpa__srrhf.rs:20:13\n   |\n20 |       stack.push(i)\n   |             ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa__srrhf.rs:24:16\n   |\n24 |         return \"No\"\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0599]: no method named `pop` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpa__srrhf.rs:27:15\n   |\n27 |         stack.pop()\n   |               ^^^ method not found in `[_; 0]`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpviil0enp.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpviil0enp.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpee6rg_8_.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmpee6rg_8_.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpee6rg_8_.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmpee6rg_8_.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpdll9or4a.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdll9or4a.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let stack = [];\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n      if parens < 0 {\n        return \"No\";\n      }\n    } else {\n      if parens < 0 {\n        return \"No\";\n      }\n    }\n    stack.push(i);\n  }\n  if parens != 0 {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6n9k8btt.rs:23:16\n   |\n23 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp6n9k8btt.rs:30:11\n   |\n30 |     stack.push(i);\n   |           ^^^^ method not found in `[_; 0]`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let result = \"No\";\n  for s in lst {\n    if s == \"(\" {\n      stack.push(0);\n    } else if s == \")\" {\n      if stack.pop() == 0 {\n        result = \"Yes\";\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpo8qbk5xe.rs:19:13\n   |\n19 |       stack.push(0);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpo8qbk5xe.rs:21:16\n   |\n21 |       if stack.pop() == 0 {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo8qbk5xe.rs:27:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.push(s);\n    } else if s == \"()\" {\n      if stack.is_empty() {\n        result = \"No\";\n        break;\n      }\n      let top = stack.pop();\n      if top != \"()\" {\n        result = \"No\";\n        break;\n      }\n    } else {\n      stack.push(s);\n    }\n  }\n  if !stack.is_empty() {\n    result = \"No\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmppytty97r.rs:22:18\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n22 |         result = \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppytty97r.rs:26:17\n   |\n26 |       if top != \"()\" {\n   |                 ^^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppytty97r.rs:27:18\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n27 |         result = \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppytty97r.rs:35:14\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n35 |     result = \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp3yt5zuwv.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return \"Yes\";\n  }\n  let lst_str = lst.head();\n  let lst_str_len = lst_str.len();\n  if lst_str_len == 0 {\n    return \"No\";\n  }\n  let lst_str_chars = lst_str.chars();\n  let lst_str_chars_len = lst_str_chars.len();\n  let lst_str_chars_iter = iter(lst_str_chars);\n  let lst_str_chars_iter_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next_next_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next_next_next_next_next_next = lst_str_chars_iter.next();\n  let lst_str_chars_iter_next_next_next_next_next_next_next_next_next_next = lst_str_chars_iter.next();\n  let lst\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp3bwkk4v0.rs:37:10\n   |\n37 |   let lst\n   |          ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function `iter` in this scope\n  --> /tmp/tmp3bwkk4v0.rs:26:28\n   |\n26 |   let lst_str_chars_iter = iter(lst_str_chars);\n   |                            ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3bwkk4v0.rs:17:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n17 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror[E0599]: no method named `head` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmp3bwkk4v0.rs:19:21\n   |\n19 |   let lst_str = lst.head();\n   |                     ^^^^ method not found in `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3bwkk4v0.rs:14:38\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmps5h63sgw.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmps5h63sgw.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmps5h63sgw.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let res = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if stack.pop() != 0 {\n    res = \"No\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp1ja6yt94.rs:19:13\n   |\n19 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp1ja6yt94.rs:21:16\n   |\n21 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp1ja6yt94.rs:27:12\n   |\n27 |   if stack.pop() != 0 {\n   |            ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ja6yt94.rs:30:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n30 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.pop();\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpnqb7k40c.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnqb7k40c.rs:31:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n31 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      balance += 1;\n    } else if s == \")\" {\n      balance -= 1;\n    } else {\n      res += s;\n    }\n  }\n  if balance == 0 {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpu2lbwtow.rs:23:7\n   |\n23 |       res += s;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu2lbwtow.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  for _ in lst {\n    if balance == 0 {\n      if lst[0] != \"(\" {\n        return \"No\";\n      }\n    } else if balance == 1 {\n      if lst[0] != \")\" {\n        return \"No\";\n      }\n    } else {\n      balance -= 1;\n    }\n    lst = lst.drop(1);\n  }\n  if balance != 0 {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpuyeqc_9u.rs:19:16\n   |\n19 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0040]: explicit use of destructor method\n  --> /tmp/tmpuyeqc_9u.rs:28:15\n   |\n28 |     lst = lst.drop(1);\n   |           ----^^^^---\n   |           |   |\n   |           |   explicit destructor calls not allowed\n   |           help: consider using `drop` function: `drop(lst)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpuyeqc_9u.rs:28:15\n    |\n28  |     lst = lst.drop(1);\n    |               ^^^^ - supplied 1 argument\n    |               |\n    |               expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuyeqc_9u.rs:28:11\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                      ----------- expected due to this parameter type\n...\n28 |     lst = lst.drop(1);\n   |           ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmpuyeqc_9u.rs:28:15\n   |\n28 |     lst = lst.drop(1);\n   |           --- ^^^^ this call modifies `lst` in-place\n   |           |\n   |           you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp52bkog5f.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmp52bkog5f.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp52bkog5f.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.is_empty() {\n        result = \"No\";\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = \"Yes\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp3bypzd08.rs:22:18\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n22 |         result = \"No\";\n   |                  ^^^^- help: try using a conversion method: `.to_string()`\n   |                  |\n   |                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3bypzd08.rs:30:14\n   |\n16 |   let result = String::new();\n   |                ------------- expected due to this value\n...\n30 |     result = \"Yes\";\n   |              ^^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n        break;\n      }\n      let top = stack.pop();\n      if top != \"(\" {\n        res = String::from(\"No\");\n        break;\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpi8febpg2.rs:26:17\n   |\n26 |       if top != \"(\" {\n   |                 ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<String>`\n           found reference `&'static str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for v in lst {\n    if v == \")()()\" {\n      stack.push(\"()()\");\n    } else if v == \"()()\" {\n      stack.pop();\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpek8b6fg7.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpek8b6fg7.rs:26:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n26 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      result = String::from(\"Yes\");\n      break;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `parens`\n  --> /tmp/tmpffwpzbcx.rs:19:7\n   |\n15 |   let parens = 0;\n   |       ------\n   |       |\n   |       first assignment to `parens`\n   |       help: consider making this binding mutable: `mut parens`\n...\n19 |       parens += 1;\n   |       ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `parens`\n  --> /tmp/tmpffwpzbcx.rs:21:7\n   |\n15 |   let parens = 0;\n   |       ------\n   |       |\n   |       first assignment to `parens`\n   |       help: consider making this binding mutable: `mut parens`\n...\n21 |       parens -= 1;\n   |       ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmpffwpzbcx.rs:24:7\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n24 |       result = String::from(\"Yes\");\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let res = String::from(\"No\");\n  for _ in lst {\n    if left == right {\n      left = 0;\n      right = 0;\n    }\n    if left > right {\n      left += 1;\n    } else if left < right {\n      right += 1;\n    }\n    if left == right {\n      res = String::from(\"Yes\");\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmp5m7vqsw8.rs:20:7\n   |\n15 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n20 |       left = 0;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `right`\n  --> /tmp/tmp5m7vqsw8.rs:21:7\n   |\n16 |   let right = 0;\n   |       -----\n   |       |\n   |       first assignment to `right`\n   |       help: consider making this binding mutable: `mut right`\n...\n21 |       right = 0;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmp5m7vqsw8.rs:24:7\n   |\n15 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n24 |       left += 1;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `right`\n  --> /tmp/tmp5m7vqsw8.rs:26:7\n   |\n16 |   let right = 0;\n   |       -----\n   |       |\n   |       first assignment to `right`\n   |       help: consider making this binding mutable: `mut right`\n...\n26 |       right += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmp5m7vqsw8.rs:29:7\n   |\n17 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n29 |       res = String::from(\"Yes\");\n   |       ^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack<String>::new();\n  for s in lst {\n    if s == \")()()\" {\n      if stack.is_empty() {\n        return \"Yes\";\n      }\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      if stack.is_empty() {\n        return \"Yes\";\n      }\n      stack.pop();\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else {\n      stack.push(s);\n    }\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpkuh0gnbl.rs:15:20\n   |\n15 |   let stack = Stack<String>::new();\n   |                    ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let stack = Stack::<String>::new();\n   |                    ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkuh0gnbl.rs:19:16\n   |\n19 |         return \"Yes\";\n   |                ^^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpwg9wdlk_.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg9wdlk_.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let balance = 0;\n  let res = String::from(\"\");\n  for i in lst {\n    if i == \"(\" {\n      balance += 1;\n    } else if i == \")\" {\n      balance -= 1;\n    }\n    if balance < 0 {\n      return \"No\";\n    }\n    res = res.concat(i);\n  }\n  if balance == 0 {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmppdlkz7dq.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmppdlkz7dq.rs:26:15\n   |\n26 |     res = res.concat(i);\n   |               ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        res = String::from(\"Yes\");\n      } else {\n        let top = stack.pop();\n        if (top == \"(\" && s == \")\") {\n          stack.push(s);\n        } else {\n          stack.push(top);\n        }\n      }\n    } else {\n      stack.push(s);\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpl4g9rg88.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpl4g9rg88.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpl4g9rg88.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpl4g9rg88.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpl4g9rg88.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpl4g9rg88.rs:33:3\n   |\n33 |   return res;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n33 |   { return res; }\n   |   +             +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let res = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      left += 1;\n    } else if i == \")\" {\n      right += 1;\n    } else {\n      if left != right {\n        res = \"No\";\n        break;\n      }\n    }\n  }\n  if left == right {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpcw6l7muy.rs:33:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n33 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        return \"No\";\n      }\n    } else {\n      res += i;\n    }\n  }\n  return \"Yes\" if stack.is_empty() else \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword `if`\n  --> /tmp/tmpx1_72_zo.rs:28:16\n   |\n28 |   return \"Yes\" if stack.is_empty() else \"No\";\n   |                ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpx1_72_zo.rs:19:13\n   |\n19 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpx1_72_zo.rs:21:16\n   |\n21 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1_72_zo.rs:22:16\n   |\n22 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpx1_72_zo.rs:25:7\n   |\n25 |       res += i;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()()\" {\n      stack.pop();\n      stack.pop();\n      stack.pop();\n    } else if s == \"()()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmphhaotqa2.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphhaotqa2.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let last = 0;\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    last = i.len();\n  }\n  if parens != 0 {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpzul3gj6y.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let stack = Vec::new();\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n      stack.push(i);\n    } else if i == \")\" {\n      parens -= 1;\n      if parens < 0 {\n        return \"No\";\n      }\n      if parens == 0 {\n        stack.pop();\n      }\n    }\n  }\n  if parens == 0 {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmmgjhwif.rs:24:16\n   |\n24 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if s == \"()\" {\n      stack.push(s);\n    } else {\n      stack.push(s);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpwg9wdlk_.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg9wdlk_.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::concat(result, \"No\");\n      } else {\n        stack.pop();\n      }\n    } else {\n      result = String::concat(result, \"No\");\n    }\n  }\n  if stack.is_empty() {\n    result = String::concat(result, \"Yes\");\n  } else {\n    result = String::concat(result, \"No\");\n  }\n  return result\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpepq1m7rv.rs:22:26\n   |\n22 |         result = String::concat(result, \"No\");\n   |                          ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpepq1m7rv.rs:27:24\n   |\n27 |       result = String::concat(result, \"No\");\n   |                        ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpepq1m7rv.rs:31:22\n   |\n31 |     result = String::concat(result, \"Yes\");\n   |                      ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpepq1m7rv.rs:33:22\n   |\n33 |     result = String::concat(result, \"No\");\n   |                      ^^^^^^ function or associated item not found in `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let result = \"\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(0);\n    } else if i == \")\" {\n      if stack.pop() == 0 {\n        result += i;\n      } else {\n        return \"No\";\n      }\n    } else {\n      result += i;\n    }\n  }\n  return \"Yes\" if stack.pop() == 0 else \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword `if`\n  --> /tmp/tmp60ngv250.rs:30:16\n   |\n30 |   return \"Yes\" if stack.pop() == 0 else \"No\";\n   |                ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp60ngv250.rs:19:13\n   |\n19 |       stack.push(0);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp60ngv250.rs:21:16\n   |\n21 |       if stack.pop() == 0 {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp60ngv250.rs:22:9\n   |\n22 |         result += i;\n   |         ------^--^^\n   |         |      |\n   |         |      `+` cannot be used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp60ngv250.rs:24:16\n   |\n24 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp60ngv250.rs:27:7\n   |\n27 |       result += i;\n   |       ------^--^^\n   |       |      |\n   |       |      `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = \"No\";\n  for (let s of lst) {\n    if (s == \"(\" || s == \")\") {\n      if (stack.len() == 0) {\n        res = \"No\";\n        break;\n      }\n      if (s == \")\") {\n        stack.pop();\n      } else {\n        stack.push(s);\n      }\n    }\n  }\n  if (stack.len() == 0) {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp3dfpf23v.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp3dfpf23v.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp3dfpf23v.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp3dfpf23v.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp3dfpf23v.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmp3dfpf23v.rs:30:3\n   |\n30 |   if (stack.len() == 0) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n30 ~   { if (stack.len() == 0) {\n31 |     res = \"Yes\";\n32 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0\n  let right = 0\n  for _ in lst {\n    if left == right {\n      left += 1\n    } else if left > right {\n      right += 1\n    } else {\n      left -= 1\n    }\n  }\n  if left == right {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfrbwpn_k.rs:15:15\n   |\n15 |   let left = 0\n   |               ^ help: add `;` here\n16 |   let right = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfrbwpn_k.rs:16:16\n   |\n16 |   let right = 0\n   |                ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfrbwpn_k.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for (let s of lst) {\n    if (s.is_open()) {\n      stack.push(s);\n    } else {\n      if (stack.is_empty()) {\n        result = String::from(\"No\");\n        break;\n      }\n      let top = stack.pop();\n      if (top.is_open()) {\n        stack.push(top);\n      } else {\n        result = String::from(\"Yes\");\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpdl0e_dst.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpdl0e_dst.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpdl0e_dst.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpdl0e_dst.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdl0e_dst.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpdl0e_dst.rs:34:3\n   |\n34 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n34 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  let result = String::new();\n  for i in lst {\n    if i.len == 1 {\n      if i.chars[0] == '(' {\n        stack.push(i);\n      } else if i.chars[0] == ')' {\n        if stack.is_empty() {\n          result = String::concat(result, i);\n        } else {\n          let top = stack.pop();\n          result = String::concat(result, top);\n          result = String::concat(result, i);\n        }\n      }\n    } else {\n      if i.chars[0] == '(' {\n        stack.push(i);\n      } else if i.chars[0] == ')' {\n        if stack.is_empty() {\n          result = String::concat(result, i);\n        } else {\n          let top = stack.pop();\n          result = String::concat(result, top);\n          result = String::concat(result, i);\n        }\n      }\n    }\n  }\n  if stack.is_empty() {\n    return String::concat(result, String::from(\"Yes\"));\n  } else {\n    return String::concat(result, String::from(\"No\"));\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpi79fkqwp.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi79fkqwp.rs:18:10\n   |\n18 |     if i.len == 1 {\n   |          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n18 |     if i.len() == 1 {\n   |             ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpi79fkqwp.rs:19:12\n   |\n19 |       if i.chars[0] == '(' {\n   |            ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n19 |       if i.chars()[0] == '(' {\n   |                 ++\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpi79fkqwp.rs:21:19\n   |\n21 |       } else if i.chars[0] == ')' {\n   |                   ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n21 |       } else if i.chars()[0] == ')' {\n   |                        ++\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpi79fkqwp.rs:23:28\n   |\n23 |           result = String::concat(result, i);\n   |                            ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpi79fkqwp.rs:26:28\n   |\n26 |           result = String::concat(result, top);\n   |                            ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpi79fkqwp.rs:27:28\n   |\n27 |           result = String::concat(result, i);\n   |                            ^^^^^^ function or associated item not found in `String`\n\nerror[E0615]: attempted to take value of method `chars` on type `String`\n  --> /tmp/tmpi79fkqwp.rs:31:12\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let left = 0;\n  let right = 0;\n  let res = String::from(\"\");\n  for i in 0..lst_len {\n    if lst[i] == \"(\" {\n      left += 1;\n    } else if lst[i] == \")\" {\n      right += 1;\n    } else {\n      if left == right {\n        res = res.concat(lst[i]);\n      } else {\n        return String::from(\"No\");\n      }\n    }\n  }\n  if left == right {\n    return String::from(\"Yes\");\n  } else {\n    return String::from(\"No\");\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpqowxntzj.rs:26:19\n   |\n26 |         res = res.concat(lst[i]);\n   |                   ^^^^^^ method not found in `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let balance = 0;\n  let res = \"\";\n  for s in lst {\n    if s == \"(\" {\n      parens += 1;\n    } else if s == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    if parens == 0 {\n      balance += 1;\n    }\n    if balance == 0 {\n      res += s;\n    }\n  }\n  if balance == 0 {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpuveeyh1v.rs:25:14\n   |\n25 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpuveeyh1v.rs:31:7\n   |\n31 |       res += s;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = [0];\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.pop() != \"(\" {\n        return \"No\";\n      }\n    } else {\n      res += i;\n    }\n  }\n  if stack.pop() != \"(\" {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp3a4fn2ph.rs:19:13\n   |\n19 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp3a4fn2ph.rs:21:16\n   |\n21 |       if stack.pop() != \"(\" {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3a4fn2ph.rs:22:16\n   |\n22 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp3a4fn2ph.rs:25:7\n   |\n25 |       res += i;\n   |       ---^--^^\n   |       |   |\n   |       |   `+` cannot be used to concatenate a `&str` with a `String`\n   |       cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp3a4fn2ph.rs:28:12\n   |\n28 |   if stack.pop() != \"(\" {\n   |            ^^^ method not found in `[{integer}; 1]`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let last = 0;\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    last = i.len();\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpele1tiqc.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = \"No\";\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = \"No\";\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = \"Yes\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmppb6b8_2e.rs:32:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n32 |   return res;\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for s in lst {\n    if s == \"(\" {\n      stack.push(s);\n    } else if s == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp6rc8mshs.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(s);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp6rc8mshs.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp6rc8mshs.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for s in lst {\n    if s == \")()\" {\n      if !stack.is_empty() && stack.peek() == \"(\" {\n        stack.pop();\n      } else {\n        stack.push(\"()\");\n      }\n    } else if s == \"()\" {\n      stack.push(\"()\");\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpyrf9sfka.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyrf9sfka.rs:28:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n28 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if v == \"()\" {\n      stack.push(v);\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp8_3z88gd.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_3z88gd.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \"(\" {\n      stack.push(v);\n    } else if v == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpw_3lkpon.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_3lkpon.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let last = 0;\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    }\n    if parens < 0 {\n      return \"No\";\n    }\n    last = i.len();\n  }\n  if parens != 0 {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpzul3gj6y.rs:24:14\n   |\n24 |       return \"No\";\n   |              ^^^^- help: try using a conversion method: `.to_string()`\n   |              |\n   |              expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let lst_len = lst.len();\n  let lst_idx = 0;\n  let res = String::from(\"No\");\n  while (lst_idx < lst_len) {\n    let curr = lst[lst_idx];\n    if (curr == \"(\" || curr == \")\") {\n      if (lst_idx + 1 < lst_len && lst[lst_idx + 1] == \")\") {\n        lst_idx += 2;\n      } else {\n        lst_idx += 1;\n      }\n    } else {\n      res = String::from(\"Yes\");\n      break;\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp28n06_3r.rs:18:9\n   |\n18 |   while (lst_idx < lst_len) {\n   |         ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -   while (lst_idx < lst_len) {\n18 +   while lst_idx < lst_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp28n06_3r.rs:20:8\n   |\n20 |     if (curr == \"(\" || curr == \")\") {\n   |        ^                          ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (curr == \"(\" || curr == \")\") {\n20 +     if curr == \"(\" || curr == \")\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp28n06_3r.rs:21:10\n   |\n21 |       if (lst_idx + 1 < lst_len && lst[lst_idx + 1] == \")\") {\n   |          ^                                                ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (lst_idx + 1 < lst_len && lst[lst_idx + 1] == \")\") {\n21 +       if lst_idx + 1 < lst_len && lst[lst_idx + 1] == \")\" {\n   | \n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp28n06_3r.rs:19:16\n   |\n19 |     let curr = lst[lst_idx];\n   |                ^^^^^^^^^^^^\n   |                |\n   |                move occurs because value has type `String`, which does not implement the `Copy` trait\n   |                help: consider borrowing here: `&lst[lst_idx]`\n\nerror[E0384]: cannot assign twice to immutable variable `lst_idx`\n  --> /tmp/tmp28n06_3r.rs:22:9\n   |\n16 |   let lst_idx = 0;\n   |       -------\n   |       |\n   |       first assignment to `lst_idx`\n   |       help: consider making this binding mutable: `mut lst_idx`\n...\n22 |         lst_idx += 2;\n   |         ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `lst_idx`\n  --> /tmp/tmp28n06_3r.rs:24:9\n   |\n16 |   let lst_idx = 0;\n   |       -------\n   |       |\n   |       first assignment to `lst_idx`\n   |       help: consider making this binding mutable: `mut lst_idx`\n...\n24 |        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if v == \"()\" {\n      stack.push(v);\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp8_3z88gd.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_3z88gd.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    result = String::from(\"Yes\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmplj2kw770.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmplj2kw770.rs:29:5\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n29 |     result = String::from(\"Yes\");\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for s in lst {\n    if s == \")()\" {\n      res += \"Yes\";\n      continue;\n    }\n    if s == \"()\" {\n      res += \"No\";\n      continue;\n    }\n    if s == \"(\" {\n      stack.push(s);\n      continue;\n    }\n    if s == \")\" {\n      if stack.is_empty() {\n        res += \"No\";\n        continue;\n      }\n      let top = stack.pop();\n      if top != \"(\") {\n        res += \"No\";\n        continue;\n      }\n      res += \"Yes\";\n    }\n  }\n  if stack.is_empty() {\n    res += \"Yes\";\n  } else {\n    res += \"No\";\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpjbnx5bky.rs:49:1\n   |\n45 |   } else {\n   |          - this opening brace...\n46 |     res += \"No\";\n47 |   }\n   |   - ...matches this closing brace\n48 |   return res;\n49 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpjbnx5bky.rs:30:17\n   |\n30 |     if s == \")\" {\n   |                 ^ unclosed delimiter\n...\n36 |       if top != \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = String::concat(res, i);\n      } else {\n        stack.pop();\n      }\n    } else {\n      res = String::concat(res, i);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpa736nv3v.rs:22:23\n   |\n22 |         res = String::concat(res, i);\n   |                       ^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpa736nv3v.rs:27:21\n   |\n27 |       res = String::concat(res, i);\n   |                     ^^^^^^ function or associated item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa736nv3v.rs:31:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n31 |     return \"Yes\"\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if v == \"()\" {\n      stack.push(v);\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp8_3z88gd.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_3z88gd.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp_wgjzezq.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_wgjzezq.rs:25:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n25 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let ans = String::from(\"No\");\n  for v in lst {\n    if v == \")()\" {\n      if stack.len() == 0 {\n        ans = String::from(\"Yes\");\n        break;\n      }\n      stack.pop();\n    } else {\n      stack.push(v);\n    }\n  }\n  return ans;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `ans`\n  --> /tmp/tmpi76u8uc6.rs:20:9\n   |\n16 |   let ans = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `ans`\n   |       help: consider making this binding mutable: `mut ans`\n...\n20 |         ans = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpi76u8uc6.rs:23:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n23 |       stack.pop();\n   |       ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpi76u8uc6.rs:25:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |       stack.push(v);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      }\n      stack.pop();\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpdzq4ve4k.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzq4ve4k.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0\n  let res = \"\"\n  for _ in lst {\n    if parens == 0 {\n      res += \"Yes\"\n    } else {\n      res += \"No\"\n    }\n    if s.chars[0] == '(' {\n      parens += 1\n    } else {\n      parens -= 1\n    }\n  }\n  return res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbbvr4sox.rs:15:17\n   |\n15 |   let parens = 0\n   |                 ^ help: add `;` here\n16 |   let res = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbbvr4sox.rs:16:15\n   |\n16 |   let res = \"\"\n   |               ^ help: add `;` here\n17 |   for _ in lst {\n   |   --- unexpected token\n\nerror[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmpbbvr4sox.rs:23:8\n   |\n23 |     if s.chars[0] == '(' {\n   |        ^ not found in this scope\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpbbvr4sox.rs:19:7\n   |\n19 |       res += \"Yes\"\n   |       ---^^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpbbvr4sox.rs:21:7\n   |\n21 |       res += \"No\"\n   |       ---^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbbvr4sox.rs:29:10\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n29 |   return res\n   |          ^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        res = String::from(\"Yes\");\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    res = String::from(\"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpxm7nbuj9.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpxm7nbuj9.rs:22:9\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n22 |         res = String::from(\"Yes\");\n   |         ^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpxm7nbuj9.rs:24:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n24 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `res`\n  --> /tmp/tmpxm7nbuj9.rs:29:5\n   |\n16 |   let res = String::from(\"No\");\n   |       ---\n   |       |\n   |       first assignment to `res`\n   |       help: consider making this binding mutable: `mut res`\n...\n29 |     res = String::from(\"Yes\");\n   |     ^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for v in lst {\n    if v == \")()\" {\n      stack.pop();\n      stack.pop();\n    } else if v == \"()\" {\n      stack.push(v);\n    } else {\n      stack.push(v);\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp8_3z88gd.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_3z88gd.rs:27:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n27 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  let res = String::from(\"No\");\n  for v in lst {\n    if v == \")()\" {\n      if !stack.is_empty() {\n        stack.pop();\n      } else {\n        res = String::from(\"Yes\");\n        break;\n      }\n    } else if v == \"()\" {\n      stack.push(v);\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp4j1t9svn.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let parens = 0;\n  let stack = [0];\n  let res = \"\";\n  for i in lst {\n    if i == \"(\" {\n      parens += 1;\n    } else if i == \")\" {\n      parens -= 1;\n    } else {\n      if parens == 0 {\n        res += i;\n      } else {\n        stack.push(i);\n      }\n    }\n  }\n  if parens == 0 {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmppc718o7a.rs:25:9\n   |\n25 |         res += i;\n   |         ---^--^^\n   |         |   |\n   |         |   `+` cannot be used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned `String` on the left\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmppc718o7a.rs:27:15\n   |\n27 |         stack.push(i);\n   |               ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc718o7a.rs:32:12\n   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |                                      ------ expected `String` because of return type\n...\n32 |     return \"Yes\";\n   |            ^^^^^- help: try using a conversion method: `.to_string()`\n   |            |\n   |            expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        result = String::from(\"Yes\");\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:19:7\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n19 |       stack.push(i);\n   |       ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmp3yt5zuwv.rs:22:9\n   |\n16 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n22 |         result = String::from(\"Yes\");\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmp3yt5zuwv.rs:25:9\n   |\n15 |   let stack = Vec::new();\n   |       ----- help: consider changing this to be mutable: `mut stack`\n...\n25 |         stack.pop();\n   |         ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information about an error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let res = String::from(\"No\");\n  for (let s of lst) {\n    if (s == \")\") {\n      if (stack.len() == 0) {\n        res = String::from(\"No\");\n        break;\n      }\n      stack.pop();\n    } else if (s == \"(\") {\n      stack.push(s);\n    }\n  }\n  if (stack.len() == 0) {\n    res = String::from(\"Yes\");\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpn7l2f4x7.rs:17:8\n   |\n17 |   for (let s of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpn7l2f4x7.rs:17:12\n   |\n17 |   for (let s of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpn7l2f4x7.rs:17:14\n   |\n17 |   for (let s of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpn7l2f4x7.rs:17:17\n   |\n17 |   for (let s of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpn7l2f4x7.rs:17:21\n   |\n17 |   for (let s of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpn7l2f4x7.rs:28:3\n   |\n28 |   if (stack.len() == 0) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n28 ~   { if (stack.len() == 0) {\n29 |     res = String::from(\"Yes\");\n30 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let left = 0;\n  let right = 0;\n  let result = String::from(\"No\");\n  for _ in lst {\n    if left < right {\n      result = String::from(\"Yes\");\n      break;\n    }\n    if left > right {\n      left += 1;\n    } else {\n      right += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `result`\n  --> /tmp/tmpks2_e1dl.rs:20:7\n   |\n17 |   let result = String::from(\"No\");\n   |       ------\n   |       |\n   |       first assignment to `result`\n   |       help: consider making this binding mutable: `mut result`\n...\n20 |       result = String::from(\"Yes\");\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmpks2_e1dl.rs:24:7\n   |\n15 |   let left = 0;\n   |       ----\n   |       |\n   |       first assignment to `left`\n   |       help: consider making this binding mutable: `mut left`\n...\n24 |       left += 1;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `right`\n  --> /tmp/tmpks2_e1dl.rs:26:7\n   |\n16 |   let right = 0;\n   |       -----\n   |       |\n   |       first assignment to `right`\n   |       help: consider making this binding mutable: `mut right`\n...\n26 |       right += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Vec::new();\n  let result = String::from(\"No\");\n  for s in lst {\n    if s.len == 0 {\n      continue;\n    }\n    if s[0] == '(' {\n      stack.push(s);\n    } else {\n      if stack.len == 0 {\n        result = String::from(\"Yes\");\n        break;\n      }\n      let top = stack.pop();\n      if s.len != top.len + 1 {\n        result = String::from(\"No\");\n        break;\n      }\n      if s[0] != top[top.len - 1] {\n        result = String::from(\"No\");\n        break;\n      }\n      stack.push(top);\n      stack.push(s);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpw6dj63ac.rs:18:10\n   |\n18 |     if s.len == 0 {\n   |          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n18 |     if s.len() == 0 {\n   |             ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpw6dj63ac.rs:21:8\n   |\n21 |     if s[0] == '(' {\n   |        ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpw6dj63ac.rs:24:16\n   |\n24 |       if stack.len == 0 {\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n24 |       if stack.len() == 0 {\n   |                   ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpw6dj63ac.rs:29:12\n   |\n29 |       if s.len != top.len + 1 {\n   |            ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n29 |       if s.len() != top.len + 1 {\n   |               ++\n\nerror[E0609]: no field `len` on type `Option<String>`\n  --> /tmp/tmpw6dj63ac.rs:29:23\n   |\n29 |       if s.len != top.len + 1 {\n   |                       ^^^\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpw6dj63ac.rs:33:10\n   |\n33 |       if s[0] != top[top.len - 1] {\n   |          ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n  let stack = Stack::new();\n  for i in lst {\n    if i == \"(\" {\n      stack.push(i);\n    } else if i == \")\" {\n      if stack.is_empty() {\n        return \"No\";\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  if stack.is_empty() {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpviil0enp.rs:15:15\n   |\n15 |   let stack = Stack::new();\n   |               ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpviil0enp.rs:21:16\n   |\n21 |         return \"No\";\n   |                ^^^^- help: try using a conversion method: `.to_string()`\n   |                |\n   |                expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}