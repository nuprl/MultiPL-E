name: HumanEval_141_file_name_check
language: go_test.go
prompt: "package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Create a function which takes a string representing a file's name, and returns\n\
  // 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's\
  \ name is considered to be valid if and only if all the following conditions \n\
  // are met:\n// - There should not be more than three digits ('0'-'9') in the file's\
  \ name.\n// - The file's name contains exactly one dot '.'\n// - The substring before\
  \ the dot should not be empty, and it starts with a letter from \n// the latin alphapet\
  \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
  \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
  \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start with\
  \ a latin alphapet letter)\nfunc file_name_check(file_name string) string {\n"
tests: "func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\"\
  \ },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual:\
  \ candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"\
  ), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected:\
  \ \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n\
  \     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"\
  ?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"/this_is_valid.dll\"\
  ), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected:\
  \ \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\"\
  \ },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n\
  \     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n    \
  \ { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual:\
  \ candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual:\
  \ candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"\
  ), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected:\
  \ \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\"\
  \ },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     {\
  \ actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"\
  final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected:\
  \ \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n\
  \     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"\
  s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // digit_count := 0\n    // dot_count := 0\n    // file_extension\
    \ := \"\"\n    // file_name_without_extension := \"\"\n    // first_char := string(file_name[0])\n\
    \    // if strings.ContainsAny(first_char, \"0123456789\") {\n    //     return\
    \ \"No\"\n    // }\n    // for _, r := range file_name {\n    //     if r == '.'\
    \ {\n    //         dot_count += 1\n    //     }\n    //     if strings.ContainsAny(string(r),\
    \ \"0123456789\") {\n    //         digit_count += 1\n    //     }\n    // }\n\
    \    // if digit_count > 3 || dot_count != 1 {\n    //     return \"No\"\n   \
    \ // }\n    // file_name_without_extension = strings.Split(file_name, \".\")[0]\n\
    \    // file_extension = strings.Split(file_name, \".\")[1]\n    // if file_name_without_extension\
    \ == \"\" || !strings.ContainsAny(file_extension, \"txtexe\") {\n    //     return\
    \ \"No\"\n    // }\n    // return \"Yes\"\n    return \"Yes\"\n}\n", "    // Your\
    \ code goes here!\n}\n", "    // your code goes here\n    return \"\"\n}\n", " \
    \   return \"\"\n}\n", "    return \"\"\n}\n", "    // your code here...\n   \
    \ fmt.Println(file_name)\n    return \"\"\n}\n", "\tvar cnt int\n\tvar ok bool\n\
    \t\n\tfor i := 0; i < len(file_name); i++ {\n\t\tif file_name[i] >= '0' && file_name[i]\
    \ <= '9' {\n\t\t\tcnt++\n\t\t}\n\t}\n\t\n\tif cnt > 3 {\n\t\treturn \"No\"\n\t\
    }\n\t\n\tif file_name[0] < 'a' || file_name[0] > 'z' {\n\t\tif file_name[0] <\
    \ 'A' || file_name[0] > 'Z' {\n\t\t\treturn \"No\"\n\t\t}\n\t}\n\t\n\tif file_name[len(file_name)\
    \ - 1] == 't' && file_name[len(file_name) - 2] == 'x' && file_name[len(file_name)\
    \ - 3] == 't' {\n\t\tok = true\n\t} else if file_name[len(file_name) - 1] == 'e'\
    \ && file_name[len(file_name) - 2] == 'x' && file_name[len(file_name) - 3] ==\
    \ 'e' {\n\t\tok = true\n\t} else if file_name[len(file_name) - 1] == 'l' && file_name[len(file_name)\
    \ - 2] == 'l' && file_name[len(file_name) - 3] == 'd' {\n\t\tok = true\n\t} else\
    \ {\n\t\tok = false\n\t}\n\t\n\tif ok {\n\t\treturn \"Yes\"\n\t} else {\n\t\t\
    return \"No\"\n\t}\n}\n", "    // write your code here!\n    return \"Yes\"\n\
    }\n", "    if len(file_name) < 5 {\n        return \"No\"\n    }\n    if file_name[0]\
    \ < 'a' || file_name[0] > 'z' {\n        return \"No\"\n    }\n    if file_name[len(file_name)\
    \ - 4] != '.' {\n        return \"No\"\n    }\n    for i := 1; i < len(file_name)\
    \ - 4; i++ {\n        if file_name[i] < 'a' || file_name[i] > 'z' {\n        \
    \    return \"No\"\n        }\n    }\n    if file_name[len(file_name) - 3:] !=\
    \ \"txt\" && file_name[len(file_name) - 3:] != \"exe\" && file_name[len(file_name)\
    \ - 3:] != \"dll\" {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n",
  "    // TODO: Write your code here.\n    fmt.Println(file_name)\n    return \"Yes\"\
    \n}\n", "    // your code here\n    return \"\"\n}\n", "    // Write your solution\
    \ here\n    return \"\"\n}\n", "    if len(file_name) < 4 {\n        return \"\
    No\"\n    }\n    var dot_index int\n    var latin_letter_found bool\n    var valid_ending_found\
    \ bool\n    var digit_count int\n    for i, ch := range file_name {\n        if\
    \ ch == '.' {\n            dot_index = i\n        } else if ch >= 'a' && ch <=\
    \ 'z' || ch >= 'A' && ch <= 'Z' {\n            latin_letter_found = true\n   \
    \     } else if ch >= '0' && ch <= '9' {\n            digit_count += 1\n     \
    \   }\n    }\n    if digit_count > 3 {\n        return \"No\"\n    }\n    if !latin_letter_found\
    \ {\n        return \"No\"\n    }\n    substring_after_dot := file_name[dot_index\
    \ + 1:]\n    if substring_after_dot == \"txt\" || substring_after_dot == \"exe\"\
    \ || substring_after_dot == \"dll\" {\n        valid_ending_found = true\n   \
    \ }\n    if valid_ending_found {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n", "    var valid_extensions = map[string]int{\"txt\":1, \"exe\":1, \"\
    dll\":1}\n    var digits = map[string]int{\"0\":1, \"1\":1, \"2\":1, \"3\":1,\
    \ \"4\":1, \"5\":1, \"6\":1, \"7\":1, \"8\":1, \"9\":1}\n    var name_parts =\
    \ strings.Split(file_name, \".\")\n    if len(name_parts) != 2 {\n        return\
    \ \"No\"\n    }\n    var name_part, extension_part = name_parts[0], name_parts[1]\n\
    \    var num_digits int\n    for _, c := range name_part {\n        if val, exists\
    \ := digits[string(c)]; exists && val == 1 {\n            num_digits++\n     \
    \   }\n    }\n    if num_digits > 3 {\n        return \"No\"\n    }\n    var first_letter\
    \ string = string(name_part[0])\n    if !(strings.ToLower(first_letter) == first_letter\
    \ || strings.ToUpper(first_letter) == first_letter) {\n        return \"No\"\n\
    \    }\n    if valid_extensions[extension_part] != 1 {\n        return \"No\"\n\
    \    }\n    return \"Yes\"\n}\n", "    return \"No\"\n}\n", "    l := len(file_name)\n\
    \    if l < 5 {\n        return \"No\"\n    }\n    count := 0\n    for i := 0;\
    \ i < l; i++ {\n        if file_name[i] == '.' {\n            count++\n      \
    \  }\n    }\n    if count != 1 {\n        return \"No\"\n    }\n    a := file_name[0]\n\
    \    if !(a >= 'a' && a <= 'z' || a >= 'A' && a <= 'Z') {\n        return \"No\"\
    \n    }\n    for i := 1; i < l; i++ {\n        if file_name[i] >= '0' && file_name[i]\
    \ <= '9' {\n            count++\n        }\n    }\n    if count > 3 {\n      \
    \  return \"No\"\n    }\n    end_pos := 0\n    for i := l - 1; i >= 0; i-- {\n\
    \        if file_name[i] == '.' {\n            end_pos = i\n            break\n\
    \        }\n    }\n    if end_pos == 0 {\n        return \"No\"\n    }\n    str\
    \ := file_name[end_pos + 1:]\n    if str != \"txt\" && str != \"exe\" && str !=\
    \ \"dll\" {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n", "    var\
    \ valid_extensions = map[string]bool{\n        \"txt\": true,\n        \"exe\"\
    : true,\n        \"dll\": true,\n    }\n    var valid = false\n    var digit_count\
    \ = 0\n    var dot_count = 0\n    var extension = \"\"\n    var before_dot = \"\
    \"\n    var after_dot = \"\"\n    for _, c := range file_name {\n        if c\
    \ >= '0' && c <= '9' {\n            digit_count++\n        } else if c == '.'\
    \ {\n            dot_count++\n        } else if dot_count == 0 {\n           \
    \ before_dot += string(c)\n        } else if dot_count == 1 {\n            after_dot\
    \ += string(c)\n        }\n    }\n    if len(before_dot) > 0 && (before_dot[0]\
    \ >= 'a' && before_dot[0] <= 'z' || before_dot[0] >= 'A' && before_dot[0] <= 'Z')\
    \ {\n        if dot_count == 1 && digit_count <= 3 {\n            if _, ok :=\
    \ valid_extensions[after_dot]; ok {\n                valid = true\n          \
    \  }\n        }\n    }\n    if valid {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n", "    // code here\n    return \"Yes\"\n}\n", "    // write your\
    \ code here\n}\n", "    b := []byte(file_name)\n    dot := false\n    digit :=\
    \ 0\n    ext := false\n    ext_str := \"\"\n    latin := false\n    if len(b)\
    \ <= 4 {\n        return \"No\"\n    }\n\n    for i := 0; i < len(b); i++ {\n\
    \        if b[i] == '.' {\n            if dot {\n                return \"No\"\
    \n            }\n            dot = true\n            continue\n        }\n   \
    \     if b[i] <= '9' && b[i] >= '0' {\n            digit++\n            if digit\
    \ > 3 {\n                return \"No\"\n            }\n            continue\n\
    \        }\n        if !dot {\n            if b[i] >= 'a' && b[i] <= 'z' {\n \
    \               latin = true\n                continue\n            }\n      \
    \      if b[i] >= 'A' && b[i] <= 'Z' {\n                latin = true\n       \
    \         continue\n            }\n            return \"No\"\n        }\n    \
    \    if dot {\n            if i == len(b) - 3 {\n                ext_str = string(b[i:])\n\
    \                if ext_str == \"txt\" || ext_str == \"exe\" || ext_str == \"\
    dll\" {\n                    ext = true\n                    continue\n      \
    \          }\n            }\n            return \"No\"\n        }\n    }\n   \
    \ if !dot || !ext || !latin {\n        return \"No\"\n    }\n    return \"Yes\"\
    \n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
