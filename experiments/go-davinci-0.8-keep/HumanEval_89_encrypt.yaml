name: HumanEval_89_encrypt
language: go_test.go
prompt: "package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create\
  \ a function encrypt that takes a string as an argument and\n// returns a string\
  \ encrypted with the alphabet being rotated. \n// The alphabet should be rotated\
  \ in a manner such that the letters \n// shift down by two multiplied to two places.\n\
  // For example:\n// encrypt('hi') returns 'lm'\n// encrypt('asdfghjkl') returns\
  \ 'ewhjklnop'\n// encrypt('gf') returns 'kj'\n// encrypt('et') returns 'ix'\nfunc\
  \ encrypt(s string) string {\n"
tests: "func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"\
  asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected:\
  \ \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual:\
  \ candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"\
  hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual:\
  \ candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
  \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return \"\"\n}\n", "    var result string\n\n    for _, ch := range\
    \ s {\n        if ch >= 'A' && ch <= 'Z' {\n            result += string((ch -\
    \ 'A' + 2) % 26 + 'A')\n        } else if ch >= 'a' && ch <= 'z' {\n         \
    \   result += string((ch - 'a' + 2) % 26 + 'a')\n        } else {\n          \
    \  result += string(ch)\n        }\n    }\n\n    return result\n}\n", "    //\
    \ your code here\n    return \"\"\n}\n", "    return \"lm\"\n}\n", "    return\
    \ \"\"\n}\n", "\t// WRITE YOUR CODE HERE\n\treturn \"\"\n}\n", "    sMap := map[string]string\
    \ {\n        \"a\":\"c\",\n        \"b\":\"d\",\n        \"c\":\"e\",\n      \
    \  \"d\":\"f\",\n        \"e\":\"g\",\n        \"f\":\"h\",\n        \"g\":\"\
    j\",\n        \"h\":\"k\",\n        \"i\":\"l\",\n        \"j\":\"m\",\n     \
    \   \"k\":\"n\",\n        \"l\":\"o\",\n        \"m\":\"p\",\n        \"n\":\"\
    q\",\n        \"o\":\"r\",\n        \"p\":\"s\",\n        \"q\":\"t\",\n     \
    \   \"r\":\"u\",\n        \"s\":\"v\",\n        \"t\":\"w\",\n        \"u\":\"\
    x\",\n        \"v\":\"y\",\n        \"w\":\"z\",\n        \"x\":\"a\",\n     \
    \   \"y\":\"b\",\n        \"z\":\"c\",\n    }\n    var sEncrypt string\n    for\
    \ i := 0; i < len(s); i++ {\n        sEncrypt += sMap[string(s[i])]\n    }\n \
    \   return sEncrypt\n}\n", "\tvar final string\n\tfor _, char := range s {\n\t\
    \tif char >= 'a' && char <= 'y' {\n\t\t\tfinal += string(char + 2)\n\t\t} else\
    \ if char == 'z' {\n\t\t\tfinal += \"b\"\n\t\t} else if char == 'x' {\n\t\t\t\
    final += \"a\"\n\t\t} else {\n\t\t\tfinal += string(char)\n\t\t}\n\t}\n\treturn\
    \ final\n}\n", "    return s\n}\n", "    return \"\"\n}\n", "    // Write code\
    \ here.\n}\n", "    // Write code here\n    return \"\"\n}\n", "    var c, r string\n\
    \    for _, c = range s {\n        r += string(c + 2 * 2)\n    }\n    return r\n\
    }\n\n//Create a function decrypt that takes a string as an argument and", "  \
    \  return \"\"\n}\n", "    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var newString string\n    for _, value := range s {\n        var index = alphabet.IndexRune(value)\n\
    \        var newIndex = index + (index * 2)\n        if newIndex > 25 {\n    \
    \        newIndex = newIndex - 26\n        }\n        newString += string(alphabet[newIndex])\n\
    \    }\n    return newString\n}\n", "    s = \"\"\n    return s\n}\n", "    return\
    \ \"kj\"\n}\n", "    return \"\"\n}\n", "\t// Create slice of alphabets\n\talphabets\
    \ := \"abcdefghijklmnopqrstuvwxyz\"\n\t// Create encrypted string\n\tencryptedString\
    \ := \"\"\n\t// Create slice of encrypted alphabets\n\tencryptedAlphabets := []rune(alphabets[2:]\
    \ + alphabets[:2])\n\t// For each letter in string\n\tfor _, letter := range s\
    \ {\n\t\t// Find location of letter\n\t\tlocation := strings.Index(alphabets,\
    \ string(letter))\n\t\t// Set new letter to encrypted letter at same location\n\
    \t\tnewLetter := encryptedAlphabets[location]\n\t\t// Append new letter to encrypted\
    \ string\n\t\tencryptedString += string(newLetter)\n\t}\n\t// Return encrypted\
    \ string\n\treturn encryptedString\n}\n", "\t// Your code here\n\treturn \"\"\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
