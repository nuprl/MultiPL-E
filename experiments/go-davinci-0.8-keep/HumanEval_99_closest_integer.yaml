name: HumanEval_99_closest_integer
language: go_test.go
prompt: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunc closest_integer(value string) int {\n"
tests: "func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     {\
  \ actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"\
  ), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     {\
  \ actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\
  \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return 0\n}\n", "    var n float64\n    fmt.Sscanf(value, \"%f\"\
    , &n)\n    switch {\n    case n >= 0:\n        return int(n + 0.5)\n    default:\n\
    \        return int(n - 0.5)\n    }\n}\n", "    var result int\n    // var value_float\
    \ float64\n    _, err := fmt.Sscanf(value, \"%f\", &result)\n    if err != nil\
    \ {\n        panic(err)\n    }\n    fmt.Println(result)\n    return result\n}\n",
  "    return 0\n}\n", "    number, _ := ParseFloat(value, 64)\n    //  return int(number)\n\
    \    return int(Round(number))\n}\n", "    fvalue, err := strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        panic(err)\n    }\n    // NOTE(nate): This\
    \ isn't neccessarily true.\n    // The closest integer to 15.5 will always be\
    \ 15.5\n    if fvalue == float64(int(fvalue)) {\n        return int(fvalue)\n\
    \    }\n    // NOTE(nate): if the value is positive, we want to\n    // find the\
    \ smallest integer greater than fvalue,\n    // if the value is negative, we want\
    \ to find the\n    // largest integer less than fvalue.\n    if fvalue > 0 {\n\
    \        return int(fvalue) + 1\n    }\n    return int(fvalue) - 1\n}\n", "  \
    \  numbers := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    for _, number := range\
    \ numbers {\n        fmt.Println(number)\n    }\n    return 0\n}\n", "    if value[0]\
    \ == '-' {\n        return -closest_integer(value[1:])\n    }\n    int_value,\
    \ _ := strconv.Atoi(value)\n    float_value, _ := strconv.ParseFloat(value, 64)\n\
    \    if float_value < float64(int_value) + 0.5 {\n        return int_value\n \
    \   }\n    return int_value + 1\n}\n", "    // return int(math.Round(float64(value)))\n\
    \    return 0\n}\n", "    // TODO write code\n    return 0\n}\n", "    // Write\
    \ your code here\n    return 0\n}\n", "    var res int\n    var closest_val float64\n\
    \    for i := 0; i < len(value); i++ {\n        if value[i] == '.' {\n       \
    \     num, _ := strconv.ParseFloat(value, 64)\n            if num > 0 {\n    \
    \            closest_val = math.Ceil(num)\n            } else {\n            \
    \    closest_val = math.Floor(num)\n            }\n            res = int(closest_val)\n\
    \        } else {\n            res, _ = strconv.Atoi(value)\n        }\n    }\n\
    \    return res\n}\n", "    var int_value int\n    var temp_int int\n    var return_value\
    \ int\n    var error_value error\n    var error_flag bool\n\n    // convert the\
    \ string value to an integer\n    int_value, error_value = strconv.Atoi(value)\n\
    \    if error_value != nil {\n        error_flag = true\n    } else {\n      \
    \  error_flag = false\n    }\n\n    // If the number is negative, convert it to\
    \ a positive integer.\n    if error_flag == false {\n        if int_value < 0\
    \ {\n            int_value = int_value * -1\n        }\n    }\n\n    // Check\
    \ whether the number has a decimal place.\n    // If so, round away from zero.\n\
    \    if error_flag == false {\n        if strings.Contains(value, \".\") {\n \
    \           temp_int = int_value\n            int_value = int_value * 100\n  \
    \          return_value = int_value % 10\n            int_value = int_value /\
    \ 10\n            if return_value > 5 {\n                int_value = int_value\
    \ + 1\n            }\n            if temp_int < 0 {\n                int_value\
    \ = int_value * -1\n            }\n        }\n    }\n\n    // return the converted\
    \ value\n    return int_value\n}\n", "    return 0\n}\n", "    var x float64 =\
    \ 0\n    fmt.Sscanf(value, \"%f\", &x)\n    return int(x)\n}\n", "    // Using\
    \ a float64 here to allow for fractional values\n    f, _ := strconv.ParseFloat(value,\
    \ 64)\n    return int(f)\n}\n", "    //TODO: implement this function\n    return\
    \ 0\n}\n", "    return 0\n}\n", "    var dot_index int = 0\n    for i := 0; i\
    \ < len(value); i++ {\n        if value[i] == '.' {\n            dot_index = i\n\
    \            break\n        }\n    }\n    // For example, value := \"15.3\", integer_part\
    \ := \"15\"\n    var integer_part string = value[:dot_index]\n    // For example,\
    \ value := \"15.3\", fractional_part := \"3\"\n    var fractional_part string\
    \ = value[dot_index+1:]\n    integer_part_val, _ := strconv.Atoi(integer_part)\n\
    \    fractional_part_val, _ := strconv.Atoi(fractional_part)\n    // If the number\
    \ is equidistant from two integers, round it away from zero.\n    if fractional_part_val\
    \ > 0 {\n        return integer_part_val + 1\n    } else {\n        return integer_part_val\n\
    \    }\n}\n", "    // TODO: implement the function\n    return 0\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
