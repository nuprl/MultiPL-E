name: HumanEval_143_words_in_sentence
language: go_test.go
prompt: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You are given a string representing a sentence,\n// the sentence contains\
  \ some words separated by a space,\n// and you have to return a string that contains\
  \ the words from the original sentence,\n// whose lengths are prime numbers,\n//\
  \ the order of the words in the new string should be the same as the original one.\n\
  // Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example\
  \ 2:\n// Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
  // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence\
  \ string) string {\n"
tests: "func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"\
  is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\"\
  \ },\n     { actual: candidate(\"there is no place available here\"), expected:\
  \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
  \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go\
  \ for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual:\
  \ candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    if \"\" == sentence {\n        return \"\"\n    }\n    slice :=\
    \ strings.Split(sentence, \" \")\n    // To use a custom sort function, implement\
    \ the interface type, by writing a\n    // Len, Less, and Swap method.\n    var\
    \ sortable sliceType\n    sortable = slice\n    // Convert the type to sort.Interface\n\
    \    sort.Sort(sortable)\n    return strings.Join(slice, \" \")\n}\n\ntype sliceType\
    \ []string\n", "    words := strings.Split(sentence, \" \")\n    var primeWords\
    \ []string\n    for _, word := range words {\n        if isPrime(len(word)) {\n\
    \            primeWords = append(primeWords, word)\n        }\n    }\n    return\
    \ strings.Join(primeWords, \" \")\n}\n", "    words := []string{}\n    for _,\
    \ word := range strings.Split(sentence, \" \") {\n        if is_prime(len(word))\
    \ {\n            words = append(words, word)\n        }\n    }\n    return strings.Join(words,\
    \ \" \")\n}\n", "    if len(sentence) == 0 {\n        return \"\"\n    }\n   \
    \ var ans string\n    var words []string\n    var wordStart, wordEnd int\n   \
    \ // parse words\n    for wordEnd < len(sentence) {\n        if sentence[wordEnd]\
    \ == ' ' {\n            if wordEnd == wordStart {\n                wordStart++\n\
    \                wordEnd++\n                continue\n            }\n        \
    \    words = append(words, sentence[wordStart:wordEnd])\n            wordStart\
    \ = wordEnd + 1\n            wordEnd = wordStart\n        } else {\n         \
    \   wordEnd++\n        }\n    }\n    // last word\n    if wordEnd > wordStart\
    \ {\n        words = append(words, sentence[wordStart:wordEnd])\n    }\n    //\
    \ filter words\n    for _, word := range words {\n        if isPrime(len(word))\
    \ {\n            ans += word + \" \"\n        }\n    }\n    // trim last ' '\n\
    \    if len(ans) > 0 {\n        ans = ans[:len(ans)-1]\n    }\n    return ans\n\
    }\n", "    words := []string{}\n    for i := 0; i < len(sentence); i++ {\n   \
    \     for j := i; j < len(sentence); j++ {\n            if sentence[j] == ' '\
    \ {\n                words = append(words, sentence[i:j])\n                i =\
    \ j + 1\n                break\n            }\n        }\n    }\n    is_prime\
    \ := func(n int) bool {\n        if n <= 1 {\n            return false\n     \
    \   }\n        for i := 2; i * i <= n; i++ {\n            if n % i == 0 {\n  \
    \              return false\n            }\n        }\n        return true\n \
    \   }\n    res := \"\"\n    for _, word := range words {\n        if is_prime(len(word))\
    \ {\n            res += word + \" \"\n        }\n    }\n    if len(res) > 0 {\n\
    \        res = res[:len(res) - 1]\n    }\n    return res\n}\n", "    // if 0 ==\
    \ len(sentence) {\n    //     return sentence\n    // }\n    // var slen = len(sentence)\n\
    \    // var words = strings.Split(sentence, \" \")\n    // var prime_words = []string{}\n\
    \    // for _, word := range words {\n    //     var wlen = len(word)\n    //\
    \     if 2 <= wlen && is_prime(wlen) {\n    //         prime_words = append(prime_words,\
    \ word)\n    //     }\n    // }\n    // return strings.Join(prime_words, \" \"\
    )\n    return \"\"\n}\n", "    var set = map[int]bool{\n        2: true,\n   \
    \     3: true,\n        5: true,\n        7: true,\n        11: true,\n      \
    \  13: true,\n        17: true,\n        19: true,\n        23: true,\n      \
    \  29: true,\n        31: true,\n        37: true,\n        41: true,\n      \
    \  43: true,\n        47: true,\n        53: true,\n        59: true,\n      \
    \  61: true,\n        67: true,\n        71: true,\n        73: true,\n      \
    \  79: true,\n        83: true,\n        89: true,\n        97: true,\n    }\n\
    \    var current, answer string\n    for _, v := range sentence {\n        if\
    \ v == ' ' {\n            if set[len(current)] {\n                answer += current\
    \ + \" \"\n            }\n            current = \"\"\n        } else {\n     \
    \       current += string(v)\n        }\n    }\n    if set[len(current)] {\n \
    \       answer += current\n    }\n    return answer\n}\n", "    words := strings.Split(sentence,\
    \ \" \")\n    result := make([]string, 0)\n    for _, word := range words {\n\
    \        if IsPrime(len(word)) {\n            result = append(result, word)\n\
    \        }\n    }\n    return strings.Join(result, \" \")\n}\n", "    words :=\
    \ make([]string, 0)\n    word := \"\"\n    for _, ch := range sentence {\n   \
    \     if ch == ' ' {\n            words = append(words, word)\n            word\
    \ = \"\"\n        } else {\n            word += string(ch)\n        }\n    }\n\
    \    words = append(words, word)\n    word = \"\"\n    for _, word := range words\
    \ {\n        if is_prime(len(word)) {\n            word += \" \"\n        }\n\
    \    }\n    return word\n}\n", "    words := make([]string, 0)\n    for i := 0;\
    \ i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            continue\n\
    \        }\n        j := i\n        for ; j < len(sentence) && sentence[j] !=\
    \ ' '; j++ {}\n        words = append(words, sentence[i:j])\n        i = j\n \
    \   }\n    primes := make([]int, 0)\n    for i := 2; i < len(words); i++ {\n \
    \       is_prime := true\n        for j := 2; j * j <= i; j++ {\n            if\
    \ i % j == 0 {\n                is_prime = false\n                break\n    \
    \        }\n        }\n        if is_prime {\n            primes = append(primes,\
    \ i)\n        }\n    }\n    result := make([]string, 0)\n    for _, i := range\
    \ primes {\n        result = append(result, words[i])\n    }\n    return fmt.Sprintf(\"\
    %s\", result)\n}\n", "    var words, primes []string\n    isPrime := func(n int)\
    \ bool {\n        if n < 2 {\n            return false\n        }\n        for\
    \ i := 2; i < n; i++ {\n            if n % i == 0 {\n                return false\n\
    \            }\n        }\n        return true\n    }\n    for _, word := range\
    \ sentence {\n        if word != ' ' {\n            words = append(words, string(word))\n\
    \        } else {\n            if isPrime(len(words)) {\n                primes\
    \ = append(primes, strings.Join(words, \"\"))\n            }\n            words\
    \ = []string{}\n        }\n    }\n    if isPrime(len(words)) {\n        primes\
    \ = append(primes, strings.Join(words, \"\"))\n    }\n    return strings.Join(primes,\
    \ \" \")\n}\n", "    if sentence == \"\" {\n        return \"\"\n    }\n    words\
    \ := get_words(sentence)\n    primes := get_primes()\n    result := \"\"\n   \
    \ for _, word := range words {\n        if primes[len(word)] {\n            result\
    \ += word + \" \"\n        }\n    }\n    return result[:len(result) - 1]\n}\n",
  "    ps := sieve(101)\n    words := strings.Split(sentence, \" \")\n    result :=\
    \ make([]string, 0)\n    for _, word := range words {\n        if ps[len(word)]\
    \ {\n            result = append(result, word)\n        }\n    }\n    return strings.Join(result,\
    \ \" \")\n}\n", "    words := make([]string, 0)\n    length := len(sentence)\n\
    \    for i := 0; i < length; i++ {\n        if (sentence[i] == ' ') {\n      \
    \      continue\n        }\n        word := sentence[i:]\n        i += len(word)\n\
    \        words = append(words, word)\n    }\n    fmt.Println(words)\n    primes\
    \ := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97}\n    valid_words := make([]string, 0)\n    for _,\
    \ word := range words {\n        for _, prime := range primes {\n            if\
    \ (len(word) == prime) {\n                valid_words = append(valid_words, word)\n\
    \                break\n            }\n        }\n    }\n    return strings.Join(valid_words,\
    \ \" \")\n}\n", "    var res []byte\n    var b byte\n    var w []byte\n    var\
    \ in_word bool\n    var is_prime bool\n    for _, b = range sentence {\n     \
    \   if b != ' ' {\n            if !in_word {\n                in_word = true\n\
    \                w = make([]byte, 0)\n            }\n            w = append(w,\
    \ byte(b))\n        } else {\n            if in_word {\n                in_word\
    \ = false\n                is_prime = true\n                var n int\n      \
    \          n = len(w)\n                for i := 2; i < n; i++ {\n            \
    \        if n % i == 0 {\n                        is_prime = false\n         \
    \               break\n                    }\n                }\n            \
    \    if is_prime {\n                    res = append(res, w...)\n            \
    \        res = append(res, ' ')\n                }\n            }\n        }\n\
    \    }\n    if in_word {\n        is_prime = true\n        var n int\n       \
    \ n = len(w)\n        for i := 2; i < n; i++ {\n            if n % i == 0 {\n\
    \                is_prime = false\n                break\n            }\n    \
    \    }\n        if is_prime {\n            res = append(res, w...)\n        }\n\
    \    }\n    if len(res) > 0 {\n        res = res[:len(res)-1]\n    }\n    return\
    \ string(res)\n}\n", "    words := []string{}\n    word := \"\"\n    for _, c\
    \ := range sentence {\n        if c == ' ' {\n            words = append(words,\
    \ word)\n            word = \"\"\n        } else {\n            word += string(c)\n\
    \        }\n    }\n    words = append(words, word)\n    primes := map[int]bool{}\n\
    \    primes[2] = true\n    primes[3] = true\n    primes[5] = true\n    primes[7]\
    \ = true\n    primes[11] = true\n    primes[13] = true\n    primes[17] = true\n\
    \    primes[19] = true\n    primes[23] = true\n    primes[29] = true\n    primes[31]\
    \ = true\n    words_prime := []string{}\n    for _, word := range words {\n  \
    \      if primes[len(word)] {\n            words_prime = append(words_prime, word)\n\
    \        }\n    }\n    return words_prime_string(words_prime)\n}\n", "    var\
    \ primeSet = map[int]bool{2: true, 3: true, 5: true, 7: true, 11: true, 13: true,\
    \ 17: true, 19: true, 23: true, 29: true, 31: true, 37: true, 41: true, 43: true,\
    \ 47: true, 53: true, 59: true, 61: true, 67: true, 71: true, 73: true, 79: true,\
    \ 83: true, 89: true, 97: true}\n    var words = strings.Split(sentence, \" \"\
    )\n    var primeWords []string\n    for _, word := range words {\n        if primeSet[len(word)]\
    \ {\n            primeWords = append(primeWords, word)\n        }\n    }\n   \
    \ return strings.Join(primeWords, \" \")\n}\n", "    if len(sentence) == 0 {\n\
    \        return \"\"\n    }\n    var res []string\n    // Split the sentence into\
    \ words\n    words := strings.Split(sentence, \" \")\n    for _, word := range\
    \ words {\n        if len(word) == 1 {\n            res = append(res, word)\n\
    \        } else {\n            // If word length is 2 or more, check for prime\
    \ numbers\n            if is_prime(len(word)) {\n                res = append(res,\
    \ word)\n            }\n        }\n    }\n    return strings.Join(res, \" \")\n\
    }\n", "    r := []rune(sentence)\n    s := \"\"\n    for i := 0; i < len(r); i++\
    \ {\n        if r[i] == ' ' {\n            if is_prime(i) {\n                s\
    \ += sentence[:i]\n                break\n            }\n        }\n    }\n  \
    \  for i := 0; i < len(r); i++ {\n        if r[i] == ' ' {\n            if is_prime(i\
    \ - len(s)) {\n                s += \" \" + sentence[len(s):i]\n            }\n\
    \        }\n    }\n    if is_prime(len(r) - len(s)) {\n        s += \" \" + sentence[len(s):]\n\
    \    }\n    return s\n}\n", "    result := \"\"\n    for _, word := range strings.Split(sentence,\
    \ \" \") {\n        l := len(word)\n        if l <= 1 {\n            continue\n\
    \        }\n        if l == 2 {\n            result += word + \" \"\n        \
    \    continue\n        }\n        if l % 2 == 0 {\n            continue\n    \
    \    }\n        if is_prime(l) {\n            result += word + \" \"\n       \
    \ }\n    }\n    if len(result) > 0 {\n        result = result[:len(result)-1]\n\
    \    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
