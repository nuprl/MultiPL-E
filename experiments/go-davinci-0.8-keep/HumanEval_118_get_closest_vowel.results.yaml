language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    runes := []rune(word)\n    if len(runes) == 0 {\n    \
    \    return \"\"\n    }\n\n    if len(runes) == 1 {\n        return \"\"\n   \
    \ }\n\n    var vowels = make(map[rune]bool)\n    vowels['a'] = true\n    vowels['e']\
    \ = true\n    vowels['i'] = true\n    vowels['o'] = true\n    vowels['u'] = true\n\
    \n    var consonants = make(map[rune]bool)\n    consonants['b'] = true\n    consonants['c']\
    \ = true\n    consonants['d'] = true\n    consonants['f'] = true\n    consonants['g']\
    \ = true\n    consonants['h'] = true\n    consonants['j'] = true\n    consonants['k']\
    \ = true\n    consonants['l'] = true\n    consonants['m'] = true\n    consonants['n']\
    \ = true\n    consonants['p'] = true\n    consonants['q'] = true\n    consonants['r']\
    \ = true\n    consonants['s'] = true\n    consonants['t'] = true\n    consonants['v']\
    \ = true\n    consonants['w'] = true\n    consonants['x'] = true\n    consonants['y']\
    \ = true\n    consonants['z'] = true\n\n    for i := len(runes) - 1; i > 0; i--\
    \ {\n        if consonants[runes[i]] {\n            if vowels[runes[i - 1]] {\n\
    \                return string(runes[i - 1])\n            }\n        }\n    }\n\
    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp6gfxc67r_test.go:94: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp6gfxc67r_test.go:94: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp6gfxc67r_test.go:94: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp6gfxc67r_test.go:94: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code\n    var vowels = \"AEIOUaeiou\"\n    var\
    \ candidate string\n    var current_index int\n    var current_char rune\n   \
    \ var num_consonants int\n\n    for i := len(word) - 1; i >= 0; i-- {\n      \
    \  current_char = rune(word[i])\n        current_index = -1\n        for j :=\
    \ 0; j < len(vowels); j++ {\n            if current_char == rune(vowels[j]) {\n\
    \                current_index = j\n                break\n            }\n   \
    \     }\n        if current_index != -1 {\n            if num_consonants > 1 {\n\
    \                return string(current_char)\n            } else {\n         \
    \       candidate = string(current_char)\n            }\n        } else {\n  \
    \          num_consonants++\n        }\n    }\n    return candidate\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpgw5rmmve_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpgw5rmmve_test.go:73: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpgw5rmmve_test.go:73: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpgw5rmmve_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpgw5rmmve_test.go:73: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpgw5rmmve_test.go:73: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpgw5rmmve_test.go:73: expected 'i', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpgw5rmmve_test.go:73:\
    \ expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpgw5rmmve_test.go:73: expected 'o', got 'A'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// your code goes here\n\treturn \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpke0adao__test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpke0adao__test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpke0adao__test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpke0adao__test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpke0adao__test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpke0adao__test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsldana17_test.go:19:24: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var prev_is_consonant = false\n    var next_is_consonant\
    \ = false\n    for i, c := range word {\n        next_is_consonant = false\n \
    \       if contains(vowels, string(c)) {\n            if i == 0 {\n          \
    \      prev_is_consonant = true\n            } else {\n                prev_is_consonant\
    \ = !contains(vowels, string(word[i-1]))\n            }\n            if i == len(word)-1\
    \ {\n                next_is_consonant = true\n            } else {\n        \
    \        next_is_consonant = !contains(vowels, string(word[i+1]))\n          \
    \  }\n            if prev_is_consonant && next_is_consonant {\n              \
    \  result = string(c)\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpshkea5sg_test.go:25:12: undefined: contains

    /tmp/tmpshkea5sg_test.go:29:38: undefined: contains

    /tmp/tmpshkea5sg_test.go:34:38: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i:=len(word)-1; i>=0; i-- {\n        switch word[i]\
    \ {\n        case 'a':\n            if i+1 < len(word) && is_const(word[i+1])\
    \ {\n                return string(word[i])\n            }\n        case 'e':\n\
    \            if i+1 < len(word) && is_const(word[i+1]) {\n                return\
    \ string(word[i])\n            }\n        case 'i':\n            if i+1 < len(word)\
    \ && is_const(word[i+1]) {\n                return string(word[i])\n         \
    \   }\n        case 'o':\n            if i+1 < len(word) && is_const(word[i+1])\
    \ {\n                return string(word[i])\n            }\n        case 'u':\n\
    \            if i+1 < len(word) && is_const(word[i+1]) {\n                return\
    \ string(word[i])\n            }\n        default:\n            continue\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi4o49ji4_test.go:22:35: undefined: is_const

    /tmp/tmpi4o49ji4_test.go:26:35: undefined: is_const

    /tmp/tmpi4o49ji4_test.go:30:35: undefined: is_const

    /tmp/tmpi4o49ji4_test.go:34:35: undefined: is_const

    /tmp/tmpi4o49ji4_test.go:38:35: undefined: is_const

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    last_consonant := rune(-1)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            if last_consonant\
    \ == -1 {\n                return \"\"\n            }\n            return string(word[i])\n\
    \        }\n        last_consonant = rune(word[i])\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp3_e112v4_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp3_e112v4_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp3_e112v4_test.go:58: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp3_e112v4_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp3_e112v4_test.go:58:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp3_e112v4_test.go:58: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// your code here\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnr5laeas_test.go:20:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 2; i >= 0; i-- {\n        fmt.Println(i)\n\
    \        if isVowel(word[i+1]) {\n            continue\n        }\n        if\
    \ isVowel(word[i]) {\n            return string(word[i])\n        }\n    }\n \
    \   return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnaa405v9_test.go:21:12: undefined: isVowel

    /tmp/tmpnaa405v9_test.go:24:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"\
    o\":1, \"u\":1}\n    var (\n        i, index int\n        lastVowel string\n \
    \   )\n    for i = len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            lastVowel = string(word[i])\n            index = i\n     \
    \       break\n        }\n    }\n    if lastVowel == \"\" {\n        return \"\
    \"\n    }\n    for i = index - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ !ok {\n            return lastVowel\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp06ra1u73_test.go:67: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp06ra1u73_test.go:67: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp06ra1u73_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp06ra1u73_test.go:67: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp06ra1u73_test.go:67:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp06ra1u73_test.go:67: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code goes here\n    const vowels = \"aeiouAEIOU\"\
    \n    var result rune = 0\n    last_found := 0\n    for i,c := range word {\n\
    \        if last_found == 0 {\n            if strings.Contains(vowels, string(c))\
    \ {\n                last_found = i\n            }\n        } else {\n       \
    \     if !strings.Contains(vowels, string(c)) {\n                result = word[last_found]\n\
    \                break\n            }\n        }\n    }\n    return string(result)\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpre82plzi_test.go:25:16: undefined: strings

    /tmp/tmpre82plzi_test.go:29:17: undefined: strings

    /tmp/tmpre82plzi_test.go:30:26: cannot use word[last_found] (value of type byte)
    as type rune in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if word == \"\" {\n        return \"\"\n    }\n    var\
    \ vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var result = \"\"\n\
    \    var lastIndex = len(word) - 1\n    var lastVowelIndex = -1\n    for i :=\
    \ lastIndex; i >= 0; i-- {\n        if isVowel(vowels, string(word[i])) {\n  \
    \          lastVowelIndex = i\n            break\n        }\n    }\n    if lastVowelIndex\
    \ == -1 {\n        return \"\"\n    }\n    if lastVowelIndex == lastIndex {\n\
    \        return \"\"\n    }\n    var lastConsonantIndex = lastVowelIndex + 1\n\
    \    for i := lastConsonantIndex; i <= lastIndex; i++ {\n        if !isVowel(vowels,\
    \ string(word[i])) {\n            lastConsonantIndex = i\n            break\n\
    \        }\n    }\n    if lastConsonantIndex == lastIndex {\n        return \"\
    \"\n    }\n    if lastConsonantIndex == lastVowelIndex + 1 {\n        return \"\
    \"\n    }\n    result = string(word[lastVowelIndex])\n    return result\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9s604_26_test.go:27:12: undefined: isVowel

    /tmp/tmp9s604_26_test.go:40:13: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppazq001k_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppazq001k_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppazq001k_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppazq001k_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppazq001k_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppazq001k_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) <= 2 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]int {\n        \"a\": 0,\n        \"e\": 0,\n        \"i\": 0,\n\
    \        \"o\": 0,\n        \"u\": 0,\n    }\n    for i, value := range word {\n\
    \        _, ok := vowels[string(value)]\n        if ok {\n            vowels[string(value)]\
    \ = i\n        }\n    }\n    idx, min := -1, -1\n    for k, v := range vowels\
    \ {\n        if v == 0 {\n            continue\n        }\n        if idx == -1\
    \ {\n            idx = v\n            min = v\n        } else {\n            if\
    \ idx < v && v - idx < min {\n                min = v - idx\n                idx\
    \ = v\n            }\n        }\n    }\n    return string(word[idx])\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj3imf2dx_test.go:36:9: k declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = \"aeiou\"\n    var isConsonant = true\n \
    \   var closest = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ vowels[0] == word[i] || vowels[1] == word[i] || vowels[2] == word[i] || vowels[3]\
    \ == word[i] || vowels[4] == word[i] {\n            if !isConsonant {\n      \
    \          closest = string(word[i])\n                break\n            }\n \
    \       } else {\n            isConsonant = true\n        }\n    }\n    return\
    \ closest\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpm9uj4bd6_test.go:60: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpm9uj4bd6_test.go:60: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpm9uj4bd6_test.go:60: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpm9uj4bd6_test.go:60: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpm9uj4bd6_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpm9uj4bd6_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppqqzi0uz_test.go:48: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppqqzi0uz_test.go:48: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppqqzi0uz_test.go:48: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppqqzi0uz_test.go:48:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqqzi0uz_test.go:48: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tclosest_vowel := \"\"\n\tclosest_distance := 0\n\tvowels\
    \ := \"aeiou\"\n\tconsonants := \"bcdfghjklmnpqrstvwxyz\"\n\tword_count := len(word)\n\
    \tfor i := word_count - 1; i > 0; i-- {\n\t\tif string(word[i]) == \"a\" || string(word[i])\
    \ == \"e\" || string(word[i]) == \"i\" || string(word[i]) == \"o\" || string(word[i])\
    \ == \"u\" {\n\t\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\t\tif string(word[j])\
    \ == \"a\" || string(word[j]) == \"e\" || string(word[j]) == \"i\" || string(word[j])\
    \ == \"o\" || string(word[j]) == \"u\" {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\
    \t\t\t\tif closest_distance == 0 {\n\t\t\t\t\t\tclosest_distance = i - j\n\t\t\
    \t\t\t\tclosest_vowel = string(word[i])\n\t\t\t\t\t} else if i - j < closest_distance\
    \ {\n\t\t\t\t\t\tclosest_distance = i - j\n\t\t\t\t\t\tclosest_vowel = string(word[i])\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn closest_vowel\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphvslb_mr_test.go:21:2: vowels declared but not used

    /tmp/tmphvslb_mr_test.go:22:2: consonants declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
    quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel_idx := -1\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            vowel_idx = i\n            break\n \
    \       }\n    }\n    if vowel_idx == -1 {\n        return \"\"\n    }\n    if\
    \ vowel_idx == len(word) - 1 {\n        return \"\"\n    }\n    if vowel_idx ==\
    \ 0 {\n        return \"\"\n    }\n    for i := vowel_idx + 1; i < len(word);\
    \ i++ {\n        if word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i]\
    \ != 'o' && word[i] != 'u' {\n            for j := vowel_idx - 1; j >= 0; j--\
    \ {\n                if word[j] != 'a' && word[j] != 'e' && word[j] != 'i' &&\
    \ word[j] != 'o' && word[j] != 'u' {\n                    return string(word[vowel_idx])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmphun1m2gm_test.go:72: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphun1m2gm_test.go:72:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphun1m2gm_test.go:72: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074637
