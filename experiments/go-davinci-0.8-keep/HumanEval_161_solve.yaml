name: HumanEval_161_solve
language: go_test.go
prompt: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You\
  \ are given a string s.\n// if s[i] is a letter, reverse its case from lower to\
  \ upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
  \ no letters, reverse the string.\n// The function should return the resulted string.\n\
  // Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"\
  #a@C\") = \"#A@c\"\nfunc solve(s string) string {\n"
tests: "func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
  1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\"\
  \ },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
  \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
  #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"\
  #$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\t\
  for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(s) == 0 {\n        return s\n    }\n    if len(s) == 1 {\n\
    \        return string(s[0])\n    }\n    var r rune\n    for i, v := range s {\n\
    \        if v < 48 || v > 122 || (v > 57 && v < 65) || (v > 90 && v < 97) {\n\
    \            continue\n        }\n        if v < 97 {\n            r = v + 32\n\
    \        } else {\n            r = v - 32\n        }\n        s = s[:i] + string(r)\
    \ + s[i+1:]\n    }\n    return s\n}\n", "    var result string\n    var isLetter\
    \ bool\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' ||\
    \ char >= 'A' && char <= 'Z' {\n            isLetter = true\n            if char\
    \ >= 'a' && char <= 'z' {\n                result += string(rune(char - 32))\n\
    \            } else {\n                result += string(rune(char + 32))\n   \
    \         }\n        } else {\n            result += string(char)\n        }\n\
    \    }\n    if !isLetter {\n        for i, j := 0, len(result) - 1; i < j; i,\
    \ j = i + 1, j - 1 {\n            result[i], result[j] = result[j], result[i]\n\
    \        }\n    }\n    return result\n}\n", "    for i := 0; i < len(s); i++ {\n\
    \        if (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') {\n \
    \           if s[i] == s[i] + 32 || s[i] == s[i] - 32 {\n                s = s[:i]\
    \ + string(s[i] + 32) + s[i+1:]\n            } else {\n                s = s[:i]\
    \ + string(s[i] - 32) + s[i+1:]\n            }\n        }\n    }\n    return s\n\
    }\n", "    count := 0\n    for _, v := range s {\n        if unicode.IsLetter(v)\
    \ {\n            count++\n        }\n    }\n    if count == 0 {\n        return\
    \ reverseString(s)\n    }\n    var output string\n    for _, v := range s {\n\
    \        if unicode.IsLetter(v) {\n            if unicode.IsUpper(v) {\n     \
    \           output += string(unicode.ToLower(v))\n            } else {\n     \
    \           output += string(unicode.ToUpper(v))\n            }\n        } else\
    \ {\n            output += string(v)\n        }\n    }\n    return output\n}\n",
  "    var l,r int\n    var c,rune rune\n    if len(s) == 0 { return s }\n    r =\
    \ len(s) - 1\n    for l < r {\n        if c = rune(s[l]); c >= 'a' && c <= 'z'\
    \ || c >= 'A' && c <= 'Z' {\n            if rune(s[r]) >= 'a' && rune(s[r]) <=\
    \ 'z' || rune(s[r]) >= 'A' && rune(s[r]) <= 'Z' {\n                s = s[:l] +\
    \ string(s[r]) + s[l+1:r] + string(c) + s[r+1:]\n                l++\n       \
    \         r--\n            } else {\n                r--\n            }\n    \
    \    } else {\n            l++\n        }\n    }\n    return s\n}\n", "    //\
    \ Your code here\n    return s\n}\n", "    return \"\"\n}\n", "    isLetter :=\
    \ false\n    for _, c := range s {\n        if c >= 'a' && c <= 'z' || c >= 'A'\
    \ && c <= 'Z' {\n            isLetter = true\n            break\n        }\n \
    \   }\n    if !isLetter {\n        return reverse(s)\n    }\n    result := \"\"\
    \n    for _, c := range s {\n        if c >= 'a' && c <= 'z' {\n            result\
    \ += string(c - 32)\n        } else if c >= 'A' && c <= 'Z' {\n            result\
    \ += string(c + 32)\n        } else {\n            result += string(c)\n     \
    \   }\n    }\n    return result\n}\n", "    if len(s) == 0 {\n        return s\n\
    \    }\n    var sb strings.Builder\n    for _, c := range s {\n        if c >=\
    \ 'a' && c <= 'z' {\n            sb.WriteRune(c - 32)\n        } else if c >=\
    \ 'A' && c <= 'Z' {\n            sb.WriteRune(c + 32)\n        } else {\n    \
    \        sb.WriteRune(c)\n        }\n    }\n    return sb.String()\n}\n", "  \
    \  // your code here\n    return \"\"\n}\n", "    // your code here\n    var reverse\
    \ func(r rune) rune\n\n    if containsOnlyDigits(s) {\n        reverse = func(r\
    \ rune) rune {\n            return r\n        }\n    } else {\n        reverse\
    \ = func(r rune) rune {\n            if isDigit(r) {\n                return r\n\
    \            } else if isLower(r) {\n                return toUpper(r)\n     \
    \       } else {\n                return toLower(r)\n            }\n        }\n\
    \    }\n\n    return reverseString(s, reverse)\n}\n", "    // your code here\n\
    \    var s2 string = \"\"\n    for _, b := range s {\n        if (b >= 65 && b\
    \ <= 90) || (b >= 97 && b <= 122) {\n            s2 += string(b^32)\n        }\
    \ else {\n            s2 += string(b)\n        }\n    }\n    return s2\n}\n",
  "    res := \"\"\n    allAlpha := true\n    for _, ch := range s {\n        if (ch\
    \ >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') {\n            allAlpha = false\n\
    \            if ch >= 'a' && ch <= 'z' {\n                res += string(ch - 32)\n\
    \            } else {\n                res += string(ch + 32)\n            }\n\
    \        } else {\n            res += string(ch)\n        }\n    }\n    if allAlpha\
    \ {\n        res = reverseString(res)\n    }\n    return res\n}\n", "    n :=\
    \ len(s)\n    if n == 0 {\n        return s\n    }\n    b := make([]byte, n)\n\
    \    for i, c := range []byte(s) {\n        // no letters\n        if 'a' > c\
    \ || c > 'z' {\n            b[n-i-1] = c\n        } else {\n            b[n-i-1]\
    \ = c ^ 0x20\n        }\n    }\n    return string(b)\n}\n", "    letter := false\n\
    \    for _, ch := range s {\n        if ch >= 'a' && ch <= 'z' || ch >= 'A' &&\
    \ ch <= 'Z' {\n            letter = true\n            break\n        }\n    }\n\
    \    if !letter {\n        return reverse(s)\n    }\n    result := make([]byte,\
    \ len(s))\n    for i, ch := range s {\n        if ch >= 'a' && ch <= 'z' {\n \
    \           result[i] = byte(ch - 'a' + 'A')\n        } else if ch >= 'A' && ch\
    \ <= 'Z' {\n            result[i] = byte(ch - 'A' + 'a')\n        } else {\n \
    \           result[i] = byte(ch)\n        }\n    }\n    return string(result)\n\
    }\n", "    res := \"\"\n    for _, r := range s {\n        if (r >= 'a' && r <=\
    \ 'z') || (r >= 'A' && r <= 'Z') {\n            if (r >= 'a' && r <= 'z') {\n\
    \                res += string(r - 'a' + 'A')\n            } else {\n        \
    \        res += string(r - 'A' + 'a')\n            }\n        } else {\n     \
    \       res += string(r)\n        }\n    }\n    return res\n}\n", "    fmt.Println(s)\n\
    \    // \u5224\u65AD\u6709\u6CA1\u6709\u5B57\u6BCD\n    flag := 0\n    for _,\
    \ value := range s {\n        if value >= 'a' && value <= 'z' || value >= 'A'\
    \ && value <= 'Z' {\n            flag = 1\n            break\n        }\n    }\n\
    \    if flag == 0 {\n        return reverse(s)\n    }\n    result := \"\"\n  \
    \  for _, value := range s {\n        if value >= 'a' && value <= 'z' {\n    \
    \        result += string(value - 32)\n        } else if value >= 'A' && value\
    \ <= 'Z' {\n            result += string(value + 32)\n        } else {\n     \
    \       result += string(value)\n        }\n    }\n    return result\n}\n", " \
    \   r := []rune(s)\n    p := -1\n    for i, v := range s {\n        if unicode.IsLetter(v)\
    \ {\n            r[i] = unicode.ToLower(v) if unicode.IsUpper(v) else unicode.ToUpper(v)\n\
    \            p = i\n        }\n    }\n    if p >= 0 {\n        s = string(r)\n\
    \    } else {\n        for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\n\
    \            r[i], r[j] = r[j], r[i]\n        }\n        s = string(r)\n    }\n\
    \    return s\n}\n", "    if !hasAlpha(s) {\n        return reverse(s)\n    }\n\
    \    res := make([]byte, len(s))\n    for i, c := range s {\n        switch {\n\
    \        case c >= 'a' && c <= 'z':\n            res[i] = byte(c - 32)\n     \
    \   case c >= 'A' && c <= 'Z':\n            res[i] = byte(c + 32)\n        default:\n\
    \            res[i] = byte(c)\n        }\n    }\n    return string(res)\n}\n",
  "    for i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n  \
    \          s = s[:i] + string(s[i] - 32) + s[i+1:]\n        } else if s[i] >=\
    \ 'A' && s[i] <= 'Z' {\n            s = s[:i] + string(s[i] + 32) + s[i+1:]\n\
    \        }\n    }\n    return s\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
