name: HumanEval_26_remove_duplicates
language: go_test.go
prompt: "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// From a list of integers, remove all elements that occur more than once.\n\
  // Keep order of elements left the same as in the input.\n// >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n// [1, 3, 4]\nfunc remove_duplicates(numbers []int) []int {\n"
tests: "func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
  \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n \
  \    { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    l := len(numbers)\n    unique_number_map := make(map[int]bool)\n\
    \    result := make([]int, 0, l)\n    for _, num := range numbers {\n        if\
    \ !unique_number_map[num] {\n            unique_number_map[num] = true\n     \
    \       result = append(result, num)\n        }\n    }\n    return result\n}\n",
  "    unique := []int{}\n    for _, n := range numbers {\n        if !contains(unique,\
    \ n) {\n            unique = append(unique, n)\n        }\n    }\n    return unique\n\
    }\n", "    hashMap := make(map[int]bool)\n    for _, number := range numbers {\n\
    \        hashMap[number] = true\n    }\n    var result []int\n    for number,\
    \ _ := range hashMap {\n        result = append(result, number)\n    }\n    return\
    \ result\n}\n", "    var result []int\n    unique_numbers := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        if !unique_numbers[number] {\n\
    \            unique_numbers[number] = true\n            result = append(result,\
    \ number)\n        }\n    }\n    return result\n}\n", "    cache := make(map[int]bool)\n\
    \    non_duplicates := make([]int, 0)\n    for _, number := range numbers {\n\
    \        if _, ok := cache[number]; !ok {\n            cache[number] = true\n\
    \            non_duplicates = append(non_duplicates, number)\n        }\n    }\n\
    \    return non_duplicates\n}\n", "    var res []int\n    for i := 0; i < len(numbers);\
    \ i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[i]\
    \ == numbers[j] {\n                numbers[i] = 0\n                numbers[j]\
    \ = 0\n            }\n        }\n    }\n    for _, number := range numbers {\n\
    \        if number != 0 {\n            res = append(res, number)\n        }\n\
    \    }\n    return res\n}\n", "    result := []int{}\n    seen := make(map[int]int)\n\
    \    for _, number := range numbers {\n        if _, found := seen[number]; !found\
    \ {\n            result = append(result, number)\n            seen[number] = 1\n\
    \        }\n    }\n    return result\n}\n", "    var occurrences = make(map[int]int)\n\
    \    var result []int\n\n    for _, number := range numbers {\n        occurrences[number]\
    \ += 1\n    }\n\n    for _, number := range numbers {\n        if occurrences[number]\
    \ == 1 {\n            result = append(result, number)\n        }\n    }\n\n  \
    \  return result\n}\n", "    var result []int\n    dups := make(map[int]bool)\n\
    \    for _, n := range numbers {\n        if !dups[n] {\n            result =\
    \ append(result, n)\n            dups[n] = true\n        }\n    }\n    return\
    \ result\n}\n", "    exists := make(map[int]bool)\n    result := make([]int, 0)\n\
    \    for _, n := range numbers {\n        if exists[n] {\n            continue\n\
    \        }\n        exists[n] = true\n        result = append(result, n)\n   \
    \ }\n    return result\n}\n", "    result := []int{}\n    exists := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        if !exists[number] {\n        \
    \    result = append(result, number)\n            exists[number] = true\n    \
    \    }\n    }\n    return result\n}\n", "    dict := make(map[int]int)\n    for\
    \ _, n := range numbers {\n        dict[n]++\n    }\n    result := make([]int,\
    \ 0)\n    for _, n := range numbers {\n        if dict[n] == 1 {\n           \
    \ result = append(result, n)\n        }\n    }\n    return result\n}\n", "   \
    \ uniques := make([]int, 0)\n    alreadySeen := make(map[int]bool)\n    for _,\
    \ n := range numbers {\n        if !alreadySeen[n] {\n            uniques = append(uniques,\
    \ n)\n            alreadySeen[n] = true\n        }\n    }\n    return uniques\n\
    }\n", "    var result []int\n    for _, n := range numbers {\n        if n ==\
    \ n {\n            result = append(result, n)\n        }\n    }\n    return result\n\
    }\n", "    var result []int\n    for i := 0; i < len(numbers); i++ {\n       \
    \ if !contains(result, numbers[i]) {\n            result = append(result, numbers[i])\n\
    \        }\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n    \
    \    return numbers\n    }\n\n    result := make([]int, 0, len(numbers))\n   \
    \ // number -> index\n    index := make(map[int]int)\n    for i, n := range numbers\
    \ {\n        // if number is not in result\n        if _, ok := index[n]; !ok\
    \ {\n            result = append(result, n)\n            index[n] = i\n      \
    \  }\n    }\n    return result\n}\n", "    duplicates := make(map[int]bool)\n\
    \    var result []int\n    for _, num := range numbers {\n        if duplicates[num]\
    \ {\n            continue\n        }\n        duplicates[num] = true\n       \
    \ result = append(result, num)\n    }\n    return result\n}\n", "    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n\n    var res []int\n    res = append(res,\
    \ numbers[0])\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ != numbers[i-1] {\n            res = append(res, numbers[i])\n        }\n  \
    \  }\n    return res\n}\n", "    var dict = make(map[int]int)\n    var result\
    \ []int\n    for _, x := range numbers {\n        dict[x]++\n    }\n    for _,\
    \ x := range numbers {\n        if dict[x] == 1 {\n            result = append(result,\
    \ x)\n        }\n    }\n    return result\n}\n", "    output := []int{}\n    for\
    \ i := 0; i < len(numbers); i++ {\n        for j := 0; j < len(output); j++ {\n\
    \            if numbers[i] == output[j] {\n                break\n           \
    \ }\n            if j == len(output) - 1 {\n                output = append(output,\
    \ numbers[i])\n            }\n        }\n        if len(output) == 0 {\n     \
    \       output = append(output, numbers[i])\n        }\n    }\n    return output\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
