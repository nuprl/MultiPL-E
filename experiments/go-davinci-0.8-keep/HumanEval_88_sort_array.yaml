name: HumanEval_88_sort_array
language: go_test.go
prompt: "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given an array of non-negative integers, return a copy of the given array after\
  \ sorting,\n// you will sort the given array in ascending order if the sum( first\
  \ index value, last index value) is odd,\n// or sort it in descending order if the\
  \ sum( first index value, last index value) is even.\n// Note:\n// * don't change\
  \ the given array.\n// Examples:\n// * sort_array([]) => []\n// * sort_array([5])\
  \ => [5]\n// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * sort_array([2,\
  \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\nfunc sort_array(array []int) []int\
  \ {\n"
tests: "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
  \ candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2,\
  \ 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2,\
  \ 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2,\
  \ 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32,\
  \ 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21,\
  \ 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    fmt.Println(array)\n    if len(array) == 0 {\n        return array\n\
    \    }\n    isAscending := array[0] + array[len(array) - 1] % 2 == 0\n    for\
    \ i := 0; i < len(array) - 1; i++ {\n        for j := 0; j < len(array) - 1 -\
    \ i; j++ {\n            if isAscending {\n                if array[j] > array[j\
    \ + 1] {\n                    array[j], array[j + 1] = array[j + 1], array[j]\n\
    \                }\n            } else {\n                if array[j] < array[j\
    \ + 1] {\n                    array[j], array[j + 1] = array[j + 1], array[j]\n\
    \                }\n            }\n        }\n    }\n    return array\n}\n", " \
    \   if len(array) == 0 {\n        return array\n    }\n\n    if len(array) ==\
    \ 1 {\n        return array\n    }\n\n    sum := array[0] + array[len(array) -\
    \ 1]\n    sort(array, 0, len(array) - 1, sum % 2 == 0)\n    return array\n}\n",
  "    total := len(array)\n    if total < 2 {\n        return array\n    }\n    var\
    \ result = make([]int, total)\n    copy(result, array)\n    for i := 0; i < total;\
    \ i++ {\n        for j := i + 1; j < total; j++ {\n            if (i + j) % 2\
    \ == 0 {\n                if result[i] < result[j] {\n                    result[i],\
    \ result[j] = result[j], result[i]\n                }\n            } else {\n\
    \                if result[i] > result[j] {\n                    result[i], result[j]\
    \ = result[j], result[i]\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n", "    var sort func(array []int, isOdd bool)\n    sort\
    \ = func(array []int, isOdd bool) {\n        length := len(array)\n        if\
    \ length <= 1 {\n            return\n        }\n        left := array[0:length/2]\n\
    \        right := array[length/2:]\n        sort(left, !isOdd)\n        sort(right,\
    \ !isOdd)\n        var i, j, k int\n        temp := make([]int, length)\n    \
    \    for i < len(left) && j < len(right) {\n            if left[i] < right[j]\
    \ {\n                temp[k] = left[i]\n                i++\n            } else\
    \ {\n                temp[k] = right[j]\n                j++\n            }\n\
    \            k++\n        }\n        for i < len(left) {\n            temp[k]\
    \ = left[i]\n            i++\n            k++\n        }\n        for j < len(right)\
    \ {\n            temp[k] = right[j]\n            j++\n            k++\n      \
    \  }\n        for i = 0; i < length; i++ {\n            array[i] = temp[i]\n \
    \       }\n        if isOdd {\n            for i = 0; i < length/2; i++ {\n  \
    \              array[i], array[length-1-i] = array[length-1-i], array[i]\n   \
    \         }\n        }\n    }\n    sort(array, len(array) > 0 && (array[0]+array[len(array)-1])%2\
    \ == 1)\n    return array\n}\n", "    if len(array) == 0 {\n        return array\n\
    \    }\n    result := make([]int, len(array))\n    copy(result, array)\n    //\
    \ select the sorting strategy\n    sortFunc := func(i, j int) bool {\n       \
    \ return i < j\n    }\n    if (array[0] + array[len(array) - 1]) % 2 == 0 {\n\
    \        sortFunc = func(i, j int) bool {\n            return i > j\n        }\n\
    \    }\n    // sort\n    for i := 0; i < len(result); i++ {\n        for j :=\
    \ i + 1; j < len(result); j++ {\n            if sortFunc(result[i], result[j])\
    \ {\n                result[i], result[j] = result[j], result[i]\n           \
    \ }\n        }\n    }\n    return result\n}\n", "    i := len(array)\n    if i\
    \ < 2 {\n        return array\n    }\n    if (array[0] + array[i-1]) % 2 == 0\
    \ {\n        for j := 0; j < i/2; j++ {\n            array[j], array[i-1-j] =\
    \ array[i-1-j], array[j]\n        }\n    }\n    return array\n}\n\ntype testCase ",
  "    // your solution here\n    return array\n}\n", "    // Write your code here...\n\
    \    return []int{}\n}\n", "    return sortArrayWithOddEven(array)\n}\n", "  \
    \  if len(array) < 2 {\n        return array\n    }\n    var result []int\n  \
    \  if (array[0] + array[len(array) - 1]) % 2 == 0 {\n        for i := len(array)\
    \ - 1; i >= 0; i-- {\n            result = append(result, array[i])\n        }\n\
    \    } else {\n        for i := 0; i < len(array); i++ {\n            result =\
    \ append(result, array[i])\n        }\n    }\n    return result\n}\n", "    if\
    \ (len(array) == 0) {\n        return array\n    }\n    if (array[0] > array[len(array)\
    \ - 1]) {\n        array[0], array[len(array) - 1] = array[len(array) - 1], array[0]\n\
    \    }\n    fmt.Println(array)\n    if (array[0] % 2 == 0) {\n        // even\
    \ number, sort array in descending order\n        quick_sort(array, 0, len(array)\
    \ - 1)\n    } else {\n        // odd number, sort array in ascending order\n \
    \       quick_sort_2(array, 0, len(array) - 1)\n    }\n    return array\n}\n",
  "    if len(array) <= 1 {\n        return array\n    }\n    if array[0] + array[len(array)\
    \ - 1] % 2 == 0 {\n        // descending\n        for i := 0; i < len(array) -\
    \ 1; i++ {\n            for j := i + 1; j < len(array); j++ {\n              \
    \  if array[i] < array[j] {\n                    tmp := array[i]\n           \
    \         array[i] = array[j]\n                    array[j] = tmp\n          \
    \      }\n            }\n        }\n    } else {\n        // ascending\n     \
    \   for i := 0; i < len(array) - 1; i++ {\n            for j := i + 1; j < len(array);\
    \ j++ {\n                if array[i] > array[j] {\n                    tmp :=\
    \ array[i]\n                    array[i] = array[j]\n                    array[j]\
    \ = tmp\n                }\n            }\n        }\n    }\n    return array\n\
    }\n", "    if len(array) <= 1 {\n        return array\n    }\n    // start index's\
    \ value + end index's value to determine which sort algorithm to use.\n    if\
    \ array[0] + array[len(array) - 1] % 2 == 0 {\n        return merge_sort(array)\n\
    \    } else {\n        return quick_sort(array)\n    }\n}\n", "    fmt.Println(array)\n\
    \    fmt.Println(len(array))\n    if len(array) == 0 {\n        return array\n\
    \    }\n    if len(array) == 1 {\n        return array\n    }\n    var newArray\
    \ []int = make([]int, len(array))\n    copy(newArray, array)\n    fmt.Println(newArray)\n\
    \    if (newArray[0] + newArray[len(newArray) - 1]) % 2 == 0 {\n        for i\
    \ := 0; i < len(newArray) / 2; i++ {\n            newArray[i], newArray[len(newArray)\
    \ - 1 - i] = newArray[len(newArray) - 1 - i], newArray[i]\n        }\n    } else\
    \ {\n        for i := 0; i < len(newArray) - 1; i++ {\n            for j := 0;\
    \ j < len(newArray) - 1 - i; j++ {\n                if newArray[j] > newArray[j\
    \ + 1] {\n                    newArray[j], newArray[j + 1] = newArray[j + 1],\
    \ newArray[j]\n                }\n            }\n        }\n    }\n    return\
    \ newArray\n}\n", "    if array == nil || len(array) == 0 {\n        return array\n\
    \    }\n    if len(array) == 1 {\n        return array\n    }\n    var sum int\n\
    \    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    if\
    \ sum % 2 == 0 {\n        return QuickSortDescending(array)\n    } else {\n  \
    \      return QuickSortAscending(array)\n    }\n}\n", "    var sum int\n    for\
    \ i, v := range array {\n        sum += v\n        if i == len(array) - 1 {\n\
    \            break\n        }\n    }\n    if sum % 2 == 0 {\n        for i :=\
    \ 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i],\
    \ array[i]\n        }\n    }\n    return array\n}\n", "    // a[0] + a[len(a)-1]\
    \ % 2 == 0\n    // a[0] + a[len(a)-1] % 2 == 1\n    if len(array) <= 1 {\n   \
    \     return array\n    }\n    //fmt.Println(array)\n    if (array[0] + array[len(array)-1])\
    \ % 2 == 0 {\n        fmt.Println(\"even\")\n        for i:=0; i<len(array)-1;\
    \ i++ {\n            for j:=i+1; j<len(array); j++ {\n                if array[i]\
    \ < array[j] {\n                    array[i], array[j] = array[j], array[i]\n\
    \                }\n            }\n        }\n    } else {\n        fmt.Println(\"\
    odd\")\n        for i:=0; i<len(array)-1; i++ {\n            for j:=i+1; j<len(array);\
    \ j++ {\n                if array[i] > array[j] {\n                    array[i],\
    \ array[j] = array[j], array[i]\n                }\n            }\n        }\n\
    \    }\n    return array\n}\n", "    switch len(array) {\n    case 0:\n      \
    \  return array\n    case 1:\n        return array\n    }\n    var new_array []int\n\
    \    if (array[0] + array[len(array) - 1]) % 2 == 0 {\n        for i := 0; i <\
    \ len(array); i++ {\n            min := array[0]\n            min_index := 0\n\
    \            for j := 0; j < len(array); j++ {\n                if array[j] >\
    \ min {\n                    min = array[j]\n                    min_index = j\n\
    \                }\n            }\n            new_array = append(new_array, min)\n\
    \            array = append(array[:min_index], array[min_index + 1:]...)\n   \
    \     }\n    } else {\n        for i := 0; i < len(array); i++ {\n           \
    \ max := array[0]\n            max_index := 0\n            for j := 0; j < len(array);\
    \ j++ {\n                if array[j] > max {\n                    max = array[j]\n\
    \                    max_index = j\n                }\n            }\n       \
    \     new_array = append(new_array, max)\n            array = append(array[:max_index],\
    \ array[max_index + 1:]...)\n        }\n    }\n    return new_array\n}\n", " \
    \   output := make([]int, len(array))\n    copy(output, array)\n    if len(output)\
    \ > 1 {\n        if (output[0] + output[len(output) - 1]) % 2 == 0 {\n       \
    \     quicksort(output, 0, len(output) - 1, true)\n        } else {\n        \
    \    quicksort(output, 0, len(output) - 1, false)\n        }\n    }\n    return\
    \ output\n}\n", "    var s []int\n    for _, n := range array {\n        s = append(s,\
    \ n)\n    }\n    if len(s) == 0 {\n        return s\n    }\n    if len(s) == 1\
    \ {\n        return s\n    }\n    if (s[0] + s[len(s) - 1]) % 2 == 0 {\n     \
    \   i := 0\n        j := len(s) - 1\n        for i < j {\n            if (s[i]\
    \ + s[len(s) - 1]) % 2 == 0 {\n                i++\n            } else {\n   \
    \             if (s[j] + s[len(s) - 1]) % 2 == 0 {\n                    s[i],\
    \ s[j] = s[j], s[i]\n                    i++\n                    j--\n      \
    \          } else {\n                    j--\n                }\n            }\n\
    \        }\n        merge(s, 0, i - 1)\n        merge(s, i, len(s) - 1)\n    }\
    \ else {\n        merge(s, 0, len(s) - 1)\n    }\n    return s\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
