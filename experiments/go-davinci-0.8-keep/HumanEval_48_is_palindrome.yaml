name: HumanEval_48_is_palindrome
language: go_test.go
prompt: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
  // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n//\
  \ >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n"
tests: "func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual:\
  \ candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected:\
  \ true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual:\
  \ candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"),\
  \ expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(text) == 0 {\n        return true\n    }\n    return text[0]\
    \ == text[len(text)-1] && is_palindrome(text[1:len(text)-1])\n}\n", "    text_len\
    \ := len(text)\n    mid := text_len / 2\n    for i := 0; i < mid; i++ {\n    \
    \    j := text_len - i - 1\n        if text[i] != text[j] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    text_length := len(text)\n\
    \    is_palindrome := true\n    for i := 0; i < text_length/2; i++ {\n       \
    \ if text[i] != text[text_length-i-1] {\n            is_palindrome = false\n \
    \           break\n        }\n    }\n    return is_palindrome\n}\n", "    length\
    \ := len(text)\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    for\
    \ i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i -\
    \ 1] {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   text_reverse := reverse(text)\n    return is_same(text, text_reverse)\n}\n",
  "    // Just to exercise with slice\n    runes := []rune(text)\n    j := len(runes)\
    \ - 1\n    for i := 0; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] =\
    \ runes[j], runes[i]\n    }\n    return text == string(runes)\n}\n", "    // Strings\
    \ in Go are immutable, this makes this logic a bit more\n    // complicated than\
    \ it would be in other languages.  We can get around\n    // this by using byte\
    \ arrays instead of strings, which *are* mutable.\n    data := []byte(text)\n\n\
    \    // We can use range over the byte array to iterate over the bytes\n    //\
    \ in the string.  The first item returned is the index, the second\n    // is\
    \ the actual value.  We don't care about the index, so we'll\n    // throw it\
    \ away using _\n    for i, _ := range data {\n        // We find the index of\
    \ the end of the string by subtracting\n        // i from the length of the data.\
    \  We then compare the values\n        // at those two indexes.  If they are not\
    \ equal, the string\n        // is not a palindrome and we can return immediately.\n\
    \        if data[i] != data[len(data) - i - 1] {\n            return false\n \
    \       }\n    }\n\n    // If we get here, the string must be a palindrome\n \
    \   return true\n}\n", "    if len(text) <= 1 {\n        return true\n    }\n\
    \    if text[0] != text[len(text)-1] {\n        return false\n    }\n    return\
    \ is_palindrome(text[1:len(text)-1])\n}\n", "    return false\n}\n", "    if len(text)\
    \ == 0 {\n        return true\n    }\n    if len(text) == 1 {\n        return\
    \ true\n    }\n    if len(text) == 2 {\n        return text[0] == text[1]\n  \
    \  }\n    return text[0] == text[len(text)-1] && is_palindrome(text[1:len(text)-1])\n\
    }\n", "    len := len(text)\n    if len == 0 {\n        return true\n    }\n \
    \   else if len == 1 {\n        return true\n    }\n    else {\n        first\
    \ := text[0]\n        last := text[len - 1]\n        if first == last {\n    \
    \        return is_palindrome(text[1:len - 1])\n        }\n        else {\n  \
    \          return false\n        }\n    }\n}\n", "    lower := []rune(text)\n\
    \    length := len(lower)\n\n    for i := 0; i < length / 2; i++ {\n        if\
    \ lower[i] != lower[length - i - 1] {\n            return false\n        }\n \
    \   }\n\n    return true\n}\n", "    if len(text) == 0 {\n        return true\n\
    \    }\n    if len(text) % 2 == 0 {\n        mid := len(text) / 2\n        return\
    \ text[:mid] == Reverse(text[mid:])\n    } else {\n        mid := len(text) /\
    \ 2\n        return text[:mid] == Reverse(text[mid+1:])\n    }\n}\n", "\tvar palindrome\
    \ = true\n\tfor i := 0; i < len(text) / 2; i++ {\n\t\tif text[i] != text[len(text)\
    \ - 1 - i] {\n\t\t\tpalindrome = false\n\t\t\tbreak\n\t\t}\n\t}\n\treturn palindrome\n\
    }\n", "    // Your code here\n    return false\n}\n", "    if len(text) <= 1 {\n\
    \        return true\n    }\n    if text[0] != text[len(text)-1] {\n        return\
    \ false\n    }\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    // The\
    \ len() function returns the number of bytes in a string\n    return text == reverse(text)\n\
    }\n", "    if len(text) <= 1 {\n        return true\n    }\n    if text[0] !=\
    \ text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    text_len := len(text)\n    if text_len == 0 {\n        return true\n\
    \    }\n    for i := 0; i < text_len / 2; i++ {\n        if text[i] != text[text_len\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
