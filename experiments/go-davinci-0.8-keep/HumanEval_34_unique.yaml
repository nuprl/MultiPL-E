name: HumanEval_34_unique
language: go_test.go
prompt: "package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ sorted unique elements in a list\n// >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
  // [0, 2, 3, 5, 9, 123]\nfunc unique(l []int) []int {\n"
tests: "func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0,\
  \ 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // Insertion-sort algorithm\n    for i := 1; i < len(l); i++ {\n\
    \        for j := i; j > 0 && l[j-1] > l[j]; j-- {\n            l[j-1], l[j] =\
    \ l[j], l[j-1]\n        }\n    }\n\n    // Remove duplicates by swapping and truncating\n\
    \    for i := 0; i < len(l); i++ {\n        for j := i + 1; j < len(l); j++ {\n\
    \            if l[i] == l[j] {\n                l[j], l[len(l)-1] = l[len(l)-1],\
    \ l[j]\n                l = l[:len(l)-1]\n                j--\n            }\n\
    \        }\n    }\n\n    return l\n}\n", "    if len(l) == 0 {\n        return\
    \ []int{}\n    }\n    var ret []int\n    for _, v := range l {\n        if len(ret)\
    \ == 0 {\n            ret = append(ret, v)\n        } else {\n            if v\
    \ != ret[len(ret)-1] {\n                ret = append(ret, v)\n            }\n\
    \        }\n    }\n    return ret\n}\n", "    var u []int\n    var s = make(map[int]bool)\n\
    \    for _, v := range l {\n        if _, ok := s[v]; !ok {\n            s[v]\
    \ = true\n            u = append(u, v)\n        }\n    }\n    return u\n}\n",
  "    // make a dict to store the number of occurrences\n    occurrences := make(map[int]int)\n\
    \    for _, v := range l {\n        if _, ok := occurrences[v]; ok {\n       \
    \     occurrences[v]++\n        } else {\n            occurrences[v] = 1\n   \
    \     }\n    }\n\n    // iterate through the dict, keeping only keys that were\
    \ found once\n    var uniques []int\n    for k, v := range occurrences {\n   \
    \     if v == 1 {\n            uniques = append(uniques, k)\n        }\n    }\n\
    \n    return uniques\n}\n", "    var res []int\n    var seen = make(map[int]bool)\n\
    \    for _, v := range l {\n        if !seen[v] {\n            res = append(res,\
    \ v)\n            seen[v] = true\n        }\n    }\n    return res\n}\n", "  \
    \  // result slice\n    var res []int\n    // store the already exist values\n\
    \    m := make(map[int]bool)\n    for _, v := range l {\n        if !m[v] {\n\
    \            m[v] = true\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var sorted []int\n    var last int\n\n    for i, v\
    \ := range l {\n        if i == 0 {\n            sorted = append(sorted, v)\n\
    \            last = v\n            continue\n        }\n\n        if v == last\
    \ {\n            continue\n        }\n\n        sorted = append(sorted, v)\n \
    \       last = v\n    }\n\n    return sorted\n}\n", "    nl := make([]int, 0)\n\
    \    for _, e := range l {\n        for _, e2 := range nl {\n            if e\
    \ == e2 {\n                break\n            }\n        }\n        nl = append(nl,\
    \ e)\n    }\n    return nl\n}\n", "    var result []int\n    for _, e := range\
    \ l {\n        if !contains(result, e) {\n            result = append(result,\
    \ e)\n        }\n    }\n    return result\n}\n", "    // TODO: implement me\n\
    \    return nil\n}\n", "    result := []int{}\n    for _, e := range l {\n   \
    \     if len(result) == 0 {\n            result = append(result, e)\n        }\
    \ else {\n            for i, v := range result {\n                if e < v {\n\
    \                    result = append(result, 0)\n                    copy(result[i+1:],\
    \ result[i:])\n                    result[i] = e\n                    break\n\
    \                } else if e == v {\n                    break\n             \
    \   } else if i == len(result)-1 {\n                    result = append(result,\
    \ e)\n                    break\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n", "    h := make(map[int]bool)\n    r := make([]int,\
    \ 0)\n    for _, e := range l {\n        if _, ok := h[e]; !ok {\n           \
    \ h[e] = true\n            r = append(r, e)\n        }\n    }\n    return r\n\
    }\n", "    m := make(map[int]bool)\n    for _, i := range l {\n        m[i] =\
    \ true\n    }\n    var res []int\n    for k := range m {\n        res = append(res,\
    \ k)\n    }\n    return res\n}\n", "    var list = make([]int, 0)\n    for _,\
    \ value := range l {\n        var unique = true\n        for _, v := range list\
    \ {\n            if v == value {\n                unique = false\n           \
    \     break\n            }\n        }\n        if unique {\n            list =\
    \ append(list, value)\n        }\n    }\n    return list\n}\n", "    seen := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for _, x := range l {\n        if !seen[x]\
    \ {\n            seen[x] = true\n            result = append(result, x)\n    \
    \    }\n    }\n    return result\n}\n", "    uniqueMap := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for _, e := range l {\n        if !uniqueMap[e]\
    \ {\n            uniqueMap[e] = true\n            result = append(result, e)\n\
    \        }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n   \
    \ u := make([]int, 0)\n    for _, n := range l {\n        if !m[n] {\n       \
    \     m[n] = true\n            u = append(u, n)\n        }\n    }\n    return\
    \ u\n}\n", "    var s []int\n    for _, v := range l {\n        if !contains(s,\
    \ v) {\n            s = append(s, v)\n        }\n    }\n    return s\n}\n", " \
    \   fmt.Println(\"\\nInitial list:\", l)\n    set := make(map[int]", "    u :=\
    \ make([]int, 0, len(l))\n    m := make(map[int]bool)\n\n    for _, val := range\
    \ l {\n        if _, ok := m[val]; !ok {\n            m[val] = true\n        \
    \    u = append(u, val)\n        }\n    }\n\n    return u\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
