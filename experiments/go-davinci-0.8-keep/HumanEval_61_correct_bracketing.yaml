name: HumanEval_61_correct_bracketing
language: go_test.go
prompt: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"\
  (()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nfunc correct_bracketing(brackets\
  \ string) bool {\n"
tests: "func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n    \
  \ { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
  ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
  ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n\
  \     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
  (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n\
  \     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
  (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
  \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // Write your code here\n    var stack []byte\n    for _, b :=\
    \ range brackets {\n        if b == '(' {\n            stack = append(stack, byte(b))\n\
    \        } else {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n", "    var stack []rune\n    for _, bracket :=\
    \ range brackets {\n        if bracket == '(' {\n            stack = append(stack,\
    \ bracket)\n        } else if bracket == ')' {\n            if len(stack) == 0\
    \ {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    return len(stack) == 0\n}\n", "    counter := 0\n    for\
    \ _, bracket := range brackets {\n        if bracket == '(' {\n            counter\
    \ += 1\n        } else if bracket == ')' {\n            counter -= 1\n       \
    \ }\n        if counter < 0 {\n            return false\n        }\n    }\n  \
    \  return counter == 0\n}\n", "    // Unopened means the number of opening brackets\
    \ that were not closed yet.\n    unopened := 0\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            unopened += 1\n        } else if c ==\
    \ ')' {\n            if unopened == 0 {\n                return false\n      \
    \      }\n            unopened -= 1\n        }\n    }\n    return unopened ==\
    \ 0\n}\n", "    var open bool\n    for _, b := range brackets {\n        if b\
    \ == '(' {\n            open = true\n        } else if b == ')' {\n          \
    \  if !open {\n                return false\n            }\n            open =\
    \ false\n        }\n    }\n    return open == false\n}\n", "    balance := 0\n\
    \    for _, ch := range brackets {\n        switch ch {\n        case '(':\n \
    \           balance += 1\n        case ')':\n            balance -= 1\n      \
    \  }\n        if balance < 0 {\n            return false\n        }\n    }\n \
    \   return balance == 0\n}\n", "    if len(brackets) % 2 != 0 {\n        return\
    \ false\n    }\n    lbracket := \"(\"\n    rbracket := \")\"\n    open_brackets\
    \ := 0\n    for _, c := range brackets {\n        c := string(c)\n        if c\
    \ == lbracket {\n            open_brackets += 1\n        } else if c == rbracket\
    \ {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n\
    \            return false\n        }\n    }\n    return open_brackets == 0\n}\n",
  "    var numOpen int\n    for _, char := range brackets {\n        if char == '('\
    \ {\n            numOpen++\n        } else if char == ')' {\n            numOpen--\n\
    \        }\n        if numOpen < 0 {\n            return false\n        }\n  \
    \  }\n    return numOpen == 0\n}\n", "    s := make([]rune, 0)\n    for _, r :=\
    \ range brackets {\n        if r == '(' {\n            s = append(s, r)\n    \
    \    } else if r == ')' {\n            if len(s) == 0 {\n                return\
    \ false\n            }\n            s = s[:len(s)-1]\n        }\n    }\n    return\
    \ len(s) == 0\n}\n", "    var stack []rune\n    var bracket rune\n    for _, r\
    \ := range brackets {\n        if r == '(' {\n            stack = append(stack,\
    \ r)\n        } else {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            bracket, stack = stack[len(stack)-1], stack[:len(stack)-1]\n\
    \            if bracket != '(' {\n                return false\n            }\n\
    \        }\n    }\n    return len(stack) == 0\n}\n", "    return false\n}\n",
  "    // TODO\n    return false\n}\n", "    bracketCount := 0\n    for _, bracket\
    \ := range brackets {\n        if bracket == '(' {\n            bracketCount++\n\
    \        } else if bracket == ')' {\n            bracketCount--\n        }\n \
    \       if bracketCount < 0 {\n            return false\n        }\n    }\n  \
    \  return bracketCount == 0\n}\n", "    seen := 0\n    for _, bracket := range\
    \ brackets {\n        switch string(bracket) {\n        case \"(\":\n        \
    \    seen++\n        case \")\":\n            seen--\n        }\n        if seen\
    \ < 0 {\n            return false\n        }\n    }\n    return seen == 0\n}\n",
  "    c := 0\n    for _, b := range brackets {\n        if b == '(' {\n         \
    \   c++\n        } else {\n            c--\n        }\n        if c < 0 {\n  \
    \          return false\n        }\n    }\n    return c == 0\n}\n", "    l :=\
    \ 0\n    r := 0\n    for _, c := range brackets {\n        if c == '(' {\n   \
    \         l++\n        } else {\n            r++\n        }\n        if r > l\
    \ {\n            return false\n        }\n    }\n    return l == r\n}\n", "  \
    \  var s []string\n    for _, r := range brackets {\n        str := string(r)\n\
    \        if str == \"(\" {\n            s = append(s, str)\n        } else if\
    \ str == \")\" {\n            if len(s) == 0 {\n                return false\n\
    \            }\n            s = s[:len(s)-1]\n        }\n    }\n    return len(s)\
    \ == 0\n}\n", "    var remainder string\n    remainder = \"\"\n    for i := 0;\
    \ i < len(brackets); i++ {\n        switch {\n        case brackets[i] == '(':\n\
    \            remainder += brackets[i:]\n            break\n        case brackets[i]\
    \ == ')':\n            if len(remainder) < 1 {\n                return false\n\
    \            }\n            remainder = remainder[:len(remainder)-1]\n       \
    \     break\n        }\n    }\n    return remainder == \"\"\n}\n", "    // TODO:\
    \ implement correct_bracketing\n    return false\n}\n", "    return false\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
