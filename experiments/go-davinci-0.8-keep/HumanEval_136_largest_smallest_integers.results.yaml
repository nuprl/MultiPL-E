language: go_test.go
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    positives := []int{}\n    negatives := []int{}\n    for _, v := range lst\
    \ {\n        if v > 0 {\n            positives = append(positives, v)\n      \
    \  } else if v < 0 {\n            negatives = append(negatives, v)\n        }\n\
    \    }\n    if len(positives) == 0 {\n        positives = append(positives, 0)\n\
    \    }\n    if len(negatives) == 0 {\n        negatives = append(negatives, 0)\n\
    \    }\n    return []interface{}{min(negatives), min(positives)}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0mr817zr_test.go:32:26: undefined: min

    /tmp/tmp0mr817zr_test.go:42:76: undefined: None

    /tmp/tmp0mr817zr_test.go:43:79: undefined: None

    /tmp/tmp0mr817zr_test.go:47:60: undefined: None

    /tmp/tmp0mr817zr_test.go:48:61: undefined: None

    /tmp/tmp0mr817zr_test.go:49:78: undefined: None

    /tmp/tmp0mr817zr_test.go:50:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    smallest_pos := 0\n    largest_neg := 0\n    for _, val := range lst {\n\
    \        if val > 0 {\n            if smallest_pos == 0 {\n                smallest_pos\
    \ = val\n            } else if val < smallest_pos {\n                smallest_pos\
    \ = val\n            }\n        } else if val < 0 {\n            if largest_neg\
    \ == 0 {\n                largest_neg = val\n            } else if val > largest_neg\
    \ {\n                largest_neg = val\n            }\n        }\n    }\n    if\
    \ smallest_pos == 0 {\n        smallest_pos = nil\n    }\n    if largest_neg ==\
    \ 0 {\n        largest_neg = nil\n    }\n    return []interface{}{largest_neg,\
    \ smallest_pos}\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate\
    \ := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdxgx2wew_test.go:35:24: cannot use nil as int value in assignment

    /tmp/tmpdxgx2wew_test.go:38:23: cannot use nil as int value in assignment

    /tmp/tmpdxgx2wew_test.go:50:76: undefined: None

    /tmp/tmpdxgx2wew_test.go:51:79: undefined: None

    /tmp/tmpdxgx2wew_test.go:55:60: undefined: None

    /tmp/tmpdxgx2wew_test.go:56:61: undefined: None

    /tmp/tmpdxgx2wew_test.go:57:78: undefined: None

    /tmp/tmpdxgx2wew_test.go:58:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    // return (lst[0], lst[0])\n    var largestNeg, smallestPos int\n    largestNegSet\
    \ := false\n    smallestPosSet := false\n    for _, val := range lst {\n     \
    \   // fmt.Println(val)\n        if val < 0 {\n            if largestNegSet ==\
    \ false {\n                largestNeg = val\n                largestNegSet = true\n\
    \            } else if val > largestNeg {\n                largestNeg = val\n\
    \            }\n        } else if val > 0 {\n            if smallestPosSet ==\
    \ false {\n                smallestPos = val\n                smallestPosSet =\
    \ true\n            } else if val < smallestPos {\n                smallestPos\
    \ = val\n            }\n        }\n    }\n    if largestNegSet == false {\n  \
    \      largestNeg = 0\n    }\n    if smallestPosSet == false {\n        smallestPos\
    \ = 0\n    }\n    return []interface{}{largestNeg, smallestPos}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgt_4gc_f_test.go:55:76: undefined: None

    /tmp/tmpgt_4gc_f_test.go:56:79: undefined: None

    /tmp/tmpgt_4gc_f_test.go:60:60: undefined: None

    /tmp/tmpgt_4gc_f_test.go:61:61: undefined: None

    /tmp/tmpgt_4gc_f_test.go:62:78: undefined: None

    /tmp/tmpgt_4gc_f_test.go:63:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    var\
    \ negatives []int\n    var positives []int\n    for _, v := range lst {\n    \
    \    if v > 0 {\n            positives = append(positives, v)\n        } else\
    \ if v < 0 {\n            negatives = append(negatives, v)\n        }\n    }\n\
    \    var largest_negative interface{}\n    var smallest_positive interface{}\n\
    \    if len(negatives) == 0 {\n        largest_negative = nil\n    } else {\n\
    \        largest_negative = negatives[0]\n        for _, v := range negatives\
    \ {\n            if v > largest_negative.(int) {\n                largest_negative\
    \ = v\n            }\n        }\n    }\n    if len(positives) == 0 {\n       \
    \ smallest_positive = nil\n    } else {\n        smallest_positive = positives[0]\n\
    \        for _, v := range positives {\n            if v < smallest_positive.(int)\
    \ {\n                smallest_positive = v\n            }\n        }\n    }\n\
    \    return []interface{}{largest_negative, smallest_positive}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32fm42ry_test.go:61:76: undefined: None

    /tmp/tmp32fm42ry_test.go:62:79: undefined: None

    /tmp/tmp32fm42ry_test.go:66:60: undefined: None

    /tmp/tmp32fm42ry_test.go:67:61: undefined: None

    /tmp/tmp32fm42ry_test.go:68:78: undefined: None

    /tmp/tmp32fm42ry_test.go:69:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    i := lst[0]\n    j := lst[0]\n    for _, v := range lst {\n        if v >\
    \ i {\n            i = v\n        }\n        if v < j {\n            j = v\n \
    \       }\n    }\n    return []interface{}{i, j}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzcchf8xj_test.go:37:76: undefined: None

    /tmp/tmpzcchf8xj_test.go:38:79: undefined: None

    /tmp/tmpzcchf8xj_test.go:42:60: undefined: None

    /tmp/tmpzcchf8xj_test.go:43:61: undefined: None

    /tmp/tmpzcchf8xj_test.go:44:78: undefined: None

    /tmp/tmpzcchf8xj_test.go:45:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var largest_neg, smallest_pos int\n    negative := false\n    positive :=\
    \ false\n    for _, num := range lst {\n        if num < 0 {\n            negative\
    \ = true\n            if largest_neg == 0 || num > largest_neg {\n           \
    \     largest_neg = num\n            }\n        } else if num > 0 {\n        \
    \    positive = true\n            if smallest_pos == 0 || num < smallest_pos {\n\
    \                smallest_pos = num\n            }\n        }\n    }\n    if !negative\
    \ {\n        largest_neg = 0\n    }\n    if !positive {\n        smallest_pos\
    \ = 0\n    }\n    return []interface{}{largest_neg, smallest_pos}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9nm16nk8_test.go:49:76: undefined: None

    /tmp/tmp9nm16nk8_test.go:50:79: undefined: None

    /tmp/tmp9nm16nk8_test.go:54:60: undefined: None

    /tmp/tmp9nm16nk8_test.go:55:61: undefined: None

    /tmp/tmp9nm16nk8_test.go:56:78: undefined: None

    /tmp/tmp9nm16nk8_test.go:57:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var smallestPositive, largestNegative int\n    for _, v := range lst {\n\
    \        if v > 0 {\n            if smallestPositive == 0 || v < smallestPositive\
    \ {\n                smallestPositive = v\n            }\n        } else if v\
    \ < 0 {\n            if largestNegative == 0 || v > largestNegative {\n      \
    \          largestNegative = v\n            }\n        }\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n\
    \  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n  \
    \   { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv_htnuyl_test.go:39:76: undefined: None

    /tmp/tmpv_htnuyl_test.go:40:79: undefined: None

    /tmp/tmpv_htnuyl_test.go:44:60: undefined: None

    /tmp/tmpv_htnuyl_test.go:45:61: undefined: None

    /tmp/tmpv_htnuyl_test.go:46:78: undefined: None

    /tmp/tmpv_htnuyl_test.go:47:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    max, min := 0, 0\n    pos_only, neg_only := true, true\n    for _, val :=\
    \ range lst {\n        if val > 0 {\n            pos_only = false\n          \
    \  if min == 0 || val < min {\n                min = val\n            }\n    \
    \    } else if val < 0 {\n            neg_only = false\n            if val > max\
    \ {\n                max = val\n            }\n        }\n    }\n    if pos_only\
    \ || neg_only {\n        return []interface{}{nil, nil}\n    }\n    return []interface{}{max,\
    \ min}\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate :=\
    \ largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnhguhsj6_test.go:45:76: undefined: None

    /tmp/tmpnhguhsj6_test.go:46:79: undefined: None

    /tmp/tmpnhguhsj6_test.go:50:60: undefined: None

    /tmp/tmpnhguhsj6_test.go:51:61: undefined: None

    /tmp/tmpnhguhsj6_test.go:52:78: undefined: None

    /tmp/tmpnhguhsj6_test.go:53:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    var\
    \ smallest, largest int\n    smallest = lst[0]\n    largest = lst[0]\n    for\
    \ _, e := range lst {\n        if e < smallest {\n            smallest = e\n \
    \       }\n        if e > largest {\n            largest = e\n        }\n    }\n\
    \    if smallest >= 0 {\n        smallest = 0\n    }\n    if largest <= 0 {\n\
    \        largest = 0\n    }\n    return []interface{}{largest, smallest}\n}\n\n\
    func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
    \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7,\
    \ 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkpnte2gf_test.go:47:76: undefined: None

    /tmp/tmpkpnte2gf_test.go:48:79: undefined: None

    /tmp/tmpkpnte2gf_test.go:52:60: undefined: None

    /tmp/tmpkpnte2gf_test.go:53:61: undefined: None

    /tmp/tmpkpnte2gf_test.go:54:78: undefined: None

    /tmp/tmpkpnte2gf_test.go:55:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    negatives\
    \ := []int{}\n    positives := []int{}\n    for _, item := range lst {\n     \
    \   if item < 0 {\n            negatives = append(negatives, item)\n        }\
    \ else if item > 0 {\n            positives = append(positives, item)\n      \
    \  }\n    }\n    if len(negatives) == 0 {\n        negatives = append(negatives,\
    \ nil)\n    }\n    if len(positives) == 0 {\n        positives = append(positives,\
    \ nil)\n    }\n    return []interface{}{max(negatives), min(positives)}\n}\n\n\
    func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
    \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7,\
    \ 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzib911dc_test.go:30:39: cannot use nil as int value in argument to append

    /tmp/tmpzib911dc_test.go:33:39: cannot use nil as int value in argument to append

    /tmp/tmpzib911dc_test.go:35:26: undefined: max

    /tmp/tmpzib911dc_test.go:35:42: undefined: min

    /tmp/tmpzib911dc_test.go:45:76: undefined: None

    /tmp/tmpzib911dc_test.go:46:79: undefined: None

    /tmp/tmpzib911dc_test.go:50:60: undefined: None

    /tmp/tmpzib911dc_test.go:51:61: undefined: None

    /tmp/tmpzib911dc_test.go:52:78: undefined: None

    /tmp/tmpzib911dc_test.go:53:81: undefined: None

    /tmp/tmpzib911dc_test.go:53:81: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var largest_negative, smallest_positive int\n    var first_smallest_positive_seen,\
    \ first_largest_negative_seen bool\n\n    for _, elem := range lst {\n       \
    \ if elem < 0 {\n            if first_largest_negative_seen {\n              \
    \  if elem > largest_negative {\n                    largest_negative = elem\n\
    \                }\n            } else {\n                largest_negative = elem\n\
    \                first_largest_negative_seen = true\n            }\n        }\
    \ else if elem > 0 {\n            if first_smallest_positive_seen {\n        \
    \        if elem < smallest_positive {\n                    smallest_positive\
    \ = elem\n                }\n            } else {\n                smallest_positive\
    \ = elem\n                first_smallest_positive_seen = true\n            }\n\
    \        }\n    }\n\n    if first_largest_negative_seen {\n        return []interface{}{largest_negative,\
    \ None}\n    } else if first_smallest_positive_seen {\n        return []interface{}{None,\
    \ smallest_positive}\n    } else {\n        return []interface{}{None, None}\n\
    \    }\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate :=\
    \ largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_s_tx8wl_test.go:43:48: undefined: None

    /tmp/tmp_s_tx8wl_test.go:45:30: undefined: None

    /tmp/tmp_s_tx8wl_test.go:47:30: undefined: None

    /tmp/tmp_s_tx8wl_test.go:58:76: undefined: None

    /tmp/tmp_s_tx8wl_test.go:59:79: undefined: None

    /tmp/tmp_s_tx8wl_test.go:63:60: undefined: None

    /tmp/tmp_s_tx8wl_test.go:64:61: undefined: None

    /tmp/tmp_s_tx8wl_test.go:65:78: undefined: None

    /tmp/tmp_s_tx8wl_test.go:66:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    largest, smallest := interface{}(nil), interface{}(nil)\n    for _, val :=\
    \ range lst {\n        if val < 0 {\n            if largest == nil || val > largest\
    \ {\n                largest = val\n            }\n        } else if val > 0 {\n\
    \            if smallest == nil || val < smallest {\n                smallest\
    \ = val\n            }\n        }\n    }\n    return []interface{}{largest, smallest}\n\
    }\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
    \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7,\
    \ 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcwzudswb_test.go:20:40: invalid operation: val > largest (operator > not
    defined on interface)

    /tmp/tmpcwzudswb_test.go:24:41: invalid operation: val < smallest (operator <
    not defined on interface)

    /tmp/tmpcwzudswb_test.go:39:76: undefined: None

    /tmp/tmpcwzudswb_test.go:40:79: undefined: None

    /tmp/tmpcwzudswb_test.go:44:60: undefined: None

    /tmp/tmpcwzudswb_test.go:45:61: undefined: None

    /tmp/tmpcwzudswb_test.go:46:78: undefined: None

    /tmp/tmpcwzudswb_test.go:47:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var smallest, largest int\n    var min_set, max_set bool\n    for _, num\
    \ := range lst {\n        if num < 0 {\n            if !min_set || num > smallest\
    \ {\n                smallest = num\n                min_set = true\n        \
    \    }\n        } else if num > 0 {\n            if !max_set || num < largest\
    \ {\n                largest = num\n                max_set = true\n         \
    \   }\n        }\n    }\n    res := []interface{}{nil, nil}\n    if min_set {\n\
    \        res[0] = smallest\n    }\n    if max_set {\n        res[1] = largest\n\
    \    }\n    return res\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T)\
    \ {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n  \
    \   { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9rj39pgr_test.go:49:76: undefined: None

    /tmp/tmp9rj39pgr_test.go:50:79: undefined: None

    /tmp/tmp9rj39pgr_test.go:54:60: undefined: None

    /tmp/tmp9rj39pgr_test.go:55:61: undefined: None

    /tmp/tmp9rj39pgr_test.go:56:78: undefined: None

    /tmp/tmp9rj39pgr_test.go:57:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var maxNegative, minPositive int = 0, 0\n    var hasMaxNegative, hasMinPositive\
    \ bool = false, false\n    for _, v := range lst {\n        if v > 0 {\n     \
    \       if !hasMinPositive || minPositive > v {\n                minPositive =\
    \ v\n                hasMinPositive = true\n            }\n        } else if v\
    \ < 0 {\n            if !hasMaxNegative || maxNegative < v {\n               \
    \ maxNegative = v\n                hasMaxNegative = true\n            }\n    \
    \    }\n    }\n    if !hasMaxNegative {\n        maxNegative = 0\n    }\n    if\
    \ !hasMinPositive {\n        minPositive = 0\n    }\n    return []interface{}{maxNegative,\
    \ minPositive}\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate\
    \ := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncugyz5l_test.go:48:76: undefined: None

    /tmp/tmpncugyz5l_test.go:49:79: undefined: None

    /tmp/tmpncugyz5l_test.go:53:60: undefined: None

    /tmp/tmpncugyz5l_test.go:54:61: undefined: None

    /tmp/tmpncugyz5l_test.go:55:78: undefined: None

    /tmp/tmpncugyz5l_test.go:56:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var lg int\n    var sm int\n    var b bool\n    for _, n := range lst {\n\
    \        if n < 0 {\n            if !b {\n                lg = n\n           \
    \     b = true\n            } else if n > lg {\n                lg = n\n     \
    \       }\n        } else if n > 0 {\n            if !b {\n                sm\
    \ = n\n                b = true\n            } else if n < sm {\n            \
    \    sm = n\n            }\n        }\n    }\n    if b {\n        return []interface{}{lg,\
    \ sm}\n    }\n    return []interface{}{nil, nil}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx__t6tp0_test.go:50:76: undefined: None

    /tmp/tmpx__t6tp0_test.go:51:79: undefined: None

    /tmp/tmpx__t6tp0_test.go:55:60: undefined: None

    /tmp/tmpx__t6tp0_test.go:56:61: undefined: None

    /tmp/tmpx__t6tp0_test.go:57:78: undefined: None

    /tmp/tmpx__t6tp0_test.go:58:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    largest_neg,\
    \ smallest_pos := 0, 0\n    for _, n := range lst {\n        if n > 0 {\n    \
    \        if smallest_pos == 0 || n < smallest_pos {\n                smallest_pos\
    \ = n\n            }\n        } else if n < 0 {\n            if largest_neg ==\
    \ 0 || n > largest_neg {\n                largest_neg = n\n            }\n   \
    \     }\n    }\n    if largest_neg == 0 {\n        largest_neg = nil\n    }\n\
    \    if smallest_pos == 0 {\n        smallest_pos = nil\n    }\n    return []interface{}{largest_neg,\
    \ smallest_pos}\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate\
    \ := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvmzt84k2_test.go:33:23: cannot use nil as int value in assignment

    /tmp/tmpvmzt84k2_test.go:36:24: cannot use nil as int value in assignment

    /tmp/tmpvmzt84k2_test.go:48:76: undefined: None

    /tmp/tmpvmzt84k2_test.go:49:79: undefined: None

    /tmp/tmpvmzt84k2_test.go:53:60: undefined: None

    /tmp/tmpvmzt84k2_test.go:54:61: undefined: None

    /tmp/tmpvmzt84k2_test.go:55:78: undefined: None

    /tmp/tmpvmzt84k2_test.go:56:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var largest, smallest interface{} = nil, nil\n    for _, e := range lst {\n\
    \        if e < 0 {\n            if largest == nil || e > largest {\n        \
    \        largest = e\n            }\n        } else if e > 0 {\n            if\
    \ smallest == nil || e < smallest {\n                smallest = e\n          \
    \  }\n        }\n    }\n    return []interface{}{largest, smallest}\n}\n\nfunc\
    \ TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
    \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7,\
    \ 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn6nma1z5_test.go:20:38: invalid operation: e > largest (operator > not
    defined on interface)

    /tmp/tmpn6nma1z5_test.go:24:39: invalid operation: e < smallest (operator < not
    defined on interface)

    /tmp/tmpn6nma1z5_test.go:39:76: undefined: None

    /tmp/tmpn6nma1z5_test.go:40:79: undefined: None

    /tmp/tmpn6nma1z5_test.go:44:60: undefined: None

    /tmp/tmpn6nma1z5_test.go:45:61: undefined: None

    /tmp/tmpn6nma1z5_test.go:46:78: undefined: None

    /tmp/tmpn6nma1z5_test.go:47:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var largestNegative int\n    var smallestPositive int\n    var result []interface{}\n\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] > 0 {\n            if\
    \ smallestPositive == 0 {\n                smallestPositive = lst[i]\n       \
    \     } else if lst[i] < smallestPositive {\n                smallestPositive\
    \ = lst[i]\n            }\n        } else if lst[i] < 0 {\n            if largestNegative\
    \ == 0 {\n                largestNegative = lst[i]\n            } else if lst[i]\
    \ > largestNegative {\n                largestNegative = lst[i]\n            }\n\
    \        }\n    }\n\n    if largestNegative == 0 {\n        result = append(result,\
    \ nil)\n    } else {\n        result = append(result, largestNegative)\n    }\n\
    \n    if smallestPositive == 0 {\n        result = append(result, nil)\n    }\
    \ else {\n        result = append(result, smallestPositive)\n    }\n\n    return\
    \ result\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate\
    \ := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4a3_wpr_test.go:59:76: undefined: None

    /tmp/tmpq4a3_wpr_test.go:60:79: undefined: None

    /tmp/tmpq4a3_wpr_test.go:64:60: undefined: None

    /tmp/tmpq4a3_wpr_test.go:65:61: undefined: None

    /tmp/tmpq4a3_wpr_test.go:66:78: undefined: None

    /tmp/tmpq4a3_wpr_test.go:67:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var a, b interface{} = nil, nil\n    var a_found, b_found bool = false, false\n\
    \    for _, i := range lst {\n        if i > 0 {\n            if !b_found {\n\
    \                b = i\n                b_found = true\n            } else if\
    \ i < b.(int) {\n                b = i\n            }\n        } else if i < 0\
    \ {\n            if !a_found {\n                a = i\n                a_found\
    \ = true\n            } else if i > a.(int) {\n                a = i\n       \
    \     }\n        }\n    }\n    return []interface{}{a, b}\n}\n\nfunc TestLargest_Smallest_Integers(t\
    \ *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{None,\
    \ 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2,\
    \ 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7,\
    \ 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9,\
    \ 2} },\n     { actual: candidate([]int{}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{0}), expected: []interface{}{None, None}\
    \ },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1,\
    \ None} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3,\
    \ 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3,\
    \ 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxtj0uy31_test.go:46:76: undefined: None

    /tmp/tmpxtj0uy31_test.go:47:79: undefined: None

    /tmp/tmpxtj0uy31_test.go:51:60: undefined: None

    /tmp/tmpxtj0uy31_test.go:52:61: undefined: None

    /tmp/tmpxtj0uy31_test.go:53:78: undefined: None

    /tmp/tmpxtj0uy31_test.go:54:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a'\
    \ is\n// the largest of negative integers, and 'b' is the smallest\n// of positive\
    \ integers in a list.\n// If there is no negative or positive integers, return\
    \ them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0])\
    \ == (None, None)\nfunc largest_smallest_integers(lst []int) []interface{} {\n\
    \    var smallest, largest int\n    largestSet := false\n    smallestSet := false\n\
    \    for _, n := range lst {\n        if n < 0 {\n            if !largestSet {\n\
    \                largest = n\n                largestSet = true\n            }\
    \ else if n > largest {\n                largest = n\n            }\n        }\
    \ else if n > 0 {\n            if !smallestSet {\n                smallest = n\n\
    \                smallestSet = true\n            } else if n < smallest {\n  \
    \              smallest = n\n            }\n        }\n    }\n    if largestSet\
    \ {\n        if smallestSet {\n            return []interface{}{largest, smallest}\n\
    \        } else {\n            return []interface{}{largest, nil}\n        }\n\
    \    } else {\n        if smallestSet {\n            return []interface{}{nil,\
    \ smallest}\n        } else {\n            return []interface{}{nil, nil}\n  \
    \      }\n    }\n}\n\nfunc TestLargest_Smallest_Integers(t *testing.T) {\n  candidate\
    \ := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{2,\
    \ 4, 1, 3, 5, 7, 0}), expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
    \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
    \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}),\
    \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3,\
    \ -5, -6}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1,\
    \ -3, -5, -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
    \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7z8_mimm_test.go:59:76: undefined: None

    /tmp/tmp7z8_mimm_test.go:60:79: undefined: None

    /tmp/tmp7z8_mimm_test.go:64:60: undefined: None

    /tmp/tmp7z8_mimm_test.go:65:61: undefined: None

    /tmp/tmp7z8_mimm_test.go:66:78: undefined: None

    /tmp/tmp7z8_mimm_test.go:67:81: undefined: None

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
