language: go_test.go
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    o, oo, ooo, oooo := 0, 0,\
    \ 0, 0\n    note := 0\n    for _, c := range music_string {\n        if oooo ==\
    \ 1 {\n            beats = append(beats, 4)\n            oooo = 0\n        }\n\
    \        if ooo == 1 {\n            beats = append(beats, 3)\n            ooo\
    \ = 0\n        }\n        if oo == 1 {\n            beats = append(beats, 2)\n\
    \            oo = 0\n        }\n        if o == 1 {\n            beats = append(beats,\
    \ 1)\n            o = 0\n        }\n        switch c {\n        case 'o':\n  \
    \          if note == 0 {\n                o = 1\n            } else {\n     \
    \           ooo = 1\n            }\n        case '|':\n            note = 1\n\
    \        case '.':\n            note = 0\n        case ' ':\n            ooo =\
    \ 0\n            ooo = 0\n            ooo = 0\n            oooo = 0\n        \
    \    note = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpldvg9v_5_test.go:77: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpldvg9v_5_test.go:77: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpldvg9v_5_test.go:77: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpldvg9v_5_test.go:77: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp2sg7svbh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp2sg7svbh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp2sg7svbh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp2sg7svbh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n\tvar result []int\n\tfor i := 0; i < len(music_string); i++\
    \ {\n\t\tif string(music_string[i]) == \"o\" {\n\t\t\tif i+1 >= len(music_string)\
    \ || string(music_string[i+1]) != \"|\" {\n\t\t\t\tresult = append(result, 4)\n\
    \t\t\t} else {\n\t\t\t\tresult = append(result, 2)\n\t\t\t\ti++\n\t\t\t}\n\t\t\
    } else if string(music_string[i]) == \".\" {\n\t\t\tresult = append(result, 1)\n\
    \t\t\ti++\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code goes here\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp7ec8dsnh_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp7ec8dsnh_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp7ec8dsnh_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp7ec8dsnh_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    // TODO: implement this function!\n    return []int{}\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpf_i1of2v_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpf_i1of2v_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpf_i1of2v_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpf_i1of2v_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    last_number := 0\n    result := make([]int, 0)\n    for\
    \ _, b := range music_string {\n        if string(b) == \"o\" {\n            last_number\
    \ = 4\n        } else if string(b) == \"o\" && string(b) == \"|\" {\n        \
    \    last_number = 2\n        } else if string(b) == \".\" && string(b) == \"\
    |\" {\n            last_number = 1\n        } else {\n            result = append(result,\
    \ last_number)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp6hc3xada_test.go:23:19: suspect and: string(b) == "o" && string(b) ==
    "|"

    /tmp/tmp6hc3xada_test.go:25:19: suspect and: string(b) == "." && string(b) ==
    "|"

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    var duration_int []int\n    s := make([]rune, len(music_string))\n\
    \    var l int\n    l = 0\n    for _, r := range music_string {\n        s[l]\
    \ = r\n        l = l + 1\n    }\n    for i := 0; i < len(s); i++ {\n        if\
    \ s[i] == 'o' && s[i+1] == ' ' && s[i+2] == 'o' {\n            duration_int =\
    \ append(duration_int, 4)\n            i += 2\n        } else if s[i] == 'o' &&\
    \ s[i+1] == '|' {\n            duration_int = append(duration_int, 2)\n      \
    \      i += 1\n        } else if s[i] == '.' && s[i+1] == '|' {\n            duration_int\
    \ = append(duration_int, 1)\n            i += 1\n        }\n    }\n    return\
    \ duration_int\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp7fpmajty_test.go:58: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp7fpmajty_test.go:58: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp7fpmajty_test.go:58: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpa9o8cl_u_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpa9o8cl_u_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpa9o8cl_u_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpa9o8cl_u_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmppzo7fo39_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmppzo7fo39_test.go:40: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmppzo7fo39_test.go:40:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmppzo7fo39_test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    beats := map[string]int{\n        \"o\": 4,\n        \"\
    o|\": 2,\n        \".|\": 1,\n    }\n    notes := make([]int, 0)\n    for i :=\
    \ 0; i < len(music_string); i++ {\n        for j := i; j < len(music_string);\
    \ j++ {\n            not := music_string[i:j+1]\n            _, ok := beats[not]\n\
    \            if ok {\n                notes = append(notes, beats[not])\n    \
    \            i = j\n                break\n            }\n        }\n    }\n \
    \   return notes\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmps9sg35hy_test.go:55: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmps9sg35hy_test.go:55: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpa9o8cl_u_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpa9o8cl_u_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpa9o8cl_u_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpa9o8cl_u_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    // First, let's create a map of characters to corresponding\
    \ beat count:\n    beats := map[rune]int{\n        'o': 4,\n        '|': 2,\n\
    \        '.': 1,\n    }\n    // Make an empty slice to keep track of beats for\
    \ each character:\n    var beats_list []int\n    // Loop through the characters\
    \ in the input string:\n    for _, r := range music_string {\n        beats_list\
    \ = append(beats_list, beats[r])\n    }\n    return beats_list\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmphzf2chms_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmphzf2chms_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0)\
    \ %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmphzf2chms_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=0)\
    \ %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)\
    \ %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmphzf2chms_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    // your code here\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp0uienu10_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp0uienu10_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp0uienu10_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp0uienu10_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    slice_of_notes := make([]int, 0)\n    for i := 0; i < len(music_string);\
    \ i++ {\n        if music_string[i] == 'o' {\n            slice_of_notes = append(slice_of_notes,\
    \ 4)\n        } else if music_string[i] == '.' {\n            slice_of_notes =\
    \ append(slice_of_notes, 1)\n        }\n    }\n    return slice_of_notes\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpw8a1uu5__test.go:46: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpw8a1uu5__test.go:46: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    // This is a stub. Add your implementation here.\n    return\
    \ []int{}\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpbwltj6fq_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpbwltj6fq_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpbwltj6fq_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpbwltj6fq_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    // Code here.\n\n    fmt.Printf(\"Input:%s\\n\", music_string)\n\
    \    beats := []int{}\n    currBeat := 0\n    for _, elem := range music_string\
    \ {\n        if elem == 'o' {\n            beats = append(beats, 4)\n        }\
    \ else if elem == '|' {\n            beats[currBeat] = beats[currBeat] / 2\n \
    \       } else if elem == '.' {\n            currBeat++\n        }\n    }\n  \
    \  return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Input:\nInput:o o o o\nInput:.| .| .| .|\n--- FAIL: TestParse_Music (0.00s)\n\
    panic: runtime error: index out of range [1] with length 0 [recovered]\n\tpanic:\
    \ runtime error: index out of range [1] with length 0\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51f7b2, 0xb})\n\t/tmp/tmp4uco6e5i_test.go:27\
    \ +0x1cc\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp4uco6e5i_test.go:44\
    \ +0xa2\ntesting.tRunner(0xc0000cc4e0, 0x529048)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    if len(music_string) == 0 {\n        return []int{}\n \
    \   }\n    r := []rune(music_string)\n    d := []int{}\n    i := 0\n    for i\
    \ < len(r) {\n        if r[i] == 'o' {\n            if r[i+1] == ' ' {\n     \
    \           d = append(d, 4)\n                i += 2\n            } else if r[i+1]\
    \ == '|' {\n                d = append(d, 2)\n                i += 3\n       \
    \     }\n        } else if r[i] == '.' {\n            d = append(d, 1)\n     \
    \       i += 3\n        }\n    }\n    return d\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7]\
    \ with length 7\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51eb1d?, 0x0?})\n\t/tmp/tmpk7or40fk_test.go:26\
    \ +0x209\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpk7or40fk_test.go:49\
    \ +0x73\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    for _, char := range music_string\
    \ {\n        switch char {\n        case 'o':\n            beats = append(beats,\
    \ 4)\n        case '|':\n            beats = append(beats, 2)\n        case '.':\n\
    \            beats = append(beats, 1)\n        }\n    }\n    return beats\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp8qvaumx8_test.go:49: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp8qvaumx8_test.go:49: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp8qvaumx8_test.go:49: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4)\
    \ %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    for i := 0; i < len(music_string);\
    \ i++ {\n        char := music_string[i]\n        if char == ' ' {\n         \
    \   continue\n        } else if char == 'o' {\n            if i+1 < len(music_string)\
    \ && music_string[i+1] == '|' {\n                beats = append(beats, 2)\n  \
    \              i++\n            } else {\n                beats = append(beats,\
    \ 4)\n            }\n        } else if char == '.' {\n            beats = append(beats,\
    \ 1)\n            i++\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .|\
    \ .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string\
    \ string) []int {\n    var beats_list []int\n    var curr_beat int = 0\n    var\
    \ prev_rune rune = ' '\n    for _, character := range music_string {\n       \
    \ if curr_beat == 0 && prev_rune == ' ' {\n            curr_beat = 4\n       \
    \ } else if character == ' ' {\n            beats_list = append(beats_list, curr_beat)\n\
    \            curr_beat = 0\n        } else if character == '|' {\n           \
    \ curr_beat -= 1\n        }\n        prev_rune = character\n    }\n    return\
    \ beats_list\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpvb8mkt98_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpvb8mkt98_test.go:52: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpvb8mkt98_test.go:52: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpvb8mkt98_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074944
