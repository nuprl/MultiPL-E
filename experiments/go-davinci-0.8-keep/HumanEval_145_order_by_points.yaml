name: HumanEval_145_order_by_points
language: go_test.go
prompt: "package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Write a function which sorts the given list of integers\n// in ascending\
  \ order according to the sum of their digits.\n// Note: if there are several items\
  \ with similar sum of their digits,\n// order them based on their index in original\
  \ list.\n// For example:\n// >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n// >>> order_by_points([]) == []\nfunc order_by_points(nums\
  \ []int) []int {\n"
tests: "func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected:\
  \ []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98,\
  \ 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7,\
  \ 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected:\
  \ []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
  t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return []int{}\n}\n", "    return nil\n}\n", "    return nil\n\
    }\n", "    if len(nums) <= 1 {\n        return nums\n    }\n\n    nums_cp := nums\n\
    \    points := make([]int, len(nums))\n    for i, _ := range nums {\n        points[i]\
    \ = int_sum(nums[i])\n    }\n\n    for i := 0; i < len(nums) - 1; i++ {\n    \
    \    for j := 0; j < len(nums) - 1 - i; j++ {\n            if points[j] > points[j\
    \ + 1] {\n                swap(&points[j], &points[j + 1])\n                swap(&nums_cp[j],\
    \ &nums_cp[j + 1])\n            }\n        }\n    }\n\n    return nums_cp\n}\n",
  "    //your code here\n    return []int{}\n}\n", "    fmt.Println(nums)\n    nums_sum\
    \ := make(map[int]int)\n    for _, num := range nums {\n        nums_sum[num]\
    \ = sum_digits(num)\n    }\n    for i := 0; i < len(nums); i++ {\n        for\
    \ j := i + 1; j < len(nums); j++ {\n            if nums_sum[nums[i]] > nums_sum[nums[j]]\
    \ {\n                nums[i], nums[j] = nums[j], nums[i]\n            }\n    \
    \    }\n    }\n    return nums\n}\n", "    // your code here\n\n    return []int{}\n\
    }\n", "    points := make(map[int]int)\n    for _, n := range nums {\n       \
    \ points[n] = sum_digits(n)\n    }\n    result := make([]int, len(nums))\n   \
    \ for i, n := range nums {\n        for j, p := range points {\n            if\
    \ n == j {\n                result[p] = j\n                break\n           \
    \ }\n        }\n    }\n    return result\n}\n", "    sum := make(map[int]int)\n\
    \    ind := make(map[int]int)\n    for i, n := range nums {\n        sum[n] =\
    \ 0\n        ind[n] = i\n        for n > 0 {\n            sum[n] += n % 10\n \
    \           n /= 10\n        }\n    }\n    b := nums[:0]\n    for i := 0; i <\
    \ len(nums); i++ {\n        m := -1\n        for j := 0; j < len(nums); j++ {\n\
    \            if sum[nums[j]] > 0 && (m == -1 || sum[nums[j]] < sum[nums[m]] ||\
    \ (sum[nums[j]] == sum[nums[m]] && ind[nums[j]] < ind[nums[m]])) {\n         \
    \       m = j\n            }\n        }\n        b = append(b, nums[m])\n    \
    \    sum[nums[m]] = -1\n    }\n    return b\n}\n", "    return nums\n}\n", " \
    \   // your code here\n    return nums\n}\n", "    length := len(nums)\n    if\
    \ length <= 1 {\n        return nums\n    }\n    for i := 0; i < length; i++ {\n\
    \        for j := i + 1; j < length; j++ {\n            if calculate_point(nums[i])\
    \ > calculate_point(nums[j]) {\n                nums[i], nums[j] = nums[j], nums[i]\n\
    \            }\n        }\n    }\n    return nums\n}\n", "    // populate the\
    \ map with nums\n    nums_map := make(map[int][]int)\n    for i, num := range\
    \ nums {\n        point := get_point(num)\n        nums_map[point] = append(nums_map[point],\
    \ num)\n    }\n\n    // sort the map\n    keys := get_sorted_keys(nums_map)\n\n\
    \    // save the nums in order\n    nums_ret := make([]int, len(nums))\n    p\
    \ := 0\n    for _, key := range keys {\n        for _, num := range nums_map[key]\
    \ {\n            nums_ret[p] = num\n            p++\n        }\n    }\n\n    return\
    \ nums_ret\n}\n", "    numsMap := make(map[int][]int)\n    for i, v := range nums\
    \ {\n        tmp := v\n        sum := 0\n        for tmp != 0 {\n            sum\
    \ += tmp % 10\n            tmp /= 10\n        }\n        if _, ok := numsMap[sum];\
    \ !ok {\n            numsMap[sum] = []int{}\n        }\n        numsMap[sum] =\
    \ append(numsMap[sum], i)\n    }\n    res := []int{}\n    for sum, _ := range\
    \ numsMap {\n        for _, idx := range numsMap[sum] {\n            res = append(res,\
    \ nums[idx])\n        }\n    }\n    return res\n}\n", "    if len(nums) == 0 {\n\
    \        return nums\n    }\n    index, new_nums := 0, make([]int, len(nums))\n\
    \    min_value, min_index := findMin(nums)\n    for {\n        new_nums[index]\
    \ = min_value\n        if index == len(nums) - 1 {\n            break\n      \
    \  }\n        index++\n        nums[min_index] = min_value + 1\n        min_value,\
    \ min_index = findMin(nums)\n    }\n    return new_nums\n}\n", "    // Your code\
    \ here\n    return nil\n}\n", "    if len(nums) <= 1 {\n        return nums\n\
    \    }\n\n    num_points := make(map[int]int)\n    for i, num := range nums {\n\
    \        num_points[num] = num_points[num] + int(num % 10)\n        num /= 10\n\
    \        for num > 0 {\n            num_points[num] = num_points[num] + int(num\
    \ % 10)\n            num /= 10\n        }\n        num_points[num] = num_points[num]\
    \ + i\n    }\n\n    new_nums := make([]int, len(nums))\n    i := 0\n    for num,\
    \ _ := range num_points {\n        new_nums[i] = num\n        i++\n    }\n\n \
    \   // bubble sort\n    for i := 0; i < len(new_nums) - 1; i++ {\n        for\
    \ j := 0; j < len(new_nums) - i - 1; j++ {\n            if num_points[new_nums[j]]\
    \ > num_points[new_nums[j + 1]] {\n                temp := new_nums[j]\n     \
    \           new_nums[j] = new_nums[j + 1]\n                new_nums[j + 1] = temp\n\
    \            }\n        }\n    }\n\n    return new_nums\n}\n", "    if len(nums)\
    \ == 0 {\n        return []int{}\n    }\n\n    mp := make(map[int][]int)\n   \
    \ for i, e := range nums {\n        s := sum_digits(e)\n        if _, ok := mp[s];\
    \ !ok {\n            mp[s] = []int{}\n        }\n        mp[s] = append(mp[s],\
    \ i)\n    }\n\n    var keys []int\n    for k := range mp {\n        keys = append(keys,\
    \ k)\n    }\n    sort.Ints(keys)\n\n    var res []int\n    for _, k := range keys\
    \ {\n        for _, v := range mp[k] {\n            res = append(res, nums[v])\n\
    \        }\n    }\n    return res\n}\n", "    // Insert your code here\n    return\
    \ []int{}\n}\n", "    // first, calculate the sum of their digits and store the\
    \ pair\n    // into a map\n    sum_map := make(map[int]int)\n    for i, n := range\
    \ nums {\n        sum_map[n] = i\n    }\n\n    // next, sort the map and return\
    \ the original nums by their value\n    // in the map.\n    var sorted_nums []int\n\
    \    var sorted_sum []int\n    for sum, _ := range sum_map {\n        sorted_sum\
    \ = append(sorted_sum, sum)\n    }\n    for _, sum := range sorted_sum {\n   \
    \     sorted_nums = append(sorted_nums, nums[sum_map[sum]])\n    }\n    return\
    \ sorted_nums\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
