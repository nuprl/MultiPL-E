language: go_test.go
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n       \
    \ 4: \"iv\",\n        5: \"v\",\n        9: \"ix\",\n        10: \"x\",\n    \
    \    40: \"xl\",\n        50: \"l\",\n        90: \"xc\",\n        100: \"c\"\
    ,\n        400: \"cd\",\n        500: \"d\",\n        900: \"cm\",\n        1000:\
    \ \"m\",\n    }\n    number_as_string := \"\"\n    for key := 1000; key > 0; key\
    \ = key / 10 {\n        if number / key > 0 {\n            if number / key ==\
    \ 4 {\n                number_as_string += roman_numerals[key] + roman_numerals[5\
    \ * key]\n            } else if number / key == 9 {\n                number_as_string\
    \ += roman_numerals[key] + roman_numerals[10 * key]\n            } else {\n  \
    \              if number / key > 5 {\n                    number_as_string +=\
    \ roman_numerals[5 * key]\n                }\n                for i := 0; i <\
    \ number / key % 5; i++ {\n                    number_as_string += roman_numerals[key]\n\
    \                }\n            }\n            number = number % key\n       \
    \ }\n    }\n    return number_as_string\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1\
    \ (0.00s)\n        tmptll2gzn5_test.go:78: expected 'clii', got 'cii'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmptll2gzn5_test.go:78:\
    \ expected 'ccli', got 'cci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmptll2gzn5_test.go:78: expected 'd', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmptll2gzn5_test.go:78:\
    \ expected 'dxxxii', got 'xxxii'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    // Code here\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpj9t6bnh6_test.go:46: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpj9t6bnh6_test.go:46: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpj9t6bnh6_test.go:46: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpj9t6bnh6_test.go:46: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpj9t6bnh6_test.go:46:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpj9t6bnh6_test.go:46: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpj9t6bnh6_test.go:46: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpj9t6bnh6_test.go:46: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpj9t6bnh6_test.go:46: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpj9t6bnh6_test.go:46: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpj9t6bnh6_test.go:46:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpj9t6bnh6_test.go:46: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpj9t6bnh6_test.go:46:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpj9t6bnh6_test.go:46: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmptbq6m44e_test.go:46: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmptbq6m44e_test.go:46: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmptbq6m44e_test.go:46:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmptbq6m44e_test.go:46: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmptbq6m44e_test.go:46: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmptbq6m44e_test.go:46: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmptbq6m44e_test.go:46:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmptbq6m44e_test.go:46:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    numeral_map := map[int]string{\n        1:    \"i\",\n       \
    \ 4:    \"iv\",\n        5:    \"v\",\n        9:    \"ix\",\n        10:   \"\
    x\",\n        40:   \"xl\",\n        50:   \"l\",\n        90:   \"xc\",\n   \
    \     100:  \"c\",\n        400:  \"cd\",\n        500:  \"d\",\n        900:\
    \  \"cm\",\n        1000: \"m\",\n    }\n\n    keys := []int{1, 4, 5, 9, 10, 40,\
    \ 50, 90, 100, 400, 500, 900, 1000}\n    var numeral string\n\n    for i := len(keys)\
    \ - 1; i >= 0; i-- {\n        div := number / keys[i]\n        mod := number %\
    \ keys[i]\n        if div > 0 {\n            numeral += strings.Repeat(numeral_map[keys[i]],\
    \ div)\n        }\n        number = mod\n    }\n\n    return numeral\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjypefk63_test.go:39:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075535
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanSymbols := [...]string{\"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    numberValues\
    \ := [...]int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    roman\
    \ := \"\"\n    for i := 0; i < len(numberValues); i++ {\n        for number >=\
    \ numberValues[i] {\n            roman += romanSymbols[i]\n            number\
    \ -= numberValues[i]\n        }\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpiux20t73_test.go:46: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpiux20t73_test.go:46: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpiux20t73_test.go:46: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpiux20t73_test.go:46: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpiux20t73_test.go:46:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpiux20t73_test.go:46: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpiux20t73_test.go:46: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpiux20t73_test.go:46: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpiux20t73_test.go:46: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpiux20t73_test.go:46: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpiux20t73_test.go:46:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpiux20t73_test.go:46: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpiux20t73_test.go:46:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpiux20t73_test.go:46: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp_ld63hef_test.go:45: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp_ld63hef_test.go:45: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp_ld63hef_test.go:45: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp_ld63hef_test.go:45: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp_ld63hef_test.go:45: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        panic(\"The number must\
    \ be between 1 and 1000\")\n    }\n\n    roman := \"\"\n    for number > 0 {\n\
    \        if number >= 1000 {\n            roman += \"m\"\n            number -=\
    \ 1000\n        } else if number >= 900 {\n            roman += \"cm\"\n     \
    \       number -= 900\n        } else if number >= 500 {\n            roman +=\
    \ \"d\"\n            number -= 500\n        } else if number >= 400 {\n      \
    \      roman += \"cd\"\n            number -= 400\n        } else if number >=\
    \ 100 {\n            roman += \"c\"\n            number -= 100\n        } else\
    \ if number >= 90 {\n            roman += \"xc\"\n            number -= 90\n \
    \       } else if number >= 50 {\n            roman += \"l\"\n            number\
    \ -= 50\n        } else if number >= 40 {\n            roman += \"xl\"\n     \
    \       number -= 40\n        } else if number >= 10 {\n            roman += \"\
    x\"\n            number -= 10\n        } else if number >= 9 {\n            roman\
    \ += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n      \
    \      roman += \"v\"\n            number -= 5\n        } else if number >= 4\
    \ {\n            roman += \"iv\"\n            number -= 4\n        } else if number\
    \ >= 1 {\n            roman += \"i\"\n            number -= 1\n        }\n   \
    \ }\n\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    var digit = []int{1, 5, 10, 50, 100, 500, 1000}\n    var sym =\
    \ []string{\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"}\n    var c = 0\n\n\
    \    for i := len(digit) - 1; i >= 0; i-- {\n        x := number/digit[i]\n  \
    \      if x < 4 {\n            for ; x > 0; x-- {\n                c++\n     \
    \           fmt.Print(sym[i])\n            }\n        } else if x == 4 {\n   \
    \         c++\n            fmt.Print(sym[i], sym[i+1])\n        } else if x >\
    \ 4 && x < 9 {\n            c++\n            fmt.Print(sym[i+1])\n           \
    \ for x = x - 5; x > 0; x-- {\n                c++\n                fmt.Print(sym[i])\n\
    \            }\n        } else if x == 9 {\n            c++\n            fmt.Print(sym[i],\
    \ sym[i+2])\n        }\n        number %= digit[i]\n    }\n    return fmt.Sprintf(\"\
    \ (%d)\", c)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "xvivcliicclicdxxvidiivxliiilxllxlivdxxxiidcddcdlxlivm--- FAIL: TestInt_To_Mini_Roman\
    \ (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'xix', got ' (3)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1\
    \ (0.00s)\n        tmpu8l_oz4u_test.go:72: expected 'clii', got ' (4)'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'ccli', got ' (4)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpu8l_oz4u_test.go:72: expected 'cdxxvi', got ' (5)'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'd', got ' (1)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpu8l_oz4u_test.go:72: expected 'i', got ' (1)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpu8l_oz4u_test.go:72: expected 'iv', got ' (1)'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'xliii', got ' (4)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpu8l_oz4u_test.go:72: expected 'xc', got ' (2)'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'xciv', got ' (3)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpu8l_oz4u_test.go:72: expected 'dxxxii', got ' (6)'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'cm', got ' (2)'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpu8l_oz4u_test.go:72: expected 'cmxciv', got ' (5)'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpu8l_oz4u_test.go:72:\
    \ expected 'm', got ' (1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmptbq6m44e_test.go:46: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmptbq6m44e_test.go:46: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmptbq6m44e_test.go:46:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmptbq6m44e_test.go:46: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmptbq6m44e_test.go:46: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmptbq6m44e_test.go:46: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmptbq6m44e_test.go:46:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmptbq6m44e_test.go:46:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmptbq6m44e_test.go:46: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\"\
    )\n    }\n\n    result := \"\"\n    for number > 0 {\n        if number >= 1000\
    \ {\n            result += \"m\"\n            number -= 1000\n        } else if\
    \ number >= 900 {\n            result += \"cm\"\n            number -= 900\n \
    \       } else if number >= 500 {\n            result += \"d\"\n            number\
    \ -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n  \
    \          number -= 400\n        } else if number >= 100 {\n            result\
    \ += \"c\"\n            number -= 100\n        } else if number >= 90 {\n    \
    \        result += \"xc\"\n            number -= 90\n        } else if number\
    \ >= 50 {\n            result += \"l\"\n            number -= 50\n        } else\
    \ if number >= 40 {\n            result += \"xl\"\n            number -= 40\n\
    \        } else if number >= 10 {\n            result += \"x\"\n            number\
    \ -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n     \
    \       number -= 9\n        } else if number >= 5 {\n            result += \"\
    v\"\n            number -= 5\n        } else if number >= 4 {\n            result\
    \ += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n      \
    \      result += \"i\"\n            number -= 1\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    var numeral = \"\"\n    // Use a single function to handle conversion\
    \ of all numerals.\n    // Technically, there is an edge case that should be handled\n\
    \    // (what if the numeral were \"IM\", or \"IC\"? But these are not valid numbers\n\
    \    // since \"M\" or \"C\" can be used only once in a number, and I or X \n\
    \    // cannot precede M or C).\n    appendNumeral := func(numeralChar rune, numeralCount\
    \ int) {\n        for i := 0; i < numeralCount; i++ {\n            numeral +=\
    \ string(numeralChar)\n        }\n    }\n    if number >= 1000 {\n        appendNumeral('m',\
    \ number / 1000)\n        number %= 1000\n    }\n    if number >= 900 {\n    \
    \    appendNumeral('c', 1)\n        appendNumeral('m', 1)\n        number %= 900\n\
    \    }\n    if number >= 500 {\n        appendNumeral('d', 1)\n        number\
    \ %= 500\n    }\n    if number >= 400 {\n        appendNumeral('c', 1)\n     \
    \   appendNumeral('d', 1)\n        number %= 400\n    }\n    if number >= 100\
    \ {\n        appendNumeral('c', number / 100)\n        number %= 100\n    }\n\
    \    if number >= 90 {\n        appendNumeral('x', 1)\n        appendNumeral('c',\
    \ 1)\n        number %= 90\n    }\n    if number >= 50 {\n        appendNumeral('l',\
    \ 1)\n        number %= 50\n    }\n    if number >= 40 {\n        appendNumeral('x',\
    \ 1)\n        appendNumeral('l', 1)\n        number %= 40\n    }\n    if number\
    \ >= 10 {\n        appendNumeral('x', number / 10)\n        number %= 10\n   \
    \ }\n    if number >= 9 {\n        appendNumeral('i', 1)\n        appendNumeral('x',\
    \ 1)\n        number %= 9\n    }\n    if number >= 5 {\n        appendNumeral('v',\
    \ 1)\n        number %= 5\n    }\n    if number >= 4 {\n        appendNumeral('i',\
    \ 1)\n        appendNumeral('\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz50s10zh_test.go:78:23: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075534
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_str := \"\"\n    for number > 0 {\n        if number >=\
    \ 1000 {\n            roman_str += \"m\"\n            number -= 1000\n       \
    \ } else if number >= 900 {\n            roman_str += \"cm\"\n            number\
    \ -= 900\n        } else if number >= 500 {\n            roman_str += \"d\"\n\
    \            number -= 500\n        } else if number >= 400 {\n            roman_str\
    \ += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n  \
    \          roman_str += \"c\"\n            number -= 100\n        } else if number\
    \ >= 90 {\n            roman_str += \"xc\"\n            number -= 90\n       \
    \ } else if number >= 50 {\n            roman_str += \"l\"\n            number\
    \ -= 50\n        } else if number >= 40 {\n            roman_str += \"xl\"\n \
    \           number -= 40\n        } else if number >= 10 {\n            roman_str\
    \ += \"x\"\n            number -= 10\n        } else if number >= 9 {\n      \
    \      roman_str += \"ix\"\n            number -= 9\n        } else if number\
    \ >= 5 {\n            roman_str += \"v\"\n            number -= 5\n        } else\
    \ if number >= 4 {\n            roman_str += \"iv\"\n            number -= 4\n\
    \        } else if number >= 1 {\n            roman_str += \"i\"\n           \
    \ number -= 1\n        }\n    }\n    return roman_str\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075535
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    // your code here\n    // return \"\"\n\n    arabic := []int{1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    roman := []string{\"m\"\
    , \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"\
    iv\", \"i\"}\n\n    output := \"\"\n    for i := 0; i < len(arabic); i++ {\n \
    \       for number >= arabic[i] {\n            number -= arabic[i]\n         \
    \   output += roman[i]\n        }\n    }\n    return output\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp_ld63hef_test.go:45: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp_ld63hef_test.go:45: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp_ld63hef_test.go:45: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp_ld63hef_test.go:45: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp_ld63hef_test.go:45: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp_ld63hef_test.go:45: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp_ld63hef_test.go:45: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp_ld63hef_test.go:45: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp_ld63hef_test.go:45: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp_ld63hef_test.go:45: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp_ld63hef_test.go:45:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp_ld63hef_test.go:45: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    var numeral = \"\";\n    var numeral_map = map[int]string{\n \
    \       1:    \"i\",\n        4:    \"iv\",\n        5:    \"v\",\n        9:\
    \    \"ix\",\n        10:   \"x\",\n        40:   \"xl\",\n        50:   \"l\"\
    ,\n        90:   \"xc\",\n        100:  \"c\",\n        400:  \"cd\",\n      \
    \  500:  \"d\",\n        900:  \"cm\",\n        1000: \"m\",\n    }\n    var keys\
    \ []int\n    for key := range numeral_map {\n        keys = append(keys, key)\n\
    \    }\n    sort.Ints(keys)\n    var values = make([]string, len(keys))\n    for\
    \ i, key := range keys {\n        values[i] = numeral_map[key]\n    }\n    for\
    \ i, _ := range keys {\n        for number >= keys[i] {\n            numeral +=\
    \ values[i]\n            number -= keys[i]\n        }\n    }\n    return numeral\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcv5gq0y0_test.go:36:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075535
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\
    \n    roman := \"\"\n    for number >= 1000 {\n        roman += \"m\"\n      \
    \  number -= 1000\n    }\n    for number >= 900 {\n        roman += \"cm\"\n \
    \       number -= 900\n    }\n    for number >= 500 {\n        roman += \"d\"\n\
    \        number -= 500\n    }\n    for number >= 400 {\n        roman += \"cd\"\
    \n        number -= 400\n    }\n    for number >= 100 {\n        roman += \"c\"\
    \n        number -= 100\n    }\n    for number >= 90 {\n        roman += \"xc\"\
    \n        number -= 90\n    }\n    for number >= 50 {\n        roman += \"l\"\n\
    \        number -= 50\n    }\n    for number >= 40 {\n        roman += \"xl\"\n\
    \        number -= 40\n    }\n    for number >= 10 {\n        roman += \"x\"\n\
    \        number -= 10\n    }\n    for number >= 9 {\n        roman += \"ix\"\n\
    \        number -= 9\n    }\n    for number >= 5 {\n        roman += \"v\"\n \
    \       number -= 5\n    }\n    for number >= 4 {\n        roman += \"iv\"\n \
    \       number -= 4\n    }\n    for number >= 1 {\n        roman += \"i\"\n  \
    \      number -= 1\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075535
- exit_code: 0
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    var str string\n    var nums = []int{1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n    var romans = []string{\"m\", \"cm\", \"d\"\
    , \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\
    \    for i := 0; i < len(nums); i++ {\n        for number >= nums[i] {\n     \
    \       str += romans[i]\n            number -= nums[i]\n        }\n    }\n  \
    \  return str\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075535
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    var result string\n\n    if number >= 1000 {\n        result +=\
    \ \"m\"\n        number -= 1000\n    }\n    if number >= 900 {\n        result\
    \ += \"cm\"\n        number -= 900\n    }\n    if number >= 500 {\n        result\
    \ += \"d\"\n        number -= 500\n    }\n    if number >= 400 {\n        result\
    \ += \"cd\"\n        number -= 400\n    }\n    if number >= 100 {\n        result\
    \ += \"c\"\n        number -= 100\n    }\n    if number >= 90 {\n        result\
    \ += \"xc\"\n        number -= 90\n    }\n    if number >= 50 {\n        result\
    \ += \"l\"\n        number -= 50\n    }\n    if number >= 40 {\n        result\
    \ += \"xl\"\n        number -= 40\n    }\n    if number >= 10 {\n        result\
    \ += \"x\"\n        number -= 10\n    }\n    if number >= 9 {\n        result\
    \ += \"ix\"\n        number -= 9\n    }\n    if number >= 5 {\n        result\
    \ += \"v\"\n        number -= 5\n    }\n    if number >= 4 {\n        result +=\
    \ \"iv\"\n        number -= 4\n    }\n    if number >= 1 {\n        result +=\
    \ \"i\"\n        number -= 1\n    }\n\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1\
    \ (0.00s)\n        tmpbpgcs9d0_test.go:100: expected 'clii', got 'cli'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpbpgcs9d0_test.go:100:\
    \ expected 'ccli', got 'cxclxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpbpgcs9d0_test.go:100: expected 'cdxxvi', got 'cdxixvi'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpbpgcs9d0_test.go:100:\
    \ expected 'xliii', got 'xli'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpbpgcs9d0_test.go:100: expected 'dxxxii', got 'dxixvivi'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075535
