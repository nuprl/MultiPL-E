name: HumanEval_83_starts_one_ends
language: go_test.go
prompt: "package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a positive integer n, return the count of the numbers of n-digit\n\
  // positive integers that start or end with 1.\nfunc starts_one_ends(n int) int\
  \ {\n"
tests: "func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual:\
  \ candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n\
  \     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected:\
  \ 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
  \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    count := 0\n    for i := 1; i <= n; i++ {\n        count += starts_one_ends_util(i)\n\
    \    }\n    return count\n}\n", "    if n == 1 {\n        return 1\n    }\n  \
    \  var ans int = 1 // we have one number that is 1\n    var base = 1\n    var\
    \ num_digit = 1\n    for num_digit < n {\n        num_digit += 1\n        base\
    \ *= 10\n        ans += 9 * base\n    }\n    return ans\n}\n", "    // If we don't\
    \ have a valid positive integer, return zero.\n    if n < 1 {\n        return\
    \ 0\n    }\n\n    // Compute the value of the largest n-digit positive integer.\n\
    \    largest := 1\n    for i := 1; i < n; i++ {\n        largest *= 10\n    }\n\
    \n    // Now, we know that the count of the n-digit positive integers that\n \
    \   // start or end with 1 is equal to the count of the number of\n    // n-digit\
    \ positive integers that start with 1 plus the count of the\n    // number of\
    \ (n-1)-digit positive integers.\n    return largest + starts_one_ends(n - 1)\n\
    }\n", "    // This can be figured out using combinatorics.\n    // n = 3:\n  \
    \  // 111, 211, 311, 411, 511, 611, 711, 811, 911\n    // 121, 131, 141, 151,\
    \ 161, 171, 181, 191\n    // 112, 113, 114, 115, 116, 117, 118, 119\n    // So\
    \ the answer is 9 + 8 + 8 = 25.\n    if n == 1 {\n        return 2\n    } else\
    \ if n == 2 {\n        return 9\n    } else {\n        return 9 + 8 * (n - 1)\n\
    \    }\n}\n", "    total := 0\n    for i := 1; i <= n; i++ {\n        total +=\
    \ 9 * base_power(10, i - 1)\n    }\n    return total\n}\n", "    var result int\n\
    \    if n < 1 {\n        return result\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    left_s_1, left_s_0 := 1, 0\n    for i := 2; i <= n; i++ {\n  \
    \      left_s_1, left_s_0 = (left_s_1 + left_s_0) * 2, left_s_1\n    }\n    return\
    \ left_s_1 * 2 + left_s_0\n}\n", "    if n < 1 {\n        return 0\n    }\n\n\
    \    if n == 1 {\n        return 2\n    }\n\n    // 0 ~ 9\n    ends_with_one :=\
    \ 10\n\n    // 1 ~ 9\n    start_with_one := 9\n\n    sum := 0\n    // 10 ~ 99\n\
    \    for i := 2; i < n; i++ {\n        // 10 ~ 19\n        sum += 10 * start_with_one\n\
    \        // (1 ~ 9) * (10 ~ 99)\n        start_with_one *= 10\n    }\n\n    sum\
    \ += start_with_one + ends_with_one\n\n    return sum\n}\n", "    if n == 1 {\n\
    \        return 2\n    }\n\n    return starts_one_ends(n - 1) + 9 * pows(9, n\
    \ - 2)\n}\n", "    if n == 1 {\n        return 1\n    }\n\n    // dp[i] is the\
    \ count of i-digit positive integers starts or ends with 1.\n    dp := make([]int,\
    \ n + 1)\n    dp[1] = 1\n    dp[2] = 9\n    for i := 3; i <= n; i++ {\n      \
    \  dp[i] = 9 * dp[i - 1]\n    }\n\n    return dp[n]\n}\n", "    if n == 1 {\n\
    \        return 1\n    }\n    if n < 1 {\n        return 0\n    }\n    if n >\
    \ 10 {\n        return -1\n    }\n    var count int\n    for i := 1; i < n; i++\
    \ {\n        for j := 1; j < n; j++ {\n            if i == 1 && j == 1 {\n   \
    \             count++\n            } else if i == 1 || j == 1 {\n            \
    \    count += 2\n            } else {\n                count += 4\n          \
    \  }\n        }\n    }\n    return count\n}\n", "    if n == 1 {\n        return\
    \ 10\n    }\n    if n == 2 {\n        return 55\n    }\n    if n == 3 {\n    \
    \    return 220\n    }\n    return 100\n}\n", "    ones := 1\n    for i := 1;\
    \ i < n; i++ {\n        ones = ones * 10 + 1\n    }\n    return ones\n}\n", " \
    \   var cnt,i int = 0,1\n    if n <= 0 {\n        return cnt\n    }\n\n    //\
    \ first digit\n    cnt += 9 * get_result(n-1)\n    for i = 2; i < n; i++ {\n \
    \       cnt += get_result(i-1) * 9\n    }\n    return cnt\n}\n", "    if n ==\
    \ 1 {\n        return 1\n    }\n\n    count := 0\n    if n%2 == 0 {\n        count\
    \ += 9\n    } else {\n        count += (n - 2)/2 * 9 + 10\n    }\n\n    var i\
    \ int\n    for i = 2; i < n; i++ {\n        count += 9*9*9*9\n    }\n\n    return\
    \ count\n}\n", "    if n == 1 {\n        return 10 - 2\n    }\n    if n == 2 {\n\
    \        return 9 * (9 + 1) / 2\n    }\n    if n == 3 {\n        return 9 * 9\
    \ * (9 + 1) / 2\n    }\n    if n == 4 {\n        return 9 * 9 * 9 * (9 + 1) /\
    \ 2\n    }\n    if n == 5 {\n        return 9 * 9 * 9 * 9 * (9 + 1) / 2\n    }\n\
    \    if n == 6 {\n        return 9 * 9 * 9 * 9 * 9 * (9 + 1) / 2\n    }\n    if\
    \ n == 7 {\n        return 9 * 9 * 9 * 9 * 9 * 9 * (9 + 1) / 2\n    }\n    if\
    \ n == 8 {\n        return 9 * 9 * 9 * 9 * 9 * 9 * 9 * (9 + 1) / 2\n    }\n  \
    \  if n == 9 {\n        return 9 * 9 * 9 * 9 * 9 * 9 * 9 * 9 * (9 + 1) / 2\n \
    \   }\n    if n == 10 {\n        return 9 * 9 * 9 * 9 * 9 * 9 * 9 * 9 * 9 * (9\
    \ + 1) / 2\n    }\n    return 0\n}\n", "    if n == 1 {\n        return 2\n  \
    \  }\n\n    return 9 * starts_one_ends(n - 1)\n}\n", "    if n == 1 {\n      \
    \  return 2\n    }\n    return starts_one_ends(n-1) + 9 * (n-1) * int(math.Pow10(n-2))\n\
    }\n", "    counts := make([]int, n+1)\n    counts[0] = 0\n    counts[1] = 1\n\
    \    for i := 2; i <= n; i++ {\n        counts[i] = counts[i-1] + 10*counts[i-2]\n\
    \    }\n    return counts[n]\n}\n", "    if n < 1 {\n        return 0\n    }\n\
    \n    if n == 1 {\n        return 1\n    }\n\n    // Write numbers of n-digit\
    \ positive integers that start or end with 1.\n    //\n    //  1: 1, 11, ... 1111,\
    \ ...\n    //  2: 11, ..., 1111, ..., 111111, ...\n    //  3: 111, ..., 11111,\
    \ ..., 1111111, ...\n    //  4: 1111, ..., 111111, ..., 11111111, ...\n    //\n\
    \    // This helps to see that to count n-digit integers that start or end with\
    \ 1,\n    // we need to count the numbers of (n-1)-digit integers that start or\
    \ end with 1.\n    //\n    // We need to count numbers that start with 1, which\
    \ are the (n-1)-digit numbers\n    // that start or end with 1, and numbers that\
    \ end with 1, which are the (n-1)-digit\n    // numbers that start or end with\
    \ 1.\n    return 2 * starts_one_ends(n-1)\n}\n", "    count := 0\n    for i :=\
    \ 1; i <= n; i++ {\n        start_count := 0\n        // find numbers that start\
    \ with one\n        start_count = 9 * (1 << uint(i-1))\n        if i == 1 {\n\
    \            start_count = 1\n        }\n        // find numbers that end with\
    \ one\n        end_count := 0\n        if i == 1 {\n            end_count = 1\n\
    \        } else {\n            end_count = 9 * (1 << uint(i-2))\n        }\n \
    \       count += start_count + end_count\n    }\n    return count\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
