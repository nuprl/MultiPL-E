name: HumanEval_69_search
language: go_test.go
prompt: "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You\
  \ are given a non-empty list of positive integers. Return the greatest integer that\
  \ is greater than \n// zero, and has a frequency greater than or equal to the value\
  \ of the integer itself. \n// The frequency of an integer is the number of times\
  \ it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n\
  // search([4, 1, 2, 2, 3, 1]) == 2\n// search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n\
  // search([5, 5, 4, 4, 4]) == -1\nfunc search(lst []int) int {\n"
tests: "func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual:\
  \ candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3,\
  \ 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}),\
  \ expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n\
  \     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7,\
  \ 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}),\
  \ expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3,\
  \ 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected:\
  \ -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10,\
  \ 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1,\
  \ 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7,\
  \ 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n \
  \    { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8,\
  \ 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected:\
  \ 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6,\
  \ 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1,\
  \ 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5,\
  \ 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual:\
  \ candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected:\
  \ 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10,\
  \ 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}),\
  \ expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7,\
  \ 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10,\
  \ 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4,\
  \ 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual:\
  \ candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    counter := make(map[int]int)\n    for _, val := range lst {\n \
    \       counter[val] += 1\n    }\n    max := 0\n    for _, val := range lst {\n\
    \        if val > max && counter[val] >= val {\n            max = val\n      \
    \  }\n    }\n    if max == 0 {\n        return -1\n    }\n    return max\n}\n",
  "    if len(lst) == 0 {\n        return -1\n    }\n    m := make(map[int]int)\n\
    \    max := -1\n    for _, val := range lst {\n        if _, ok := m[val]; ok\
    \ {\n            m[val] += 1\n        } else {\n            m[val] = 1\n     \
    \   }\n        if m[val] >= val && val > max {\n            max = val\n      \
    \  }\n    }\n    return max\n}\n", "    // Write your code here\n    var frequencyMap\
    \ = make(map[int]int)\n    var keyArray []int\n    var valueArray []int\n    var\
    \ maxValue = 0\n    var maxKey = 0\n    var a int\n    var b int\n    var tmp\
    \ int\n    var maxIndex int\n    var max int\n    var key int\n    var value int\n\
    \    var freq int\n    var itemExists bool\n    var maxFrequency = 0\n    var\
    \ maxValueIndex = 0\n    var maxFreqIndex = 0\n    var maxFreqKey = 0\n    var\
    \ maxFreqValue = 0\n    var maxKeyIndex = 0\n    var maxValueIndex2 = 0\n    for\
    \ index, value := range lst {\n        itemExists = false\n        for keyIndex,\
    \ keyValue := range keyArray {\n            if keyValue == value {\n         \
    \       itemExists = true\n                maxKeyIndex = keyIndex\n          \
    \      break\n            }\n        }\n        if !itemExists {\n           \
    \ keyArray = append(keyArray, value)\n            valueArray = append(valueArray,\
    \ 1)\n            maxKeyIndex = len(keyArray) - 1\n        } else {\n        \
    \    valueArray[maxKeyIndex]++\n        }\n        if value > maxValue {\n   \
    \         maxValue = value\n            maxValueIndex = index\n        }\n   \
    \     if valueArray[maxKeyIndex] > maxFrequency {\n            maxFrequency =\
    \ valueArray[maxKeyIndex]\n            maxFreqIndex = maxKeyIndex\n        }\n\
    \    }\n    fmt.Println(keyArray)\n    fmt.Println(valueArray)\n    fmt.Println(maxValue)\n\
    \    fmt.Println(maxFrequency)\n    if maxValue > maxFrequency {\n        return\
    \ -1\n    }\n    if maxValue == maxFrequency {\n        maxKey = keyArray[maxValueIndex]\n\
    \        maxFreqKey = keyArray[maxFreqIndex]\n        maxFreqValue = valueArray[maxFreqIndex]\n\
    \        maxKeyIndex = maxValueIndex\n        maxValueIndex2 = maxFreqIndex\n\
    \        if maxKey > maxFreqKey {\n            a = maxKeyIndex\n            b\
    \ = maxValueIndex2\n        }", "    ints := make(map[int]int)\n    for _, v :=\
    \ range lst {\n        ints[v]++\n    }\n    for _, v := range lst {\n       \
    \ if ints[v] >= v {\n            return v\n        }\n    }\n    return -1\n}\n",
  "    max, val := 0, 0\n    // todo: write this method\n    for _, v := range lst\
    \ {\n        // create map\n        if v > max {\n            max = v\n      \
    \  }\n    }\n    fmt.Println(max)\n    m := make(map[int]int)\n    for _, v :=\
    \ range lst {\n        m[v]++\n    }\n    for _, v := range lst {\n        if\
    \ v > 0 && v == m[v] {\n            val = v\n        }\n    }\n    if val == 0\
    \ {\n        return -1\n    }\n    return val\n}\n", "    ints := make(map[int]int)\n\
    \    for _, item := range lst {\n        ints[item] += 1\n    }\n    greatest\
    \ := -1\n    for key, value := range ints {\n        if key <= value && key >\
    \ greatest {\n            greatest = key\n        }\n    }\n    return greatest\n\
    }\n", "    frequencyMap := make(map[int]int)\n    for _, value := range lst {\n\
    \        frequencyMap[value]++\n    }\n    for _, value := range lst {\n     \
    \   if frequencyMap[value] >= value {\n            return value\n        }\n \
    \   }\n    return -1\n}\n", "    max, freq := 0, 0\n    for _, x := range lst\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    cnt := make([]int,\
    \ max + 1)\n    for _, x := range lst {\n        cnt[x]++\n    }\n    for i, x\
    \ := range cnt {\n        if x >= i && x > freq {\n            freq = x\n    \
    \    }\n    }\n    if freq == 0 {\n        return -1\n    }\n    return freq\n\
    }\n", "    m := make(map[int]int)\n    for _, item := range lst {\n        m[item]++\n\
    \    }\n    for i := len(lst); i > 0; i-- {\n        if m[i] >= i {\n        \
    \    return i\n        }\n    }\n    return -1\n}\n", "    var result int\n  \
    \  for _, v := range lst {\n        if v > result {\n            result = v\n\
    \        }\n    }\n    return result\n}\n", "    list := make(map[int]int)\n \
    \   var max int\n    var maxCount int\n    for _, v := range lst {\n        if\
    \ _, ok := list[v]; ok {\n            list[v]++\n        } else {\n          \
    \  list[v] = 1\n        }\n        if v > max {\n            max = v\n       \
    \ }\n    }\n    for i, v := range list {\n        if v >= i && i == max {\n  \
    \          return i\n        }\n        if v >= i && v > maxCount {\n        \
    \    maxCount = v\n            max = i\n        }\n    }\n    return -1\n}\n",
  "    var mapFrequency = make(map[int]int)\n    for _, val := range lst {\n     \
    \   mapFrequency[val]++\n    }\n    for i := len(lst); i > 0; i-- {\n        if\
    \ mapFrequency[i] >= i {\n            return i\n        }\n    }\n    return -1\n\
    }\n", "    // Write your code here\n    hash := make(map[int]int)\n    for _,\
    \ val := range lst {\n        hash[val] += 1\n    }\n    largest := 0\n    for\
    \ key, val := range hash {\n        if val >= key && key > largest {\n       \
    \     largest = key\n        }\n    }\n    if largest == 0 {\n        return -1\n\
    \    }\n    return largest\n}\n", "    if len(lst) == 0 {\n        return -1\n\
    \    }\n    var m = make(map[int]int)\n    for _, v := range lst {\n        m[v]++\n\
    \    }\n    var res = -1\n    for _, k := range lst {\n        if k > 0 && m[k]\
    \ >= k && res < k {\n            res = k\n        }\n    }\n    return res\n}\n",
  "    // write your code in Go 1.4\n    if len(lst) == 0 {\n        return -1\n \
    \   }\n    var max, value int\n    var numbers map[int]int\n    numbers = make(map[int]int)\n\
    \    for _, n := range lst {\n        numbers[n]++\n    }\n    for k, v := range\
    \ numbers {\n        if k == v && k > max {\n            max = k\n           \
    \ value = v\n        }\n    }\n    if max == 0 {\n        return -1\n    }\n \
    \   return value\n}\n", "    counts := make(map[int]int)\n    for _, n := range\
    \ lst {\n        counts[n]++\n    }\n    for _, n := range lst {\n        if n\
    \ > 0 && counts[n] >= n {\n            return n\n        }\n    }\n    return\
    \ -1\n}\n", "    hist := map[int]int{}\n    for _,v := range lst {\n        hist[v]++\n\
    \    }\n    for _, v := range lst {\n        if v == 1 { continue }\n        if\
    \ v == hist[v] { return v }\n    }\n    return -1\n}\n", "    // Write your code\
    \ here\n    return -1\n}\n", "    var max int\n    var m map[int]int\n    m =\
    \ make(map[int]int)\n    for _, a := range lst {\n        m[a]++\n        if a\
    \ > max {\n            max = a\n        }\n    }\n    for i := max; i > 0; i--\
    \ {\n        if m[i] >= i {\n            return i\n        }\n    }\n    return\
    \ -1\n}\n", "    itemCount := map[int]int{}\n    for _, item := range lst {\n\
    \        itemCount[item]++\n    }\n    for i := len(lst); i > 0; i-- {\n     \
    \   if itemCount[i] >= i {\n            return i\n        }\n    }\n    return\
    \ -1\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
