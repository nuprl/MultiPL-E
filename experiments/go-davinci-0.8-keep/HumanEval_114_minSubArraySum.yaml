name: HumanEval_114_minSubArraySum
language: go_test.go
prompt: "package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n\
  // of nums.\n// Example\n// minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n// minSubArraySum([-1,\
  \ -2, -3]) == -6\nfunc minSubArraySum(nums []int) int {\n"
tests: "func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected:\
  \ 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual:\
  \ candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}),\
  \ expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}),\
  \ expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected:\
  \ -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6\
  \ },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n   \
  \  { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     {\
  \ actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}),\
  \ expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\
  \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
  \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\",\
  \ tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
  \t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(nums) == 0 {\n        return 0\n    }\n    if len(nums)\
    \ == 1 {\n        return nums[0]\n    }\n    maxSum := nums[0]\n    for i := 1;\
    \ i < len(nums); i++ {\n        maxSum = max(maxSum, nums[i])\n    }\n    if maxSum\
    \ >= 0 {\n        return 0\n    }\n    sum := nums[0]\n    minSum := sum\n   \
    \ for i := 1; i < len(nums); i++ {\n        sum += nums[i]\n        if sum < minSum\
    \ {\n            minSum = sum\n        }\n        if sum > 0 {\n            sum\
    \ = 0\n        }\n    }\n    return minSum\n}\n", "    if len(nums) == 0 {\n \
    \       return 0\n    }\n    if len(nums) == 1 {\n        return nums[0]\n   \
    \ }\n    min := nums[0]\n    currentSum := nums[0]\n    for i := 1; i < len(nums);\
    \ i++ {\n        currentSum += nums[i]\n        if nums[i] < currentSum {\n  \
    \          currentSum = nums[i]\n        }\n        if currentSum < min {\n  \
    \          min = currentSum\n        }\n    }\n    return min\n}\n", "    sum\
    \ := 0\n    minSum := 0\n    for _, n := range nums {\n        sum += n\n    \
    \    if sum < minSum {\n            minSum = sum\n        }\n    }\n    return\
    \ minSum\n}\n", "    // sliding window: O(n)\n    i, j := 0, 0\n    min := nums[0]\n\
    \    sum := 0\n    for j < len(nums) {\n        sum += nums[j]\n        if sum\
    \ < min {\n            min = sum\n        }\n        if sum > 0 {\n          \
    \  sum = 0\n            i = j + 1\n        }\n        j++\n    }\n    return min\n\
    }\n", "    result := 0\n    min := 0\n    for i := 0; i < len(nums); i++ {\n \
    \       result += nums[i]\n        if i == 0 || result < min {\n            min\
    \ = result\n        }\n        if result > 0 {\n            result = 0\n     \
    \   }\n    }\n    return min\n}\n", "    var i, j, sum, minSum int\n    minSum\
    \ = 0\n    sum = 0\n    for i = 0; i < len(nums); i++ {\n        for j = i; j\
    \ < len(nums); j++ {\n            sum += nums[j]\n            if i == 0 && j ==\
    \ 0 {\n                minSum = sum\n            } else if sum < minSum {\n  \
    \              minSum = sum\n            }\n        }\n        sum = 0\n    }\n\
    \    return minSum\n}\n", "    min := nums[0]\n    for l := range nums {\n   \
    \     for r := l; r < len(nums); r++ {\n            sum := 0\n            for\
    \ i := l; i <= r; i++ {\n                sum += nums[i]\n            }\n     \
    \       if sum < min {\n                min = sum\n            }\n        }\n\
    \    }\n    return min\n}\n", "    if len(nums) == 0 {\n        return 0\n   \
    \ }\n    min := nums[0]\n    sum := nums[0]\n    for i := 1; i < len(nums); i++\
    \ {\n        if nums[i] < min {\n            min = nums[i]\n        }\n      \
    \  sum += nums[i]\n        if sum < 0 {\n            sum = 0\n        }\n    }\n\
    \    if sum == 0 {\n        return min\n    }\n    return sum\n}\n", "    min\
    \ := nums[0]\n    for i, n := range nums {\n        sum := n\n        if min >\
    \ sum {\n            min = sum\n        }\n        for j := i + 1; j < len(nums);\
    \ j++ {\n            sum += nums[j]\n            if min > sum {\n            \
    \    min = sum\n            }\n        }\n    }\n    return min\n}\n", "    if\
    \ len(nums) == 0 {\n        return 0\n    }\n    sum := 0\n    min := nums[0]\n\
    \    for _, n := range nums {\n        sum += n\n        if sum < min {\n    \
    \        min = sum\n        }\n        if sum > 0 {\n            sum = 0\n   \
    \     }\n    }\n    return min\n}\n", "    if len(nums) == 0 {\n        return\
    \ 0\n    }\n    min := nums[0]\n    for i := 0; i < len(nums); i++ {\n       \
    \ for j := i; j < len(nums); j++ {\n            sum := 0\n            for k :=\
    \ i; k <= j; k++ {\n                sum += nums[k]\n            }\n          \
    \  if sum < min {\n                min = sum\n            }\n        }\n    }\n\
    \    return min\n}\n", "    var min int = nums[0]\n    var sum int = nums[0]\n\
    \    for i := 1; i < len(nums); i++ {\n        sum += nums[i]\n        min = min2(min,\
    \ sum)\n        if sum < 0 {\n            sum = 0\n        }\n    }\n    return\
    \ min\n}\n", "    minSum := 0\n    minIdx := 0\n    sum := 0\n    i := 0\n   \
    \ for _, n := range nums {\n        sum += n\n        if sum < minSum {\n    \
    \        minSum = sum\n            minIdx = i\n        }\n        i++\n    }\n\
    \    return minSum\n}\n", "    min := nums[0]\n    sum := 0\n    sumEnd := 0\n\
    \    for _, num := range nums {\n        if sumEnd < 0 {\n            sumEnd =\
    \ 0\n        }\n        sumEnd += num\n        sum += num\n        if sumEnd <\
    \ min {\n            min = sumEnd\n        }\n    }\n    if sum > 0 {\n      \
    \  return min\n    }\n    return sum\n}\n", "    minSoFar := nums[0]\n    minEndingHere\
    \ := minSoFar\n    for i := 1; i < len(nums); i++ {\n        minEndingHere = min(minEndingHere\
    \ + nums[i], nums[i])\n        minSoFar = min(minSoFar, minEndingHere)\n    }\n\
    \    return minSoFar\n}\n", "    min := nums[0]\n    for i := 0; i < len(nums);\
    \ i++ {\n        if nums[i] < min {\n            min = nums[i]\n        }\n  \
    \  }\n    return min\n}\n", "    res := 0\n    for i, _ := range nums {\n    \
    \    res += nums[i]\n    }\n    for i, _ := range nums {\n        for j := i;\
    \ j < len(nums); j++ {\n            sum := 0\n            for k := i; k <= j;\
    \ k++ {\n                sum += nums[k]\n            }\n            if sum < res\
    \ {\n                res = sum\n            }\n        }\n    }\n    return res\n\
    }\n", "    // TODO: write your solution here\n    return -1\n}\n", "    if len(nums)\
    \ == 0 {\n        return 0\n    }\n    min := nums[0]\n    sum := nums[0]\n  \
    \  for i := 1; i < len(nums); i++ {\n        sum += nums[i]\n        if sum <\
    \ min {\n            min = sum\n        }\n        if sum < 0 {\n            sum\
    \ = 0\n        }\n    }\n    return min\n}\n", "    sum, minSum := 0, 0\n    for\
    \ _, num := range nums {\n        sum += num\n        if sum < minSum {\n    \
    \        minSum = sum\n        }\n    }\n    return minSum\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
