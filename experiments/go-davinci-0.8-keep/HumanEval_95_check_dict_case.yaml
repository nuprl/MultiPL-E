name: HumanEval_95_check_dict_case
language: go_test.go
prompt: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a dictionary, return True if all keys are strings in lower \n// case\
  \ or all keys are strings in upper case, else return False.\n// The function should\
  \ return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
  a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"a\"\
  :\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
  a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
  Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n//\
  \ check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
  func check_dict_case(dict map[string]string) bool {\n"
tests: "func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
  , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
  p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
  \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
  , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
  Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
  \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
  }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
  Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
  \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // empty dict\n    if dict == nil || len(dict) == 0 {\n       \
    \ return false\n    }\n\n    // lowercase\n    if all_keys_are_strings_in_lower_case(dict)\
    \ {\n        return true\n    }\n\n    // uppercase\n    if all_keys_are_strings_in_upper_case(dict)\
    \ {\n        return true\n    }\n\n    return false\n}\n", "    var allUpper,\
    \ allLower bool = true, true\n    for key, _ := range dict {\n        allUpper\
    \ = allUpper && is_upper(key)\n        allLower = allLower && is_lower(key)\n\
    \    }\n    return allUpper || allLower\n}\n", "    var all_upper_case, all_lower_case\
    \ bool = true, true\n    for key, value := range dict {\n        is_upper := true\n\
    \        for _, v := range key {\n            if (v >= 'a' && v <= 'z') {\n  \
    \              is_upper = false\n                break\n            }\n      \
    \  }\n        if !is_upper {\n            all_upper_case = false\n        } else\
    \ {\n            all_lower_case = false\n        }\n        fmt.Printf(\"%v:%v\\\
    n\", key, value)\n    }\n    return all_upper_case || all_lower_case\n}\n", " \
    \   var hasUpper bool\n    var hasLower bool\n    var hasOther bool\n    for k,\
    \ _ := range dict {\n        if isUpper(k) {\n            hasUpper = true\n  \
    \      } else if isLower(k) {\n            hasLower = true\n        } else {\n\
    \            hasOther = true\n        }\n    }\n    return (!hasOther && (hasUpper\
    \ || hasLower))\n}\n", "    var upper_count, lower_count int\n    // check each\
    \ key\n    for key, _ := range dict {\n        if key == strings.ToUpper(key)\
    \ {\n            upper_count++\n        } else if key == strings.ToLower(key)\
    \ {\n            lower_count++\n        }\n    }\n    if upper_count == len(dict)\
    \ || lower_count == len(dict) {\n        return true\n    }\n    return false\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    lower, upper\
    \ := true, true\n    for k, _ := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            lower = false\n        }\n        if k != strings.ToUpper(k)\
    \ {\n            upper = false\n        }\n    }\n    return lower || upper\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range\
    \ dict {\n        for i := 0; i < len(k); i++ {\n            if (k[i] >= 'A' &&\
    \ k[i] <= 'Z') || (k[i] >= 'a' && k[i] <= 'z') {\n                if i == 0 {\n\
    \                    continue\n                } else {\n                    return\
    \ false\n                }\n            } else {\n                return false\n\
    \            }\n        }\n        fmt.Println(k, v)\n    }\n    return true\n\
    }\n", "    if len(dict) < 1 {\n        return false\n    }\n    var key []rune\n\
    \    var value []rune\n    for k, v := range dict {\n        key = []rune(k)\n\
    \        value = []rune(v)\n        if is_lower_case(key) {\n            if !is_lower_case(value)\
    \ {\n                return false\n            }\n        } else if is_upper_case(key)\
    \ {\n            if !is_upper_case(value) {\n                return false\n  \
    \          }\n        } else {\n            return false\n        }\n    }\n \
    \   return true\n}\n", "    is_lower := false\n    is_upper := false\n    for\
    \ key, _ := range dict {\n        if _, ok := key.(string); !ok {\n          \
    \  return false\n        }\n        if key == strings.ToLower(key) {\n       \
    \     is_lower = true\n        } else if key == strings.ToUpper(key) {\n     \
    \       is_upper = true\n        } else {\n            return false\n        }\n\
    \    }\n    return is_lower || is_upper\n}\n", "    if len(dict) == 0 {\n    \
    \    return false\n    }\n    is_upper := false\n    is_lower := false\n    for\
    \ key, _ := range dict {\n        if key == \"\" {\n            return false\n\
    \        }\n        if is_upper && is_lower {\n            return false\n    \
    \    }\n        if key == strings.ToUpper(key) {\n            is_upper = true\n\
    \        } else if key == strings.ToLower(key) {\n            is_lower = true\n\
    \        } else {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    return false\n}\n", "    i, j := 0, 0\n    for k, _ := range dict {\n\
    \        if is_lower(k) {\n            i++\n        } else if is_upper(k) {\n\
    \            j++\n        } else {\n            return false\n        }\n    }\n\
    \    if i + j == len(dict) {\n        return true\n    }\n    return false\n}\n",
  "    keys := make([]string, len(dict))\n    i := 0\n    for k := range dict {\n\
    \        keys[i] = k\n        i++\n    }\n    if len(keys) == 0 {\n        return\
    \ false\n    }\n    s := keys[0]\n    if s == strings.ToUpper(s) {\n        uppercase\
    \ := true\n        for _, k := range keys {\n            if k != strings.ToUpper(k)\
    \ {\n                uppercase = false\n                break\n            }\n\
    \        }\n        return uppercase\n    } else if s == strings.ToLower(s) {\n\
    \        lowercase := true\n        for _, k := range keys {\n            if k\
    \ != strings.ToLower(k) {\n                lowercase = false\n               \
    \ break\n            }\n        }\n        return lowercase\n    }\n    return\
    \ false\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n    upper\
    \ := true\n    lower := true\n    for k, _ := range dict {\n        _, upper =\
    \ dict[strings.ToUpper(k)]\n        _, lower = dict[strings.ToLower(k)]\n    \
    \    if !(upper || lower) {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    switch(len(dict)) {\n        case 0:\n            return false\n\
    \        case 1:\n            return true\n    }\n    // for i, v := range dict\
    \ {\n    //     if i {\n    //         if i != v {\n    //             return\
    \ false\n    //         }\n    //     }\n    // }\n    return true\n}\n", "  \
    \  // First, check if the given dictionary is empty\n    if len(dict) == 0 {\n\
    \        return false\n    }\n\n    // Check whether all keys are strings in lower\
    \ case\n    lower_case := true\n    for key, _ := range dict {\n        if key\
    \ == key {\n            lower_case = false\n            break\n        }\n   \
    \ }\n\n    // Check whether all keys are strings in upper case\n    upper_case\
    \ := true\n    for key, _ := range dict {\n        if key == key {\n         \
    \   upper_case = false\n            break\n        }\n    }\n\n    return lower_case\
    \ || upper_case\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \    for k, _ := range dict {\n        if len(k) > 0 {\n            if k[0] >=\
    \ 'a' && k[0] <= 'z' {\n                for i := 1; i < len(k); i++ {\n      \
    \              if k[i] < 'a' || k[i] > 'z' {\n                        return false\n\
    \                    }\n                }\n            } else if k[0] >= 'A' &&\
    \ k[0] <= 'Z' {\n                for i := 1; i < len(k); i++ {\n             \
    \       if k[i] < 'A' || k[i] > 'Z' {\n                        return false\n\
    \                    }\n                }\n            } else {\n            \
    \    return false\n            }\n        }\n    }\n    return true\n}\n", " \
    \   // if the dictionary is empty, return false\n    if len(dict) == 0 {\n   \
    \     return false\n    }\n    // check all the keys to see if they are all upper\
    \ or lower\n    upper := true\n    lower := true\n    for k, _ := range dict {\n\
    \        if !is_upper(k) {\n            upper = false\n        }\n        if !is_lower(k)\
    \ {\n            lower = false\n        }\n    }\n    return upper || lower\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    lower := true\n\
    \    upper := true\n    for key, _ := range dict {\n        if key != strings.ToLower(key)\
    \ {\n            lower = false\n        }\n        if key != strings.ToUpper(key)\
    \ {\n            upper = false\n        }\n    }\n    return lower || upper\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    case_of_first_char\
    \ := \"\"\n    all_upper := true\n    all_lower := true\n    for k, v := range\
    \ dict {\n        if len(k) > 0 {\n            if case_of_first_char == \"\" {\n\
    \                if 'A' <= k[0] && k[0] <= 'Z' {\n                    case_of_first_char\
    \ = \"upper\"\n                } else {\n                    case_of_first_char\
    \ = \"lower\"\n                }\n            }\n            if !(('A' <= k[0]\
    \ && k[0] <= 'Z') || ('a' <= k[0] && k[0] <= 'z')) {\n                fmt.Printf(\"\
    Invalid key %s found in dictionary.\\n\", k)\n                return false\n \
    \           }\n            if case_of_first_char == \"upper\" {\n            \
    \    if 'a' <= k[0] && k[0] <= 'z' {\n                    all_upper = false\n\
    \                }\n            } else {\n                if 'A' <= k[0] && k[0]\
    \ <= 'Z' {\n                    all_lower = false\n                }\n       \
    \     }\n        } else {\n            fmt.Printf(\"Invalid key %s found in dictionary.\\\
    n\", k)\n            return false\n        }\n        fmt.Printf(\"Key %s has\
    \ value %s\\n\", k, v)\n    }\n    return all_upper || all_lower\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
