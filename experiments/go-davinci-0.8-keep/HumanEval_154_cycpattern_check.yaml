name: HumanEval_154_cycpattern_check
language: go_test.go
prompt: "package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You are given 2 words. You need to return True if the second word or any\
  \ of its rotations is a substring in the first word\n// cycpattern_check(\"abcd\"\
  ,\"abd\") => False\n// cycpattern_check(\"hello\",\"ell\") => True\n// cycpattern_check(\"\
  whassup\",\"psus\") => False\n// cycpattern_check(\"abab\",\"baa\") => True\n//\
  \ cycpattern_check(\"efef\",\"eeff\") => False\n// cycpattern_check(\"himenss\"\
  ,\"simen\") => True\nfunc cycpattern_check(a string, b string) bool {\n"
tests: "func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false\
  \ },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual:\
  \ candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"\
  efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"\
  ), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected:\
  \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
  \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return cycpattern_check_it(a, b) || cycpattern_check_it(a, b[1:]\
    \ + b[:1]) || cycpattern_check_it(a, b[2:] + b[:2])\n}\n", "    if len(a) < len(b)\
    \ {\n        return false\n    }\n    for i:=0; i< len(a); i++ {\n        rotate\
    \ := a[i:] + a[:i]\n        if len(rotate) < len(b) {\n            continue\n\
    \        }\n        if rotate[:len(b)] == b {\n            return true\n     \
    \   }\n    }\n    return false\n}\n", "    a_len := len(a)\n    b_len := len(b)\n\
    \    if a_len < b_len {\n        return false\n    }\n    for i := 0; i < a_len;\
    \ i++ {\n        if a[i] == b[0] {\n            j := 0\n            for j < b_len\
    \ {\n                if a[(i+j)%a_len] != b[j] {\n                    break\n\
    \                }\n                j++\n            }\n            if j == b_len\
    \ {\n                return true\n            }\n        }\n    }\n    return\
    \ false\n}\n", "    if len(a) < len(b) {\n        return false\n    }\n    b +=\
    \ b\n    return b[:len(b)/2] == a || b[len(b)/2:] == a\n}\n", "    if len(a) <\
    \ len(b) {\n        return false\n    }\n    var result bool\n    counter, i :=\
    \ 0, 0\n    for counter < len(b) {\n        if a[i] == b[counter] {\n        \
    \    counter++\n        } else {\n            counter = 0\n        }\n       \
    \ i++\n        if i == len(a) {\n            i = 0\n        }\n    }\n    if counter\
    \ == len(b) {\n        result = true\n    }\n    return result\n}\n", "    return\
    \ false\n}\n", "    // your code here\n    lena := len(a)\n    lenb := len(b)\n\
    \    if lenb > lena {\n        return false\n    }\n    var c string\n    c =\
    \ a + a\n    for i := 0; i < lena; i++ {\n        if c[i:i+lenb] == b {\n    \
    \        return true\n        }\n    }\n    return false\n}\n", "    if len(a)\
    \ != len(b) {\n        return false\n    }\n    for i := 0; i < len(a); i++ {\n\
    \        if a[i] == b[0] {\n            rotate_b := b[1:] + string(b[0])\n   \
    \         if string(a[i:]) + string(a[:i]) == rotate_b {\n                return\
    \ true\n            }\n        }\n    }\n    return false\n}\n", "    var lena,\
    \ lenb = len(a), len(b)\n    if lena <= lenb {\n        return false\n    }\n\
    \    var aSub = a[:lenb]\n    var bSub = a[1:]\n    if b == aSub {\n        return\
    \ true\n    }\n    if b == bSub {\n        return true\n    }\n    var isSub =\
    \ false\n    var i = 0\n    for i < lena {\n        if a[i] == b[0] {\n      \
    \      isSub = true\n            var j = 0\n            for j < lenb {\n     \
    \           if b[j] != a[i+j] {\n                    isSub = false\n         \
    \           break\n                }\n                j++\n            }\n   \
    \         if isSub {\n                break\n            }\n        }\n      \
    \  i++\n    }\n    return isSub\n}\n", "    if len(a) != len(b) {\n        return\
    \ false\n    }\n    if a == b {\n        return true\n    }\n    i := 0\n    for\
    \ {\n        b = b[1:] + string(b[0])\n        i++\n        if i == len(b) {\n\
    \            break\n        }\n        if a == b {\n            return true\n\
    \        }\n    }\n    return false\n}\n", "    b = b + b\n    return IsSubstring(a,\
    \ b)\n}\n", "    return false\n}\n", "    ra := []rune(a)\n    rb := []rune(b)\n\
    \    rb = append(rb, rb[0])\n    rb = rb[1:]\n    return string(rb) == a\n}\n",
  "    var _a, _b string\n    _a = a\n    _b = b\n    for i := 0; i < len(b); i++\
    \ {\n        _b = string(_b[1:]) + string(_b[0])\n        if _a == _b {\n    \
    \        return true\n        }\n    }\n    return false\n}\n", "    return true\n\
    }\n", "    mlen := len(a)\n    nlen := len(b)\n    if nlen > mlen {\n        return\
    \ false\n    }\n    if nlen == mlen {\n        if a == b {\n            return\
    \ true\n        }\n        return false\n    }\n    bmap := make(map[rune]int)\n\
    \    for _, r := range b {\n        bmap[r]++\n    }\n    l := 0\n    r := 0\n\
    \    count := 0\n    amap := make(map[rune]int)\n    for r < mlen {\n        if\
    \ _, ok := bmap[rune(a[r])]; ok {\n            if amap[rune(a[r])] < bmap[rune(a[r])]\
    \ {\n                count++\n            }\n            amap[rune(a[r])]++\n\
    \        }\n        for count == nlen {\n            if r - l + 1 == nlen {\n\
    \                return true\n            }\n            if _, ok := bmap[rune(a[l])];\
    \ ok {\n                amap[rune(a[l])]--\n                if amap[rune(a[l])]\
    \ < bmap[rune(a[l])] {\n                    count--\n                }\n     \
    \       }\n            l++\n        }\n        r++\n    }\n    return false\n\
    }\n", "    if len(a) < len(b) {\n        return false\n    }\n    c:=append(b,b...)\n\
    \    return c[0:len(b)] == a ||\n        c[1:len(b)+1] == a ||\n        c[2:len(b)+2]\
    \ == a ||\n        c[3:len(b)+3] == a ||\n        c[4:len(b)+4] == a ||\n    \
    \    c[5:len(b)+5] == a ||\n        c[6:len(b)+6] == a ||\n        c[7:len(b)+7]\
    \ == a ||\n        c[8:len(b)+8] == a ||\n        c[9:len(b)+9] == a ||\n    \
    \    c[10:len(b)+10] == a ||\n        c[11:len(b)+11] == a ||\n        c[12:len(b)+12]\
    \ == a ||\n        c[13:len(b)+13] == a ||\n        c[14:len(b)+14] == a ||\n\
    \        c[15:len(b)+15] == a ||\n        c[16:len(b)+16] == a ||\n        c[17:len(b)+17]\
    \ == a ||\n        c[18:len(b)+18] == a ||\n        c[19:len(b)+19] == a ||\n\
    \        c[20:len(b)+20] == a ||\n        c[21:len(b)+21] == a ||\n        c[22:len(b)+22]\
    \ == a ||\n        c[23:len(b)+23] == a ||\n        c[24:len(b)+24] == a ||\n\
    \        c[25:len(b)+25] == a ||\n        c[26:len(b)+26] == a ||\n        c[27:len(b)+27]\
    \ == a ||\n        c[28:len(b)+28] == a ||\n        c[29:len(b)+29] == a ||\n\
    \        c[30:len(b)+30] == a ||\n        c[31:len(b)+31] == a ||\n       ", "\t\
    n := len(a)\n\tif len(b) > n {\n\t\treturn false\n\t}\n\t// \u628Ab\u5FAA\u73AF\
    \u5DE6\u79FB\n\tfor i := 0; i < n; i++ {\n\t\tb = b[1:] + b[:1]\n\t\tif a == b\
    \ {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n", "    // your code here\n\
    \    return false\n}\n", "    if (len(a) != len(b)) {\n        return false\n\
    \    }\n    if (a == b) {\n        return true\n    }\n    var strlen int = len(a)\n\
    \    for i := 0; i < strlen; i++ {\n        if a[i] == b[0] {\n            if\
    \ a[0:i] + a[i+1:] == b[1:] {\n                return true\n            }\n  \
    \      }\n    }\n    return false\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
