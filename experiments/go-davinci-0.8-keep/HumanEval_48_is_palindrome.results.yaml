language: go_test.go
name: HumanEval_48_is_palindrome
results:
- exit_code: 1
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    if len(text) == 0 {\n        return true\n    }\n    return text[0] == text[len(text)-1]\
    \ && is_palindrome(text[1:len(text)-1])\n}\n\nfunc TestIs_Palindrome(t *testing.T)\
    \ {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n\
    \     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"\
    zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true\
    \ },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual:\
    \ candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [1:0]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512620, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_palindrome({0x51d2aa?, 0x0?})\n\t/tmp/tmp8jhz5nsf_test.go:21\
    \ +0x78\ncommand-line-arguments_test.is_palindrome({0x51d2a9?, 0xc000078728?})\n\
    \t/tmp/tmp8jhz5nsf_test.go:21 +0x51\ncommand-line-arguments_test.TestIs_Palindrome(0x0?)\n\
    \t/tmp/tmp8jhz5nsf_test.go:32 +0x62\ntesting.tRunner(0xc000103520, 0x527f60)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    text_len := len(text)\n    mid := text_len / 2\n    for i := 0; i < mid;\
    \ i++ {\n        j := text_len - i - 1\n        if text[i] != text[j] {\n    \
    \        return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t\
    \ *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected:\
    \ true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual:\
    \ candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"\
    ), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n\
    \     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    text_length := len(text)\n    is_palindrome := true\n    for i := 0; i <\
    \ text_length/2; i++ {\n        if text[i] != text[text_length-i-1] {\n      \
    \      is_palindrome = false\n            break\n        }\n    }\n    return\
    \ is_palindrome\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    length := len(text)\n    for i := 0; i < length/2; i++ {\n        if text[i]\
    \ != text[length-i-1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual:\
    \ candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"),\
    \ expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n\
    \     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073703
- exit_code: 2
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    text_reverse := reverse(text)\n    return is_same(text, text_reverse)\n}\n\
    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual:\
    \ candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"),\
    \ expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n\
    \     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwu_xy5ap_test.go:18:21: undefined: reverse

    /tmp/tmpwu_xy5ap_test.go:19:12: undefined: is_same

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    // Just to exercise with slice\n    runes := []rune(text)\n    j := len(runes)\
    \ - 1\n    for i := 0; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] =\
    \ runes[j], runes[i]\n    }\n    return text == string(runes)\n}\n\nfunc TestIs_Palindrome(t\
    \ *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected:\
    \ true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual:\
    \ candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"\
    ), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n\
    \     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    // Strings in Go are immutable, this makes this logic a bit more\n    //\
    \ complicated than it would be in other languages.  We can get around\n    //\
    \ this by using byte arrays instead of strings, which *are* mutable.\n    data\
    \ := []byte(text)\n\n    // We can use range over the byte array to iterate over\
    \ the bytes\n    // in the string.  The first item returned is the index, the\
    \ second\n    // is the actual value.  We don't care about the index, so we'll\n\
    \    // throw it away using _\n    for i, _ := range data {\n        // We find\
    \ the index of the end of the string by subtracting\n        // i from the length\
    \ of the data.  We then compare the values\n        // at those two indexes. \
    \ If they are not equal, the string\n        // is not a palindrome and we can\
    \ return immediately.\n        if data[i] != data[len(data) - i - 1] {\n     \
    \       return false\n        }\n    }\n\n    // If we get here, the string must\
    \ be a palindrome\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T)\
    \ {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n\
    \     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"\
    zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true\
    \ },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual:\
    \ candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    if len(text) <= 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073703
- exit_code: 1
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    return false\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate :=\
    \ is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual:\
    \ candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"),\
    \ expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n\
    \     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"\
    xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0\
    \ (0.00s)\n        tmpki3t3z_y_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmpki3t3z_y_test.go:40:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2\
    \ (0.00s)\n        tmpki3t3z_y_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmpki3t3z_y_test.go:40:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    if len(text) == 0 {\n        return true\n    }\n    if len(text) == 1 {\n\
    \        return true\n    }\n    if len(text) == 2 {\n        return text[0] ==\
    \ text[1]\n    }\n    return text[0] == text[len(text)-1] && is_palindrome(text[1:len(text)-1])\n\
    }\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073845
- exit_code: 1
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    len := len(text)\n    if len == 0 {\n        return true\n    }\n    else\
    \ if len == 1 {\n        return true\n    }\n    else {\n        first := text[0]\n\
    \        last := text[len - 1]\n        if first == last {\n            return\
    \ is_palindrome(text[1:len - 1])\n        }\n        else {\n            return\
    \ false\n        }\n    }\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate\
    \ := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual:\
    \ candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"),\
    \ expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n\
    \     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"\
    xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0m79dwjs_test.go:22:5: expected statement, found ''else''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    lower := []rune(text)\n    length := len(lower)\n\n    for i := 0; i < length\
    \ / 2; i++ {\n        if lower[i] != lower[length - i - 1] {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T)\
    \ {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n\
    \     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"\
    zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true\
    \ },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual:\
    \ candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073845
- exit_code: 2
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    if len(text) == 0 {\n        return true\n    }\n    if len(text) % 2 ==\
    \ 0 {\n        mid := len(text) / 2\n        return text[:mid] == Reverse(text[mid:])\n\
    \    } else {\n        mid := len(text) / 2\n        return text[:mid] == Reverse(text[mid+1:])\n\
    \    }\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2akhak11_test.go:23:30: undefined: Reverse

    /tmp/tmp2akhak11_test.go:26:30: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \tvar palindrome = true\n\tfor i := 0; i < len(text) / 2; i++ {\n\t\tif text[i]\
    \ != text[len(text) - 1 - i] {\n\t\t\tpalindrome = false\n\t\t\tbreak\n\t\t}\n\
    \t}\n\treturn palindrome\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate\
    \ := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual:\
    \ candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"),\
    \ expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n\
    \     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"\
    xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073845
- exit_code: 1
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    // Your code here\n    return false\n}\n\nfunc TestIs_Palindrome(t *testing.T)\
    \ {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n\
    \     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"\
    zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true\
    \ },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual:\
    \ candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0\
    \ (0.00s)\n        tmpdnptzuki_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmpdnptzuki_test.go:41:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2\
    \ (0.00s)\n        tmpdnptzuki_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmpdnptzuki_test.go:41:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    if len(text) <= 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073703
- exit_code: 2
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    // The len() function returns the number of bytes in a string\n    return\
    \ text == reverse(text)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate\
    \ := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual:\
    \ candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"),\
    \ expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n\
    \     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"\
    xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3ss06xoe_test.go:19:20: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073845
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    if len(text) <= 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n    \
    \ { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"\
    aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false\
    \ },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073703
- exit_code: 0
  program: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n\
    // >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n\
    // >>> is_palindrome('zbcd')\n// False\nfunc is_palindrome(text string) bool {\n\
    \    text_len := len(text)\n    if text_len == 0 {\n        return true\n    }\n\
    \    for i := 0; i < text_len / 2; i++ {\n        if text[i] != text[text_len\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual:\
    \ candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"),\
    \ expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n\
    \     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"\
    xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073846
