name: HumanEval_140_fix_spaces
language: go_test.go
prompt: "package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given a string text, replace all spaces in it with underscores, \n// and if a\
  \ string has more than 2 consecutive spaces, \n// then replace all consecutive spaces\
  \ with - \n// fix_spaces(\"Example\") == \"Example\"\n// fix_spaces(\"Example 1\"\
  ) == \"Example_1\"\n// fix_spaces(\" Example 2\") == \"_Example_2\"\n// fix_spaces(\"\
  \ Example   3\") == \"_Example-3\"\nfunc fix_spaces(text string) string {\n"
tests: "func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n   \
  \  { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n  \
  \   { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\"\
  \ },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n    \
  \ { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return \"\"\n}\n", "    // length := len(text)\n    for i := range\
    \ text {\n        if text[i] == ' ' {\n            // text = text[0:i] + \"_\"\
    \ + text[i+1:]\n            text = text[:i] + \"_\" + text[i+1:]\n        }\n\
    \    }\n    return text\n}\n", "    var result string\n    var spaceCounter int\n\
    \    for _, char := range text {\n        if char == ' ' {\n            spaceCounter++\n\
    \            if spaceCounter == 1 {\n                result += \"_\"\n       \
    \     } else if spaceCounter == 2 {\n                result += \"-\"\n       \
    \     }\n        } else {\n            result += string(char)\n            spaceCounter\
    \ = 0\n        }\n    }\n    return result\n}\n", "    spaceFound := false\n \
    \   moreThanTwoSpaces := false\n    result := \"\"\n    for _, v := range text\
    \ {\n        if v == ' ' {\n            if spaceFound {\n                if !moreThanTwoSpaces\
    \ {\n                    moreThanTwoSpaces = true\n                    result\
    \ += \"-\"\n                }\n            } else {\n                spaceFound\
    \ = true\n                result += \"_\"\n            }\n        } else {\n \
    \           spaceFound = false\n            moreThanTwoSpaces = false\n      \
    \      result += string(v)\n        }\n    }\n    return result\n}\n", "    return\
    \ text\n}\n", "    return \"\"\n}\n", "    var result []rune\n    var is_space\
    \ = false\n    var cnt = 0\n    for _, c := range text {\n        if is_space\
    \ && c == ' ' {\n            cnt += 1\n            if cnt == 2 {\n           \
    \     result = append(result, '-')\n                cnt = 0\n            }\n \
    \       } else {\n            is_space = false\n            if c == ' ' {\n  \
    \              result = append(result, '_')\n                is_space = true\n\
    \                cnt = 1\n            } else {\n                result = append(result,\
    \ c)\n            }\n        }\n    }\n    return string(result)\n}\n", "    chars\
    \ := []rune(text)\n    for i, char := range chars {\n        if i == 0 && char\
    \ == ' ' {\n            chars[i] = '_'\n        } else if char == ' ' {\n    \
    \        chars[i] = '_'\n            if chars[i-1] == ' ' {\n                chars[i-1]\
    \ = '-'\n            }\n        }\n    }\n    return string(chars)\n}\n", "  \
    \  return \"\"\n}\n", "    return \"\"\n}\n", "    res := \"\"\n    count := 0\n\
    \    for _, t := range text {\n        if string(t) == \" \" {\n            count++\n\
    \            if count > 2 {\n                continue\n            }\n       \
    \     res += \"_\"\n        } else {\n            count = 0\n            res +=\
    \ string(t)\n        }\n    }\n    return res\n}\n", "    spaces := map[rune]rune{\n\
    \        ' ': '_',\n        '\\t': '_',\n        '\\n': '_',\n    }\n    var result\
    \ []rune\n    var last rune\n    var this rune\n    for _, v := range text {\n\
    \        this = spaces[v]\n        if this == 0 {\n            this = v\n    \
    \    }\n        if last == this {\n            result = append(result, '-')\n\
    \        }\n        result = append(result, this)\n        last = this\n    }\n\
    \    return string(result)\n}\n", "    var output string\n    var prev_char_is_space\
    \ bool = false\n    var add_space bool = false\n    for _, ch := range text {\n\
    \        if string(ch) == \" \" {\n            if !prev_char_is_space {\n    \
    \            add_space = true\n            }\n            prev_char_is_space =\
    \ true\n        } else {\n            prev_char_is_space = false\n           \
    \ if add_space {\n                output += \"_\"\n                add_space =\
    \ false\n            }\n            output += string(ch)\n        }\n    }\n \
    \   return output\n}\n", "    return \"\"\n}\n", "    if len(text) == 0 {\n  \
    \      return text\n    }\n    var result string\n    last := text[0]\n    spaceCount\
    \ := 0\n    for _, char := range text {\n        if char == ' ' {\n          \
    \  spaceCount++\n            if spaceCount == 1 {\n                result += \"\
    _\"\n            } else if spaceCount > 2 {\n                result += \"-\"\n\
    \            }\n        } else {\n            result += string(char)\n       \
    \     spaceCount = 0\n        }\n    }\n    if last == ' ' {\n        result +=\
    \ \"_\"\n    }\n    return result\n}\n", "    var replaced string\n    var prev\
    \ byte\n    var cur byte\n    var trailing_space bool\n    var consecutive_space\
    \ bool\n    for i, ch := range text {\n        prev = cur\n        cur = byte(ch)\n\
    \        if cur == ' ' {\n            if consecutive_space {\n               \
    \ if !trailing_space {\n                    replaced += \"-\"\n              \
    \      trailing_space = true\n                }\n            } else {\n      \
    \          replaced += \"_\"\n                trailing_space = true\n        \
    \    }\n            consecutive_space = true\n        } else {\n            replaced\
    \ += string(cur)\n            consecutive_space = false\n            trailing_space\
    \ = false\n        }\n        if i == 0 && cur == ' ' {\n            replaced\
    \ = \"-\"\n        }\n    }\n    return replaced\n}\n", "    // Write your code\
    \ here\n    return text\n}\n", "    return \"Implement me\"\n}\n", "    // your\
    \ code here\n    return \"\"\n}\n", "    return \"\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
