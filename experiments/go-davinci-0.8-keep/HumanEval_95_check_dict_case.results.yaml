language: go_test.go
name: HumanEval_95_check_dict_case
results:
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    // empty dict\n    if\
    \ dict == nil || len(dict) == 0 {\n        return false\n    }\n\n    // lowercase\n\
    \    if all_keys_are_strings_in_lower_case(dict) {\n        return true\n    }\n\
    \n    // uppercase\n    if all_keys_are_strings_in_upper_case(dict) {\n      \
    \  return true\n    }\n\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvqg5e587_test.go:24:8: undefined: all_keys_are_strings_in_lower_case

    /tmp/tmpvqg5e587_test.go:29:8: undefined: all_keys_are_strings_in_upper_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    var allUpper, allLower\
    \ bool = true, true\n    for key, _ := range dict {\n        allUpper = allUpper\
    \ && is_upper(key)\n        allLower = allLower && is_lower(key)\n    }\n    return\
    \ allUpper || allLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqlz1px9r_test.go:20:32: undefined: is_upper

    /tmp/tmpqlz1px9r_test.go:21:32: undefined: is_lower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    var all_upper_case, all_lower_case\
    \ bool = true, true\n    for key, value := range dict {\n        is_upper := true\n\
    \        for _, v := range key {\n            if (v >= 'a' && v <= 'z') {\n  \
    \              is_upper = false\n                break\n            }\n      \
    \  }\n        if !is_upper {\n            all_upper_case = false\n        } else\
    \ {\n            all_lower_case = false\n        }\n        fmt.Printf(\"%v:%v\\\
    n\", key, value)\n    }\n    return all_upper_case || all_lower_case\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "p:pineapple\nb:banana\np:pineapple\nA:banana\nB:banana\np:pineapple\n5:banana\n\
    a:apple\nName:John\nAge:36\nCity:Houston\nSTATE:NC\nZIP:12345\nfruit:Orange\n\
    taste:Sweet\n--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpetsd1tnr_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpetsd1tnr_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    var hasUpper bool\n \
    \   var hasLower bool\n    var hasOther bool\n    for k, _ := range dict {\n \
    \       if isUpper(k) {\n            hasUpper = true\n        } else if isLower(k)\
    \ {\n            hasLower = true\n        } else {\n            hasOther = true\n\
    \        }\n    }\n    return (!hasOther && (hasUpper || hasLower))\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprytzwh59_test.go:22:12: undefined: isUpper

    /tmp/tmprytzwh59_test.go:24:19: undefined: isLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    var upper_count, lower_count\
    \ int\n    // check each key\n    for key, _ := range dict {\n        if key ==\
    \ strings.ToUpper(key) {\n            upper_count++\n        } else if key ==\
    \ strings.ToLower(key) {\n            lower_count++\n        }\n    }\n    if\
    \ upper_count == len(dict) || lower_count == len(dict) {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq097qhmr_test.go:21:19: undefined: strings

    /tmp/tmpq097qhmr_test.go:23:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    lower, upper := true, true\n    for k, _ :=\
    \ range dict {\n        if k != strings.ToLower(k) {\n            lower = false\n\
    \        }\n        if k != strings.ToUpper(k) {\n            upper = false\n\
    \        }\n    }\n    return lower || upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpss2jg056_test.go:23:17: undefined: strings

    /tmp/tmpss2jg056_test.go:26:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    for k, v := range dict {\n        for i := 0;\
    \ i < len(k); i++ {\n            if (k[i] >= 'A' && k[i] <= 'Z') || (k[i] >= 'a'\
    \ && k[i] <= 'z') {\n                if i == 0 {\n                    continue\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                return false\n            }\n        }\n\
    \        fmt.Println(k, v)\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "p pineapple\nb banana\np pineapple\nA banana\nB banana\np pineapple\n---\
    \ FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmprhl9_hfr_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmprhl9_hfr_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmprhl9_hfr_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) < 1 {\n\
    \        return false\n    }\n    var key []rune\n    var value []rune\n    for\
    \ k, v := range dict {\n        key = []rune(k)\n        value = []rune(v)\n \
    \       if is_lower_case(key) {\n            if !is_lower_case(value) {\n    \
    \            return false\n            }\n        } else if is_upper_case(key)\
    \ {\n            if !is_upper_case(value) {\n                return false\n  \
    \          }\n        } else {\n            return false\n        }\n    }\n \
    \   return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmd0mbcz1_test.go:26:12: undefined: is_lower_case

    /tmp/tmpmd0mbcz1_test.go:27:17: undefined: is_lower_case

    /tmp/tmpmd0mbcz1_test.go:30:19: undefined: is_upper_case

    /tmp/tmpmd0mbcz1_test.go:31:17: undefined: is_upper_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    is_lower := false\n \
    \   is_upper := false\n    for key, _ := range dict {\n        if _, ok := key.(string);\
    \ !ok {\n            return false\n        }\n        if key == strings.ToLower(key)\
    \ {\n            is_lower = true\n        } else if key == strings.ToUpper(key)\
    \ {\n            is_upper = true\n        } else {\n            return false\n\
    \        }\n    }\n    return is_lower || is_upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqfo6v4qy_test.go:21:21: invalid operation: key (variable of type string)
    is not an interface

    /tmp/tmpqfo6v4qy_test.go:24:19: undefined: strings

    /tmp/tmpqfo6v4qy_test.go:26:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    is_upper := false\n    is_lower := false\n \
    \   for key, _ := range dict {\n        if key == \"\" {\n            return false\n\
    \        }\n        if is_upper && is_lower {\n            return false\n    \
    \    }\n        if key == strings.ToUpper(key) {\n            is_upper = true\n\
    \        } else if key == strings.ToLower(key) {\n            is_lower = true\n\
    \        } else {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppguhqhr1_test.go:30:19: undefined: strings

    /tmp/tmppguhqhr1_test.go:32:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    return false\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpmanp8vu__test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpmanp8vu__test.go:40:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpmanp8vu__test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    i, j := 0, 0\n    for\
    \ k, _ := range dict {\n        if is_lower(k) {\n            i++\n        } else\
    \ if is_upper(k) {\n            j++\n        } else {\n            return false\n\
    \        }\n    }\n    if i + j == len(dict) {\n        return true\n    }\n \
    \   return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpculiyn8l_test.go:20:12: undefined: is_lower

    /tmp/tmpculiyn8l_test.go:22:19: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    keys := make([]string,\
    \ len(dict))\n    i := 0\n    for k := range dict {\n        keys[i] = k\n   \
    \     i++\n    }\n    if len(keys) == 0 {\n        return false\n    }\n    s\
    \ := keys[0]\n    if s == strings.ToUpper(s) {\n        uppercase := true\n  \
    \      for _, k := range keys {\n            if k != strings.ToUpper(k) {\n  \
    \              uppercase = false\n                break\n            }\n     \
    \   }\n        return uppercase\n    } else if s == strings.ToLower(s) {\n   \
    \     lowercase := true\n        for _, k := range keys {\n            if k !=\
    \ strings.ToLower(k) {\n                lowercase = false\n                break\n\
    \            }\n        }\n        return lowercase\n    }\n    return false\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4l8sic0e_test.go:28:13: undefined: strings

    /tmp/tmp4l8sic0e_test.go:31:21: undefined: strings

    /tmp/tmp4l8sic0e_test.go:37:20: undefined: strings

    /tmp/tmp4l8sic0e_test.go:40:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    upper := true\n    lower := true\n    for k,\
    \ _ := range dict {\n        _, upper = dict[strings.ToUpper(k)]\n        _, lower\
    \ = dict[strings.ToLower(k)]\n        if !(upper || lower) {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyer8t0j1_test.go:24:25: undefined: strings

    /tmp/tmpyer8t0j1_test.go:25:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    switch(len(dict)) {\n\
    \        case 0:\n            return false\n        case 1:\n            return\
    \ true\n    }\n    // for i, v := range dict {\n    //     if i {\n    //    \
    \     if i != v {\n    //             return false\n    //         }\n    // \
    \    }\n    // }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpe4agh6cd_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpe4agh6cd_test.go:53:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpe4agh6cd_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    // First, check if the\
    \ given dictionary is empty\n    if len(dict) == 0 {\n        return false\n \
    \   }\n\n    // Check whether all keys are strings in lower case\n    lower_case\
    \ := true\n    for key, _ := range dict {\n        if key == key {\n         \
    \   lower_case = false\n            break\n        }\n    }\n\n    // Check whether\
    \ all keys are strings in upper case\n    upper_case := true\n    for key, _ :=\
    \ range dict {\n        if key == key {\n            upper_case = false\n    \
    \        break\n        }\n    }\n\n    return lower_case || upper_case\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpfxc0h95k_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpfxc0h95k_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpfxc0h95k_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    for k, _ := range dict {\n        if len(k)\
    \ > 0 {\n            if k[0] >= 'a' && k[0] <= 'z' {\n                for i :=\
    \ 1; i < len(k); i++ {\n                    if k[i] < 'a' || k[i] > 'z' {\n  \
    \                      return false\n                    }\n                }\n\
    \            } else if k[0] >= 'A' && k[0] <= 'Z' {\n                for i :=\
    \ 1; i < len(k); i++ {\n                    if k[i] < 'A' || k[i] > 'Z' {\n  \
    \                      return false\n                    }\n                }\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmp85z89v2g_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    // if the dictionary\
    \ is empty, return false\n    if len(dict) == 0 {\n        return false\n    }\n\
    \    // check all the keys to see if they are all upper or lower\n    upper :=\
    \ true\n    lower := true\n    for k, _ := range dict {\n        if !is_upper(k)\
    \ {\n            upper = false\n        }\n        if !is_lower(k) {\n       \
    \     lower = false\n        }\n    }\n    return upper || lower\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwmqogatu_test.go:26:13: undefined: is_upper

    /tmp/tmpwmqogatu_test.go:29:13: undefined: is_lower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    lower := true\n    upper := true\n    for key,\
    \ _ := range dict {\n        if key != strings.ToLower(key) {\n            lower\
    \ = false\n        }\n        if key != strings.ToUpper(key) {\n            upper\
    \ = false\n        }\n    }\n    return lower || upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6mfmso_h_test.go:24:19: undefined: strings

    /tmp/tmp6mfmso_h_test.go:27:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a dictionary, return True if all keys are strings in lower \n\
    // case or all keys are strings in upper case, else return False.\n// The function\
    \ should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"\
    a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"\
    a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    // check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    case_of_first_char := \"\"\n    all_upper :=\
    \ true\n    all_lower := true\n    for k, v := range dict {\n        if len(k)\
    \ > 0 {\n            if case_of_first_char == \"\" {\n                if 'A' <=\
    \ k[0] && k[0] <= 'Z' {\n                    case_of_first_char = \"upper\"\n\
    \                } else {\n                    case_of_first_char = \"lower\"\n\
    \                }\n            }\n            if !(('A' <= k[0] && k[0] <= 'Z')\
    \ || ('a' <= k[0] && k[0] <= 'z')) {\n                fmt.Printf(\"Invalid key\
    \ %s found in dictionary.\\n\", k)\n                return false\n           \
    \ }\n            if case_of_first_char == \"upper\" {\n                if 'a'\
    \ <= k[0] && k[0] <= 'z' {\n                    all_upper = false\n          \
    \      }\n            } else {\n                if 'A' <= k[0] && k[0] <= 'Z'\
    \ {\n                    all_lower = false\n                }\n            }\n\
    \        } else {\n            fmt.Printf(\"Invalid key %s found in dictionary.\\\
    n\", k)\n            return false\n        }\n        fmt.Printf(\"Key %s has\
    \ value %s\\n\", k, v)\n    }\n    return all_upper || all_lower\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Key p has value pineapple\nKey b has value banana\nKey p has value pineapple\n\
    Key A has value banana\nKey B has value banana\nKey p has value pineapple\nInvalid\
    \ key 5 found in dictionary.\nKey Name has value John\nKey Age has value 36\n\
    Key City has value Houston\nKey STATE has value NC\nKey ZIP has value 12345\n\
    Key fruit has value Orange\nKey taste has value Sweet\n--- FAIL: TestCheck_Dict_Case\
    \ (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmphl6ofr8t_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmphl6ofr8t_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074943
