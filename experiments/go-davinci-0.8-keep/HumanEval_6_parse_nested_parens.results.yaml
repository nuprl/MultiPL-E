language: go_test.go
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    for _, group := range split_by_space(paren_string)\
    \ {\n        results = append(results, get_max_nesting_level(group))\n    }\n\
    \    return results\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqx_flb07_test.go:15:27: undefined: split_by_space

    /tmp/tmpqx_flb07_test.go:16:35: undefined: get_max_nesting_level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074368
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    max_depth := 0\n    result := []int{}\n\
    \    for _, char := range paren_string {\n        switch char {\n        case\
    \ '(':\n            depth += 1\n            if depth > max_depth {\n         \
    \       max_depth = depth\n            }\n        case ')':\n            depth\
    \ -= 1\n        case ' ':\n            result = append(result, max_depth)\n  \
    \          max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    res := make([]int, 0)\n    for _, g := range split_space(paren_string)\
    \ {\n        lvl := 0\n        max_lvl := 0\n        for _, v := range g {\n \
    \           if v == '(' {\n                lvl += 1\n            } else if v ==\
    \ ')' {\n                if lvl > max_lvl {\n                    max_lvl = lvl\n\
    \                }\n                lvl -= 1\n            }\n        }\n     \
    \   res = append(res, max_lvl)\n    }\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnt7gtsb_test.go:15:23: undefined: split_space

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074368
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    curr_depth := 0\n    curr_depth_list\
    \ := []int{}\n    for _, char := range paren_string {\n        switch char {\n\
    \        case '(':\n            curr_depth += 1\n            if curr_depth > max_depth\
    \ {\n                max_depth = curr_depth\n            }\n        case ')':\n\
    \            curr_depth -= 1\n        case ' ':\n            curr_depth_list =\
    \ append(curr_depth_list, max_depth)\n            max_depth = 0\n            curr_depth\
    \ = 0\n        }\n    }\n    if max_depth > 0 {\n        curr_depth_list = append(curr_depth_list,\
    \ max_depth)\n    }\n    return curr_depth_list\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int,\
    \ 0)\n    for i := 0; i < len(paren_string); i++ {\n        switch paren_string[i]\
    \ {\n        case '(':\n            paren_stack = append(paren_stack, len(paren_stack)\
    \ + 1)\n        case ')':\n            paren_list = append(paren_list, paren_stack[len(paren_stack)\
    \ - 1])\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n      \
    \  case ' ':\n            continue\n        }\n    }\n    return paren_list\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmps7tkvq6w_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmps7tkvq6w_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmps7tkvq6w_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var depths []int\n    for _, s := range paren_string {\n\
    \        if s == '(' {\n            dep := 1\n            for _, s := range paren_string\
    \ {\n                if s == '(' {\n                    dep++\n              \
    \  } else if s == ')' {\n                    dep--\n                }\n      \
    \      }\n            depths = append(depths, dep)\n        }\n    }\n    return\
    \ depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpgnq0z9e2_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpgnq0z9e2_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpgnq0z9e2_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := make([]int, 0)\n    paren_string = \" \"\
    \ + paren_string + \" \"\n    for i := 0; i < len(paren_string); i++ {\n     \
    \   if paren_string[i] == ' ' {\n            i += 1\n            j := i\n    \
    \        level := 0\n            for paren_string[j] != ' ' {\n              \
    \  if paren_string[j] == '(' {\n                    level += 1\n             \
    \   } else if paren_string[j] == ')' {\n                    level -= 1\n     \
    \           }\n                j += 1\n            }\n            max_levels =\
    \ append(max_levels, level)\n            i = j\n        }\n    }\n    return max_levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [29] with length 29 [recovered]\n\tpanic: runtime error: index\
    \ out of range [29] with length 29\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x5126a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5126a0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens({0x52239c, 0x1b})\n\t\
    /tmp/tmp87nkij55_test.go:21 +0x185\ncommand-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\
    \t/tmp/tmp87nkij55_test.go:43 +0x4d\ntesting.tRunner(0xc0001321a0, 0x528008)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO(you): Add code here to complete the task.\n   \
    \ // NOTE: The value given for max_level is only for convenience.\n    // You\
    \ may or may not need to use it.\n    max_level := 0\n    // Use this `level`\
    \ variable to keep track of the current depth.\n    level := 0\n    // Use this\
    \ `levels` variable to keep track of the maximum depth\n    // at each position.\n\
    \    levels := []int{}\n    for _, c := range paren_string {\n        if c ==\
    \ '(' {\n            level++\n            max_level = max(max_level, level)\n\
    \        } else if c == ')' {\n            level--\n        } else {\n       \
    \     level = max(0, level)\n        }\n        levels = append(levels, max_level)\n\
    \    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe4_wjes0_test.go:26:25: undefined: max

    /tmp/tmpe4_wjes0_test.go:30:21: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_groups := strings.Split(paren_string, \" \")\n  \
    \  max_levels := make([]int, len(paren_groups))\n    for i, paren_group := range\
    \ paren_groups {\n        max_levels[i] = get_max_levels(paren_group)\n    }\n\
    \    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspwy1d0g_test.go:14:21: undefined: strings

    /tmp/tmpspwy1d0g_test.go:17:25: undefined: get_max_levels

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_counts []int\n    var current_paren_count int\n\
    \    var i int\n    for i = 0; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            current_paren_count += 1\n        } else if paren_string[i]\
    \ == ')' {\n            paren_counts = append(paren_counts, current_paren_count)\n\
    \            current_paren_count = 0\n        }\n    }\n    return paren_counts\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp_i290erm_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_i290erm_test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp_i290erm_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []rune\n    var depth int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            stack\
    \ = append(stack, c)\n            depth++\n        } else if c == ')' {\n    \
    \        stack = stack[:len(stack)-1]\n            depth--\n        } else if\
    \ c == ' ' {\n            result = append(result, depth)\n        }\n    }\n \
    \   return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpem6ghx57_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpem6ghx57_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpem6ghx57_test.go:46: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    depth := 0\n    max_depth\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            results = append(results, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    results\
    \ = append(results, max_depth)\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    stack := make([]int, 0)\n    stack_index := 0\n    max_level\
    \ := make([]int, 0)\n    for _, v := range paren_string {\n        if v == '('\
    \ {\n            stack = append(stack, stack_index)\n            stack_index +=\
    \ 1\n        } else if v == ')' {\n            stack = stack[:len(stack)-1]\n\
    \            max_level = append(max_level, stack_index-1)\n            stack_index\
    \ -= 1\n        }\n    }\n    return max_level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp3zy35f9h_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp3zy35f9h_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp3zy35f9h_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_nest := []int{}\n    for _, paren_substring := range\
    \ str_to_substr(paren_string) {\n        max_nest = append(max_nest, find_max_paren_nest(paren_substring))\n\
    \    }\n    return max_nest\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwl2i58bs_test.go:15:37: undefined: str_to_substr

    /tmp/tmpwl2i58bs_test.go:16:37: undefined: find_max_paren_nest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         level++\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if char == ')' {\n            if level\
    \ == max_level {\n                result = append(result, max_level)\n       \
    \         max_level = 0\n            }\n            level--\n        }\n    }\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1m8cmxrh_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp1m8cmxrh_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    const left_paren = \"(\"\n    const right_paren = \")\"\
    \n    // get the max depth of nesting level for each group.\n    var depths []int\n\
    \    var depth int\n    for _, c := range paren_string {\n        if string(c)\
    \ == left_paren {\n            depth += 1\n        } else if string(c) == right_paren\
    \ {\n            depth -= 1\n        } else if c == ' ' {\n            depths\
    \ = append(depths, depth)\n            depth = 0\n        }\n    }\n    return\
    \ depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpu6odifde_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpu6odifde_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpu6odifde_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Fill this up\n    r := make([]int, 0)\n    is_left :=\
    \ false\n    is_right := false\n    r_num := 0\n    for _, s := range paren_string\
    \ {\n        switch s {\n        case '(':\n            if is_left {\n       \
    \         r_num++\n            } else {\n                is_left = true\n    \
    \            r_num = 1\n            }\n        case ')':\n            if is_right\
    \ {\n                if r_num == 0 {\n                    r = append(r, 0)\n \
    \               } else {\n                    r = append(r, r_num)\n         \
    \       }\n                is_right = false\n                is_left = false\n\
    \                r_num = 0\n            } else {\n                is_right = true\n\
    \                r_num--\n            }\n        default:\n            if is_left\
    \ {\n                if r_num == 0 {\n                    r = append(r, 0)\n \
    \               } else {\n                    r = append(r, r_num)\n         \
    \       }\n                is_left = false\n                r_num = 0\n      \
    \      }\n            if is_right {\n                if r_num == 0 {\n       \
    \             r = append(r, 0)\n                } else {\n                   \
    \ r = append(r, r_num)\n                }\n                is_right = false\n\
    \                r_num = 0\n            }\n        }\n    }\n    if is_left {\n\
    \        if r_num == 0 {\n            r = append(r, 0)\n        } else {\n   \
    \         r = append(r, r_num)\n        }\n    }\n    if is_right {\n        if\
    \ r_num == 0 {\n            r = append(r, 0)\n        } else {\n            r\
    \ = append(r, r_num)\n        }\n    }\n    return r\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7h59h3ql_test.go:95: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=-1) %!s(int=2) %!s(int=-1) %!s(int=0)\
    \ %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp7h59h3ql_test.go:95: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=-1)\
    \ %!s(int=3) %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp7h59h3ql_test.go:95: expected '[%!s(int=4)]', got '[%!s(int=3)\
    \ %!s(int=3) %!s(int=-1) %!s(int=-1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074368
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    fmt.Println(\">>>>>> parse_nested_parens\", paren_string)\n\
    \    i := 0\n    res := []int{}\n    max_level := 0\n    level := 0\n    for i\
    \ < len(paren_string) {\n        if paren_string[i] == '(' {\n            level++\n\
    \            if level > max_level {\n                max_level = level\n     \
    \       }\n        } else if paren_string[i] == ')' {\n            level--\n \
    \       } else if paren_string[i] == ' ' {\n            res = append(res, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n        i++\n  \
    \  }\n    res = append(res, max_level)\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // The output array for the result.\n    var output []int\n\
    \n    // The parentheses string split by spaces.\n    paren_list := make([]string,\
    \ 0)\n\n    // Init the paren_list.\n    for _, s := range paren_string {\n  \
    \      fmt.Println(string(s))\n        if string(s) == \" \" {\n            continue\n\
    \        } else {\n            paren_list = append(paren_list, string(s))\n  \
    \      }\n    }\n\n    for i := 0; i < len(paren_list); i++ {\n        // For\
    \ each of the parenthese, assume it has a nested level of 1.\n        // If this\
    \ is not the first character, assume it has the same level as the\n        //\
    \ previous character.\n        if i == 0 {\n            output = append(output,\
    \ 1)\n        } else {\n            output = append(output, output[i-1])\n   \
    \     }\n\n        if paren_list[i] == \"(\" {\n            output[i]++\n    \
    \    }\n    }\n\n    return output\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "(\n(\n)\n(\n)\n)\n \n(\n(\n(\n)\n)\n)\n \n(\n)\n \n(\n(\n(\n)\n)\n(\n)\n\
    (\n)\n)\n(\n)\n \n(\n(\n)\n)\n \n(\n(\n(\n)\n)\n)\n \n(\n(\n(\n(\n)\n)\n)\n)\n\
    (\n(\n)\n(\n(\n)\n)\n(\n(\n(\n)\n)\n)\n)\n--- FAIL: TestParse_Nested_Parens (0.00s)\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpyfezzotz_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)\
    \ %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=11) %!s(int=11) %!s(int=12) %!s(int=12) %!s(int=13) %!s(int=13)\
    \ %!s(int=13)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n \
    \       tmpyfezzotz_test.go:63: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=5)\
    \ %!s(int=6) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=8) %!s(int=9)\
    \ %!s(int=10) %!s(int=11) %!s(int=11) %!s(int=11) %!s(int=11) %!s(int=11)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpyfezzotz_test.go:63:\
    \ expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=5)\
    \ %!s(int=5) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=8)\
    \ %!s(int=8) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_nest := 0\n    nest_counter := 0\n    nest_levels :=\
    \ []int{}\n    for _, rune_char := range paren_string {\n        char := string(rune_char)\n\
    \        if char == \"(\" {\n            nest_counter += 1\n            if nest_counter\
    \ > max_nest {\n                max_nest = nest_counter\n            }\n     \
    \   } else if char == \")\" {\n            nest_counter -= 1\n        } else if\
    \ char == \" \" {\n            nest_levels = append(nest_levels, max_nest)\n \
    \           max_nest = 0\n            nest_counter = 0\n        }\n    }\n   \
    \ nest_levels = append(nest_levels, max_nest)\n    return nest_levels\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074368
