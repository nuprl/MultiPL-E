language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    position := 0\n    found := false\n\
    \    for i, p := range planets {\n        if p == planet1 {\n            position\
    \ = i\n            found = true\n            break\n        }\n    }\n    if !found\
    \ {\n        return make([]interface{}, 0)\n    }\n    found = false\n    for\
    \ i, p := range planets {\n        if p == planet2 {\n            if i > position\
    \ {\n                return planets[position+1:i]\n            } else {\n    \
    \            return planets[i+1:position]\n            }\n        }\n    }\n \
    \   return make([]interface{}, 0)\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6mg_gs6n_test.go:39:31: cannot use planets[position + 1:i] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmp6mg_gs6n_test.go:41:31: cannot use planets[i + 1:position] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpsh9pbpuh_test.go:44: expected '[Saturn Uranus]', got '[Venus Earth Mars\
    \ Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpsh9pbpuh_test.go:44:\
    \ expected '[Venus]', got '[Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpsh9pbpuh_test.go:44: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpsh9pbpuh_test.go:44: expected '[]', got '[Venus Earth Mars\
    \ Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpsh9pbpuh_test.go:44:\
    \ expected '[]', got '[Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__6\
    \ (0.00s)\n        tmpsh9pbpuh_test.go:44: expected '[]', got '[Venus Earth Mars\
    \ Jupiter Saturn]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    orbits := map[string]int{\n        \"Mercury\": 0,\n        \"Venus\"\
    : 1,\n        \"Earth\": 2,\n        \"Mars\": 3,\n        \"Jupiter\": 4,\n \
    \       \"Saturn\": 5,\n        \"Uranus\": 6,\n        \"Neptune\": 7,\n    }\n\
    \    var r []interface{}\n    if orbits[planet1] > orbits[planet2] {\n       \
    \ planet1, planet2 = planet2, planet1\n    }\n    for k, v := range orbits {\n\
    \        if v > orbits[planet1] && v < orbits[planet2] {\n            r = append(r,\
    \ k)\n        }\n    }\n    return r\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__2 (0.00s)\n  \
    \      tmpgxj8e2o7_test.go:63: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Saturn Venus Earth Mars Jupiter]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmpgxj8e2o7_test.go:63: expected '[]', got '[Mars Venus Earth]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return []interface{}{\"Mercury\", \"Venus\"\
    }\n        case \"Earth\":\n            return []interface{}{\"Mercury\", \"Venus\"\
    , \"Earth\"}\n        case \"Mars\":\n            return []interface{}{\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\"}\n        case \"Jupiter\":\n            return\
    \ []interface{}{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n  \
    \      case \"Saturn\":\n            return []interface{}{\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n        case \"Uranus\":\n  \
    \          return []interface{}{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"}\n        case \"Neptune\":\n            return\
    \ []interface{}{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n        }\n    case \"Venus\":\n        switch planet2\
    \ {\n        case \"Earth\":\n            return []interface{}{\"Venus\", \"Earth\"\
    }\n        case \"Mars\":\n            return []interface{}{\"Venus\", \"Earth\"\
    , \"Mars\"}\n        case \"Jupiter\":\n            return []interface{}{\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\"}\n        case \"Saturn\":\n            return\
    \ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n   \
    \     case \"Uranus\":\n            return []interface{}{\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\n        case \"Neptune\":\n\
    \            return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n        }\n    case \"Earth\":\n     \
    \   switch planet2 {\n        case \"Mars\":\n            return []interface{}{\"\
    Earth\", \"Mars\"}\n        case \"Jupiter\":\n            return []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\"}\n        case \"Sat\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp20co2voo_test.go:61:14: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            p1 =\
    \ i\n        }\n        if planet == planet2 {\n            p2 = i\n        }\n\
    \    }\n    if p1 == -1 || p2 == -1 {\n        return []interface{}{}\n    }\n\
    \    lower := p1\n    higher := p2\n    if p1 > p2 {\n        lower = p2\n   \
    \     higher = p1\n    }\n    planets = planets[lower+1:higher]\n    return []interface{}{planets}\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of range [3:2]\n\
    \ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x5137e0, 0xc000164000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5137e0,\
    \ 0xc000164000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf({0x51e68f, 0x5}, {0x51e68f, 0x5})\n\t\
    /tmp/tmp6saxi4vk_test.go:42 +0x318\ncommand-line-arguments_test.TestBf(0x0?)\n\
    \t/tmp/tmp6saxi4vk_test.go:57 +0x145\ntesting.tRunner(0xc000103860, 0x529130)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    var ret []interface{}\n\n    if planet1 == \"Earth\" {\n        ret =\
    \ append(ret, \"Venus\")\n    } else if planet1 == \"Jupiter\" {\n        ret\
    \ = append(ret, \"Saturn\")\n    } else if planet1 == \"Mercury\" {\n        ret\
    \ = append(ret, \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n   \
    \ }\n\n    if planet2 == \"Jupiter\" {\n        ret = append(ret, \"Saturn\")\n\
    \    } else if planet2 == \"Mercury\" {\n        ret = append(ret, \"Venus\")\n\
    \    }\n\n    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmppcla7heq_test.go:60: expected '[Saturn Uranus]', got '[Saturn]'\n  \
    \  --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppcla7heq_test.go:60: expected\
    \ '[Venus]', got '[Venus Venus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n \
    \       tmppcla7heq_test.go:60: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmppcla7heq_test.go:60:\
    \ expected '[]', got '[Venus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n   \
    \     tmppcla7heq_test.go:60: expected '[]', got '[Saturn]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{ \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n    var result []interface{}\n\
    \n    if !contains(planets, planet1) || !contains(planets, planet2) {\n      \
    \  return result\n    }\n\n    if indexOf(planets, planet1) < indexOf(planets,\
    \ planet2) {\n        result = append(result, planet1)\n        result = append(result,\
    \ planets[indexOf(planets, planet1) + 1:indexOf(planets, planet2)]...)\n     \
    \   result = append(result, planet2)\n    } else {\n        result = append(result,\
    \ planet2)\n        result = append(result, planets[indexOf(planets, planet2)\
    \ + 1:indexOf(planets, planet1)]...)\n        result = append(result, planet1)\n\
    \    }\n\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjt8hv8ij_test.go:25:9: undefined: contains

    /tmp/tmpjt8hv8ij_test.go:29:8: undefined: indexOf

    /tmp/tmpjt8hv8ij_test.go:31:40: cannot use planets[indexOf(planets, planet1) +
    1:indexOf(planets, planet2)] (value of type []string) as type []interface{} in
    argument to append

    /tmp/tmpjt8hv8ij_test.go:31:41: undefined: indexOf

    /tmp/tmpjt8hv8ij_test.go:35:40: cannot use planets[indexOf(planets, planet2) +
    1:indexOf(planets, planet1)] (value of type []string) as type []interface{} in
    argument to append

    /tmp/tmpjt8hv8ij_test.go:35:41: undefined: indexOf

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Write your code here\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn5iwyo9__test.go:23:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    var planets = map[string]bool{\n        \"Mercury\": true, \"Venus\"\
    : true, \"Earth\": true,\n        \"Mars\": true, \"Jupiter\": true, \"Saturn\"\
    : true,\n        \"Uranus\": true, \"Neptune\": true,\n    }\n    if !planets[planet1]\
    \ || !planets[planet2] {\n        return []interface{}{}\n    }\n    var order\
    \ = map[string]int{\n        \"Mercury\": 1, \"Venus\": 2, \"Earth\": 3,\n   \
    \     \"Mars\": 4, \"Jupiter\": 5, \"Saturn\": 6,\n        \"Uranus\": 7, \"Neptune\"\
    : 8,\n    }\n    var start, end int\n    if order[planet1] < order[planet2] {\n\
    \        start = order[planet1]\n        end = order[planet2]\n    } else {\n\
    \        start = order[planet2]\n        end = order[planet1]\n    }\n    var\
    \ res []interface{}\n    for i := start + 1; i < end; i++ {\n        for planet,\
    \ order := range order {\n            if order == i {\n                res = append(res,\
    \ planet)\n            }\n        }\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n\tplanets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n\tindices := []int{}\n\tfor i, planet\
    \ := range planets {\n\t\tif planet == planet1 || planet == planet2 {\n\t\t\t\
    indices = append(indices, i)\n\t\t}\n\t}\n\tif len(indices) == 0 {\n\t\treturn\
    \ []interface{}{}\n\t} else if len(indices) == 1 {\n\t\treturn []interface{}{planets[indices[0]]}\n\
    \t} else {\n\t\tif indices[0] > indices[1] {\n\t\t\treturn []interface{}{}\n\t\
    \t} else {\n\t\t\treturn []interface{}{planets[indices[0]+1:indices[1]]}\n\t\t\
    }\n\t}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpp6qnnbis_test.go:61: expected '[Saturn Uranus]', got '[[Saturn Uranus]]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpp6qnnbis_test.go:61: expected\
    \ '[Venus]', got '[[Venus]]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n     \
    \   tmpp6qnnbis_test.go:61: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[[Venus Earth Mars Jupiter Saturn]]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n\
    \        tmpp6qnnbis_test.go:61: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[[Earth Mars Jupiter Saturn Uranus]]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpp6qnnbis_test.go:61: expected '[]', got '[Earth]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpp6qnnbis_test.go:61: expected '[]',\
    \ got '[[]]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpp6qnnbis_test.go:61:\
    \ expected '[]', got '[Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    var planets = []string{\n        \"Mercury\",\n        \"Venus\",\n \
    \       \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\"\
    ,\n        \"Uranus\",\n        \"Neptune\",\n    }\n    var ret []interface{}\n\
    \n    var i, j int\n    var found1, found2 bool\n    for i = 0; i < len(planets);\
    \ i++ {\n        if planets[i] == planet1 {\n            found1 = true\n     \
    \       break\n        }\n    }\n    for j = 0; j < len(planets); j++ {\n    \
    \    if planets[j] == planet2 {\n            found2 = true\n            break\n\
    \        }\n    }\n    if !found1 || !found2 {\n        return ret\n    }\n\n\
    \    if i < j {\n        ret = planets[i+1:j]\n    } else {\n        ret = planets[j+1:i]\n\
    \    }\n    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpci9sijcf_test.go:53:22: cannot use planets[i + 1:j] (value of type []string)
    as type []interface{} in assignment

    /tmp/tmpci9sijcf_test.go:55:22: cannot use planets[j + 1:i] (value of type []string)
    as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n\tvar planets []string = []string{\n\t\t\"Mercury\",\n\t\t\"Venus\",\n\t\t\
    \"Earth\",\n\t\t\"Mars\",\n\t\t\"Jupiter\",\n\t\t\"Saturn\",\n\t\t\"Uranus\",\n\
    \t\t\"Neptune\",\n\t}\n\tvar index1, index2 int\n\tfor index, v := range planets\
    \ {\n\t\tif v == planet1 {\n\t\t\tindex1 = index\n\t\t}\n\t\tif v == planet2 {\n\
    \t\t\tindex2 = index\n\t\t}\n\t}\n\tvar res []interface{}\n\tif index1 > index2\
    \ {\n\t\tfor i := index2 + 1; i < index1; i++ {\n\t\t\tres = append(res, planets[i])\n\
    \t\t}\n\t} else {\n\t\tfor i := index1 + 1; i < index2; i++ {\n\t\t\tres = append(res,\
    \ planets[i])\n\t\t}\n\t}\n\treturn res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2geox9ce_test.go:73: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    var planetPos int\n    switch planet1 {\n        case \"Mercury\": planetPos\
    \ = 0\n        case \"Venus\": planetPos = 1\n        case \"Earth\": planetPos\
    \ = 2\n        case \"Mars\": planetPos = 3\n        case \"Jupiter\": planetPos\
    \ = 4\n        case \"Saturn\": planetPos = 5\n        case \"Uranus\": planetPos\
    \ = 6\n        case \"Neptune\": planetPos = 7\n        default: return []interface{}{}\n\
    \    }\n    switch planet2 {\n        case \"Mercury\": planetPos = 0\n      \
    \  case \"Venus\": planetPos = 1\n        case \"Earth\": planetPos = 2\n    \
    \    case \"Mars\": planetPos = 3\n        case \"Jupiter\": planetPos = 4\n \
    \       case \"Saturn\": planetPos = 5\n        case \"Uranus\": planetPos = 6\n\
    \        case \"Neptune\": planetPos = 7\n        default: return []interface{}{}\n\
    \    }\n    var ret []interface{}\n    for i := planetPos; i < planetPos; i++\
    \ {\n        switch i {\n            case 0: ret = append(ret, \"Mercury\")\n\
    \            case 1: ret = append(ret, \"Venus\")\n            case 2: ret = append(ret,\
    \ \"Earth\")\n            case 3: ret = append(ret, \"Mars\")\n            case\
    \ 4: ret = append(ret, \"Jupiter\")\n            case 5: ret = append(ret, \"\
    Saturn\")\n            case 6: ret = append(ret, \"Uranus\")\n            case\
    \ 7: ret = append(ret, \"Neptune\")\n        }\n    }\n    return ret\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpwo4vlsx9_test.go:80: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpwo4vlsx9_test.go:80: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpwo4vlsx9_test.go:80:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpwo4vlsx9_test.go:80: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    pl := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    r := make([]interface{}, 0)\n    if\
    \ planet1 == planet2 {\n        return r\n    }\n    c1 := -1\n    c2 := -1\n\
    \    for i, p := range pl {\n        if p == planet1 {\n            c1 = i\n \
    \       }\n        if p == planet2 {\n            c2 = i\n        }\n    }\n \
    \   if c1 == -1 || c2 == -1 {\n        return r\n    }\n    a := 0\n    b := 0\n\
    \    if c1 < c2 {\n        a = c1 + 1\n        b = c2\n    } else {\n        a\
    \ = c2 + 1\n        b = c1\n    }\n    for i := a; i < b; i++ {\n        r = append(r,\
    \ pl[i])\n    }\n    return r\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            p1 = i\n      \
    \  }\n        if v == planet2 {\n            p2 = i\n        }\n    }\n    if\
    \ p1 < 0 || p2 < 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n\
    \        planets[p1], planets[p2] = planets[p2], planets[p1]\n        p1, p2 =\
    \ p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdnkl9l6s_test.go:40:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    positions := []int{}\n    result :=\
    \ []interface{}{}\n    for i, p := range planets {\n        if p == planet1 ||\
    \ p == planet2 {\n            positions = append(positions, i)\n        }\n  \
    \  }\n    if len(positions) != 2 {\n        return result\n    }\n    if positions[0]\
    \ > positions[1] {\n        positions[0], positions[1] = positions[1], positions[0]\n\
    \    }\n    for i := positions[0]+1; i < positions[1]; i++ {\n        result =\
    \ append(result, planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planerNames := map[string]int{\n        \"Mercury\": 0,\n        \"Venus\"\
    : 1,\n        \"Earth\": 2,\n        \"Mars\": 3,\n        \"Jupiter\": 4,\n \
    \       \"Saturn\": 5,\n        \"Uranus\": 6,\n        \"Neptune\": 7,\n    }\n\
    \    planetsInRange := []interface{}{}\n    planet1Index, _ := planerNames[planet1]\n\
    \    planet2Index, _ := planerNames[planet2]\n    for i := planet1Index; i <=\
    \ planet2Index; i++ {\n        for name, index := range planerNames {\n      \
    \      if index == i {\n                planetsInRange = append(planetsInRange,\
    \ name)\n            }\n        }\n    }\n    return planetsInRange\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpaz6n8l5z_test.go:64: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpaz6n8l5z_test.go:64:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpaz6n8l5z_test.go:64: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpaz6n8l5z_test.go:64: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpaz6n8l5z_test.go:64:\
    \ expected '[]', got '[Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    ind1 := -1\n    ind2 := -1\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            ind1 = i\n \
    \       }\n        if v == planet2 {\n            ind2 = i\n        }\n    }\n\
    \    if ind1 < 0 || ind2 < 0 {\n        return make([]interface{}, 0)\n    }\n\
    \    if ind1 == ind2 {\n        return []interface{}{planets[ind1]}\n    }\n \
    \   if ind1 > ind2 {\n        ind1, ind2 = ind2, ind1\n    }\n    return planets[ind1+1:ind2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfa_2s6o8_test.go:42:19: cannot use planets[ind1 + 1:ind2] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            p1 = i\n      \
    \  }\n        if p == planet2 {\n            p2 = i\n        }\n    }\n    if\
    \ p1 == -1 || p2 == -1 {\n        return []interface{}{}\n    }\n    if p1 > p2\
    \ {\n        t := p1\n        p1 = p2\n        p2 = t\n    }\n    ret := []interface{}{}\n\
    \    for i := p1 + 1; i < p2; i++ {\n        ret = append(ret, planets[i])\n \
    \   }\n    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planets := map[string]string{\n        \"mercury\": \"mercury\",\n  \
    \      \"venus\": \"venus\",\n        \"earth\": \"earth\",\n        \"mars\"\
    : \"mars\",\n        \"jupiter\": \"jupiter\",\n        \"saturn\": \"saturn\"\
    ,\n        \"uranus\": \"uranus\",\n        \"neptune\": \"neptune\",\n    }\n\
    \    planets_arr := []string{\n        \"mercury\", \"venus\", \"earth\", \"mars\"\
    , \"jupiter\", \"saturn\", \"uranus\", \"neptune\",\n    }\n    if _, ok := planets[planet1];\
    \ !ok {\n        return []interface{}{}\n    }\n    if _, ok := planets[planet2];\
    \ !ok {\n        return []interface{}{}\n    }\n    planet1_index := 0\n    planet2_index\
    \ := 0\n    for i, v := range planets_arr {\n        if v == planet1 {\n     \
    \       planet1_index = i\n        }\n        if v == planet2 {\n            planet2_index\
    \ = i\n        }\n    }\n    if planet1_index > planet2_index {\n        planets_arr[planet1_index],\
    \ planets_arr[planet2_index] = planets_arr[planet2_index], planets_arr[planet1_index]\n\
    \    }\n    return planets_arr[planet1_index+1:planet2_index]\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl22bbf5q_test.go:54:23: cannot use planets_arr[planet1_index + 1:planet2_index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
