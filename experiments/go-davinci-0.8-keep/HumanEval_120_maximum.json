{
  "name": "HumanEval_120_maximum",
  "language": "go_test.go",
  "prompt": "package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given an array arr of integers and a positive integer k, return a sorted list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// Input: arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// Example 2:\n// Input: arr = [4, -4, 4], k = 2\n// Output: [4, 4]\n// Example 3:\n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n",
  "tests": "func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "completions": [
    "    n := len(arr)\n    if n == 0 {\n        return []int{}\n    }\n    m := make([]int, n)\n    for i := 0; i < n; i++ {\n        m[i] = arr[i]\n    }\n    for i := 0; i < k; i++ {\n        for j := 0; j < n - i - 1; j++ {\n            if m[j] < m[j + 1] {\n                m[j], m[j + 1] = m[j + 1], m[j]\n            }\n        }\n    }\n    ret := make([]int, k)\n    for i := 0; i < k; i++ {\n        ret[i] = m[i]\n    }\n    return ret\n}\n",
    "    var idx int\n    for i := 1; i < k; i++ {\n        idx = i\n        for j := i; j < len(arr); j++ {\n            if arr[j] > arr[idx] {\n                idx = j\n            }\n        }\n        arr[i], arr[idx] = arr[idx], arr[i]\n    }\n    return arr[:k]\n}\n",
    "    return nil\n}\n",
    "    if len(arr) == 0 || k == 0 {\n        return nil\n    }\n    m := make(map[int]bool)\n    for _, v := range arr {\n        m[v] = true\n    }\n    //fmt.Println(m)\n    r := make([]int, len(m))\n    var i int\n    for _, v := range m {\n        if v {\n            r[i] = v\n            i++\n        }\n    }\n    //fmt.Println(r)\n    //fmt.Println(r[:k])\n    return r[:k]\n}\n",
    "    if len(arr) <= k {\n        return arr\n    }\n    n := len(arr)\n    var stk []int\n    for i := 0; i < n; i++ {\n        for len(stk) > 0 && arr[i] > stk[len(stk)-1] && len(stk) + n - i - 1 >= k {\n            stk = stk[:len(stk)-1]\n        }\n        if len(stk) < k {\n            stk = append(stk, arr[i])\n        }\n    }\n    return stk\n}\n",
    "    var n = len(arr)\n    if n == k { return arr }\n    var result = make([]int, k)\n    var idx = 0\n    var j = 0\n    var i = 0\n    // skip the first 0 ~ (k - n) elements\n    for j < n {\n        if arr[j] < 0 {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    // skip the last (n - k) ~ (n - 1) elements\n    for j < n {\n        if arr[n - 1 - j] > 0 {\n            i++\n            j++\n        } else {\n            break\n        }\n    }\n    // copy the (k - i) ~ (n - i - 1) elements to result\n    for idx < k {\n        result[idx] = arr[i]\n        idx++\n        i++\n    }\n    // sort result\n    for idx = 1; idx < k; idx++ {\n        var val = result[idx]\n        var j = idx - 1\n        for j >= 0 && result[j] < val {\n            result[j + 1] = result[j]\n            j--\n        }\n        result[j + 1] = val\n    }\n    return result\n}\n",
    "    n := len(arr)\n    if n == k {\n        return arr\n    }\n    heap := arr[:k]\n    for i := k / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := k; i < n; i++ {\n        if arr[i] > heap[0] {\n            heap[0] = arr[i]\n            heapify(heap, 0, k)\n        }\n    }\n    return heap\n}\n",
    "    var q []int\n    for i := 0; i < len(arr); i++ {\n        for len(q) > 0 && q[len(q)-1] < arr[i] && len(q)-1+len(arr)-i >= k {\n            q = q[:len(q)-1]\n        }\n        if len(q) < k {\n            q = append(q, arr[i])\n        }\n    }\n    return q\n}\n",
    "    // get max K numbers\n    // bubble sort\n    for i := 0; i < k; i++ {\n        for j := i; j < len(arr); j++ {\n            if arr[i] < arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n    return arr[:k]\n}\n",
    "    n := len(arr)\n    if n == k {\n        return arr\n    }\n    result := make([]int, k)\n    for i := 0; i < k; i++ {\n        max := arr[0]\n        for j := 0; j < n; j++ {\n            if arr[j] > max {\n                max = arr[j]\n            }\n        }\n        result[i] = max\n        for j := 0; j < n; j++ {\n            if arr[j] == max {\n                arr[j] = -1000000000\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    // using merge sort to find the kth largest element\n    // because it can guarante the kth largest element is smaller than any other elements\n    m := mergeSort(arr)\n    return m[len(m)-k:]\n}\n",
    "    if len(arr) == k {\n        return arr\n    }\n    var result []int\n    for i := 0; i < k; i++ {\n        maxIndex := -1\n        for j := i; j < len(arr); j++ {\n            if maxIndex == -1 || arr[j] > arr[maxIndex] {\n                maxIndex = j\n            }\n        }\n        result = append(result, arr[maxIndex])\n        arr = append(arr[:maxIndex], arr[maxIndex+1:]...)\n    }\n    return result\n}\n",
    "    n := len(arr)\n    if n == 0 {\n        return []int{}\n    }\n    max := make([]int, k)\n    for i := 0; i < k; i++ {\n        max[i] = -1000\n    }\n    for i := 0; i < n; i++ {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n            heapify(max, 0)\n        }\n    }\n    return max\n}\n",
    "    // check args\n    if arr == nil || len(arr) == 0 || k <= 0 || k > len(arr) {\n        return nil\n    }\n    // sort\n    arr = maxHeapSort(arr)\n    // return first k elements\n    return arr[:k]\n}\n",
    "    // initialize a empty result\n    res := make([]int, 0)\n    // traverse the array and add a max number to the result,\n    // and the length of result is k\n    for i := 0; i < k; i++ {\n        if len(arr) == 0 {\n            break\n        }\n        max := arr[0]\n        start := 0\n        for i := 0; i < len(arr); i++ {\n            if arr[i] > max {\n                max = arr[i]\n                start = i\n            }\n        }\n        res = append(res, max)\n        arr = append(arr[:start], arr[start+1:]...)\n    }\n    return res\n}\n",
    "    var res []int\n    if k == 0 {\n        return res\n    }\n    for i := 0; i < len(arr); i++ {\n        for len(res) > 0 && len(res) + len(arr) - i > k && res[len(res) - 1] < arr[i] {\n            res = res[:len(res) - 1]\n        }\n        if len(res) < k {\n            res = append(res, arr[i])\n        }\n    }\n    return res\n}\n",
    "    n := len(arr)\n    if n == 0 {\n        return nil\n    }\n    if k == 0 {\n        return []int{}\n    }\n    if k == n {\n        return arr\n    }\n    if k > n {\n        return nil\n    }\n    var temp []int\n    var result []int\n    for i := 0; i < n; i++ {\n        if len(temp) < k {\n            temp = append(temp, arr[i])\n            for j := len(temp) - 1; j > 0; j-- {\n                if temp[j] > temp[j - 1] {\n                    temp[j], temp[j - 1] = temp[j - 1], temp[j]\n                } else {\n                    break\n                }\n            }\n        } else {\n            if arr[i] > temp[0] {\n                temp[0] = arr[i]\n                for j := 1; j < k; j++ {\n                    if temp[j] > temp[j - 1] {\n                        temp[j], temp[j - 1] = temp[j - 1], temp[j]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < k; i++ {\n        result = append(result, temp[i])\n    }\n    return result\n}\n",
    "    // \u7ef4\u62a4\u4e00\u4e2a\u53ea\u5305\u542b\u6700\u5927\u503c\u7684\u8f85\u52a9\u6570\u7ec4\uff0c\u7528\u4e8e\u6bd4\u8f83\u5927\u5c0f\n    // \u5177\u4f53\u6765\u8bf4\uff0c\u6bcf\u4e00\u6b21\u5224\u65ad\u4e00\u4e2a\u65b0\u7684\u6570\uff0c\u5982\u679c\u8f85\u52a9\u6570\u7ec4\u4e3a\u7a7a\uff0c\u5c31\u76f4\u63a5\u63d2\u5165\n    // \u5982\u679c\u4e0d\u4e3a\u7a7a\uff0c\u5c31\u548c\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u6bd4\u8f83\u5927\u5c0f\uff0c\u5982\u679c\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5c0f\u4e8e\u5f53\u524d\u5143\u7d20\uff0c\n    // \u5c31\u5c06\u8be5\u5143\u7d20\u63d2\u5165\u5230\u8f85\u52a9\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u7ee7\u7eed\u548c\u7b2c\u4e00\u4e2a\u5143\u7d20\u6bd4\u8f83\uff0c\u76f4\u5230\u8f85\u52a9\u6570\u7ec4\u957f\u5ea6\n    // \u5927\u4e8e\u7b49\u4e8ek\uff0c\u5219\u8fd4\u56de\u6570\u7ec4\n    if k >= len(arr) {\n        return arr\n    }\n    auxiliary := make([]int, 0)\n    for i := 0; i < len(arr); i++ {\n        if len(auxiliary) == 0 {\n            auxiliary = append(auxiliary, arr[i])\n        } else {\n            if auxiliary[len(auxiliary) - 1] < arr[i] {\n                auxiliary = append(auxiliary, arr[i])\n            } else {\n                for j := 0; j < len(auxiliary); j++ {\n                    if auxiliary[j] > arr[i] {\n                        auxiliary = append(auxiliary, 0)\n                        copy(auxiliary[j + 1:], auxiliary[j:])\n                        auxiliary[j] = arr[i]\n                        break\n                    }\n                }\n            }\n        }\n",
    "    // TODO\n    return nil\n}\n",
    "    var (\n        heap []int\n        ret []int\n    )\n    for _, v := range arr {\n        if len(heap) < k {\n            heap = append(heap, v)\n            siftUp(heap, len(heap) - 1)\n        } else if v > heap[0] {\n            heap[0] = v\n            siftDown(heap, 0)\n        }\n    }\n    for i := len(heap) - 1; i >= 0; i-- {\n        ret = append(ret, heap[0])\n        heap[0] = heap[i]\n        heap = heap[:i]\n        siftDown(heap, 0)\n    }\n    return ret\n}\n"
  ],
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ]
}