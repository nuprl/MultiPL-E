language: go_test.go
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpfvlyhg2x_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpfvlyhg2x_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpfvlyhg2x_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpfvlyhg2x_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073841
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var current_paren_groups string\n    var paren_groups []string\n    if\
    \ len(paren_string) == 0 {\n        return paren_groups\n    }\n    for i, char\
    \ := range paren_string {\n        if char == ' ' {\n            continue\n  \
    \      }\n        if char == '(' {\n            current_paren_groups += \"(\"\n\
    \        } else if char == ')' {\n            current_paren_groups += \")\"\n\
    \            if (is_balanced(current_paren_groups)) {\n                paren_groups\
    \ = append(paren_groups, current_paren_groups)\n                current_paren_groups\
    \ = \"\"\n            }\n        }\n    }\n    return paren_groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplsfqnvsz_test.go:20:9: i declared but not used

    /tmp/tmplsfqnvsz_test.go:28:17: undefined: is_balanced

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073999
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    rv := make([]string, 0)\n    paren_count := 0\n    last_paren_index :=\
    \ 0\n    for i, ch := range paren_string {\n        if ch == '(' {\n         \
    \   paren_count++\n        } else if ch == ')' {\n            paren_count--\n\
    \        }\n        if paren_count == 0 {\n            rv = append(rv, paren_string[last_paren_index:i+1])\n\
    \            last_paren_index = i+1\n        }\n    }\n    return rv\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmplxixkhmo_test.go:48: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())   ((()))   ()   ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmplxixkhmo_test.go:48: expected '[() (()) ((())) (((())))]',\
    \ got '[()   (())   ((()))   (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmplxixkhmo_test.go:48: expected '[() (()) (()())]', got '[(\
    \ )   (( ))   (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpfvlyhg2x_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpfvlyhg2x_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpfvlyhg2x_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpfvlyhg2x_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073841
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpfvlyhg2x_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpfvlyhg2x_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpfvlyhg2x_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpfvlyhg2x_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073841
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var res []string\n    var partial_group string\n    balanced := 0\n \
    \   for _, c := range paren_string {\n        if c == '(' {\n            partial_group\
    \ += string(c)\n            balanced++\n        } else if c == ')' {\n       \
    \     partial_group += string(c)\n            balanced--\n            if balanced\
    \ == 0 {\n                res = append(res, partial_group)\n                partial_group\
    \ = \"\"\n            }\n        }\n    }\n    return res\n}\n\n//Tests\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    groups := make([]string, 0)\n    group := \"\"\n    parens := 0\n   \
    \ for _, char := range paren_string {\n        if char == '(' {\n            parens++\n\
    \        } else if char == ')' {\n            parens--\n        }\n        if\
    \ parens == 0 {\n            groups = append(groups, group)\n            group\
    \ = \"\"\n        } else {\n            group += string(char)\n        }\n   \
    \ }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpqzy37dtv_test.go:50: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()  ((())  (  ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpqzy37dtv_test.go:50: expected '[() (()) ((())) (((())))]',\
    \ got '[(  (()  ((())  (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpqzy37dtv_test.go:50: expected '[(()(())((())))]', got '[(()(())((()))]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpqzy37dtv_test.go:50:\
    \ expected '[() (()) (()())]', got '[(   (( )  (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n\t\n\t// 1) Create a data \nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy3oq32jx_test.go:17:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073999
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    if len(paren_string) == 0 {\n        return []string{}\n    }\n    var\
    \ total int\n    for _, x := range paren_string {\n        if x == '(' {\n   \
    \         total++\n        } else if x == ')' {\n            total--\n       \
    \ }\n    }\n    if total != 0 {\n        return []string{}\n    }\n    var result\
    \ []string\n    var current string\n    for _, x := range paren_string {\n   \
    \     if x == '(' {\n            current += string(x)\n        } else if x ==\
    \ ')' {\n            current += string(x)\n            result = append(result,\
    \ current)\n            current = \"\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmppq57kuqs_test.go:59: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ) ((() ) ) () ((() ) () () )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmppq57kuqs_test.go:59: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ) ((() ) ) (((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmppq57kuqs_test.go:59: expected '[(()(())((())))]', got '[(()\
    \ (() ) ((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmppq57kuqs_test.go:59: expected '[() (()) (()())]', got '[() (() ) (()\
    \ () )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // TODO: Implement this\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmplva26avf_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmplva26avf_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmplva26avf_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmplva26avf_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    var i int\n    begin := 0\n    for i = 0; i\
    \ < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n          \
    \  if paren_string[i + 1] == ' ' {\n                continue\n            }\n\
    \            begin = i\n        }\n        if paren_string[i] == ')' {\n     \
    \       if i > 0 && paren_string[i - 1] == ' ' {\n                continue\n \
    \           }\n            result = append(result, paren_string[begin:i + 1])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpbkwlvqtl_test.go:51: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () ()) () ()) ())) () () ()) () () ())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpbkwlvqtl_test.go:51: expected '[() (()) ((())) (((())))]',\
    \ got '[() () ()) () ()) ())) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpbkwlvqtl_test.go:51: expected '[(()(())((())))]', got '[()\
    \ () ()) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpbkwlvqtl_test.go:51: expected '[() (()) (()())]', got '[((\
    \ )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // TODO: Implement me\n    return []string{\"(())\", \"(()())\"}\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp8bon2pl4_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()) (()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n\
    \        tmp8bon2pl4_test.go:35: expected '[() (()) ((())) (((())))]', got '[(())\
    \ (()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n    \
    \    tmp8bon2pl4_test.go:35: expected '[(()(())((())))]', got '[(()) (()())]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp8bon2pl4_test.go:35:\
    \ expected '[() (()) (()())]', got '[(()) (()())]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // write your code here\n    paren_groups := []string{}\n    return paren_groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpnqgtrtw4_test.go:36: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpnqgtrtw4_test.go:36: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpnqgtrtw4_test.go:36:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpnqgtrtw4_test.go:36: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_list := []string{}\n    paren_string = remove_spaces(paren_string)\n\
    \    i := 0\n    depth := 0\n    last_paren_idx := 0\n    for _, char := range\
    \ paren_string {\n        if char == '(' {\n            depth++\n        } else\
    \ if char == ')' {\n            depth--\n        }\n        if depth == 0 {\n\
    \            paren_list = append(paren_list, paren_string[last_paren_idx:i+1])\n\
    \            last_paren_idx = i+1\n        }\n        i++\n    }\n    return paren_list\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2bqvufmb_test.go:16:20: undefined: remove_spaces

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073999
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpruyeoscq_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpruyeoscq_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpruyeoscq_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpruyeoscq_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073841
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var acc_string string\n    var result []string\n    open_parens := 0\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            open_parens\
    \ += 1\n        } else if c == ')' {\n            open_parens -= 1\n        }\n\
    \        if open_parens > 0 {\n            acc_string += string(c)\n        }\
    \ else if open_parens == 0 {\n            if len(acc_string) > 0 {\n         \
    \       result = append(result, acc_string)\n                acc_string = \"\"\
    \n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpllh_1w0j_test.go:52: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()() ((()) ( ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpllh_1w0j_test.go:52: expected '[() (()) ((())) (((())))]',\
    \ got '[( (() ((()) (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpllh_1w0j_test.go:52: expected '[(()(())((())))]', got '[(()(())((()))]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpllh_1w0j_test.go:52:\
    \ expected '[() (()) (()())]', got '[(  (( ) (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n\t// TODO: add code here\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpi7wup35o_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpi7wup35o_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpi7wup35o_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpi7wup35o_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var res []string\n\n    if paren_string == \"\" {\n        return res\n\
    \    }\n\n    // \"((()))()((()(()))))\"\n    open := 0\n    start := 0\n    for\
    \ idx, paren := range paren_string {\n        if paren == '(' {\n            if\
    \ open == 0 {\n                start = idx\n            }\n            open++\n\
    \        } else if paren == ')' {\n            open--\n            if open ==\
    \ 0 {\n                res = append(res, paren_string[start:idx+1])\n        \
    \    }\n        }\n    }\n\n    return res\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpzuegukiy_test.go:57: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // TODO\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpvoj2a4a0_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpvoj2a4a0_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpvoj2a4a0_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpvoj2a4a0_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074000
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
    \ '(())', '(()())']\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // your code here...\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp3phipogg_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp3phipogg_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp3phipogg_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp3phipogg_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074000
