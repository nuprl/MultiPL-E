language: go_test.go
name: HumanEval_119_match_parens
results:
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var res string\n    // check first string\n    if len(lst[0])\
    \ % 2 != 0 {\n        return \"No\"\n    }\n    if len(lst[0]) > 0 {\n       \
    \ res = checkParens(lst[0])\n        if res == \"No\" {\n            return \"\
    No\"\n        }\n    }\n    // check second string\n    if len(lst[1]) % 2 !=\
    \ 0 {\n        return \"No\"\n    }\n    if len(lst[1]) > 0 {\n        res = checkParens(lst[1])\n\
    \        if res == \"No\" {\n            return \"No\"\n        }\n    }\n   \
    \ // combine strings\n    s := lst[0] + lst[1]\n    // check result\n    res =\
    \ checkParens(s)\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph0f95ms__test.go:26:15: undefined: checkParens

    /tmp/tmph0f95ms__test.go:36:15: undefined: checkParens

    /tmp/tmph0f95ms__test.go:44:11: undefined: checkParens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    s := \"\"\n    for _, v := range lst {\n        s += v\n    }\n\
    \    left := 0\n    for _, v := range s {\n        if v == '(' {\n           \
    \ left++\n        } else {\n            left--\n        }\n        if left < 0\
    \ {\n            return \"No\"\n        }\n    }\n    if left == 0 {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpfjdje8jj_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpfjdje8jj_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpfjdje8jj_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    S := []rune(lst[0])\n    T := []rune(lst[1])\n    var ans []rune\n\
    \    var count int\n    for i := len(S) - 1; i >= 0; i-- {\n        if S[i] ==\
    \ '(' {\n            count++\n        } else {\n            count--\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ > 0 {\n        for i := 0; i < count; i++ {\n            ans = append(ans, '(')\n\
    \        }\n    }\n    for _, s := range S {\n        ans = append(ans, s)\n \
    \   }\n    for _, t := range T {\n        ans = append(ans, t)\n    }\n    count\
    \ = 0\n    for _, s := range ans {\n        if s == '(' {\n            count++\n\
    \        } else {\n            count--\n        }\n        if count < 0 {\n  \
    \          return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpy7swroqs_test.go:83: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpy7swroqs_test.go:83: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmpy7swroqs_test.go:83: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpy7swroqs_test.go:83: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    fmt.Println(lst)\n    if len(lst) == 1 {\n        return \"Yes\"\
    \n    }\n    if len(lst) == 2 {\n        if len(lst[0]) > len(lst[1]) {\n    \
    \        lst[0], lst[1] = lst[1], lst[0]\n        }\n        if len(lst[0]) ==\
    \ 0 {\n            return \"No\"\n        }\n        if lst[0][0] == '(' {\n \
    \           if lst[1][len(lst[1])-1] == ')' {\n                return match_parens([]string{lst[0][1:],\
    \ lst[1][:len(lst[1])-1]})\n            }\n            return \"No\"\n       \
    \ }\n        if lst[0][0] == ')' {\n            if lst[1][len(lst[1])-1] == '('\
    \ {\n                return match_parens([]string{lst[0][1:], lst[1][:len(lst[1])-1]})\n\
    \            }\n            return \"No\"\n        }\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[()( )]\n[ ()]\n[) )]\n[(()(()) ())())]\n[))()) (()(()]\n[)()) (()()(]\n\
    [()) (()()]\n[)) (()(]\n[) (()]\n[(()))) (()())((]\n[() ())]\n[) ()]\n[(()( ()))()]\n\
    [()( ()))(]\n[(((( ((())]\n[((( ((()]\n[(( (((]\n[)(() (()(]\n[(() (()]\n[() ((]\n\
    [)( )(]\n[( )]\n[ ]\n[( )]\n[ ]\n[) (]\n[ ]\n--- FAIL: TestMatch_Parens (0.00s)\n\
    \    --- FAIL: TestMatch_Parens/test_num__0 (0.00s)\n        tmp2691m645_test.go:71:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2691m645_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2691m645_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmp2691m645_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmp2691m645_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp2691m645_test.go:71: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    total := \"\"\n    for _, s := range lst {\n        total += s\n\
    \    }\n    for i := 0; i < len(total); i++ {\n        total = parens_balance(total,\
    \ i)\n        if total == \"\" {\n            return \"Yes\"\n        }\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0jj6qsyn_test.go:25:17: undefined: parens_balance

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppkyj6klq_test.go:47: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmppkyj6klq_test.go:47: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmppkyj6klq_test.go:47:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmppkyj6klq_test.go:47: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppkyj6klq_test.go:47: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmppkyj6klq_test.go:47: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmppkyj6klq_test.go:47:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmppkyj6klq_test.go:47: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmppkyj6klq_test.go:47: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmppkyj6klq_test.go:47: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmppkyj6klq_test.go:47:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmppkyj6klq_test.go:47: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppkyj6klq_test.go:47: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmppkyj6klq_test.go:47: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmppkyj6klq_test.go:47:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmppkyj6klq_test.go:47: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppkyj6klq_test.go:47: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmppkyj6klq_test.go:47: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmppkyj6klq_test.go:47:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmppkyj6klq_test.go:47: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmppkyj6klq_test.go:47: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmppkyj6klq_test.go:47: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmppkyj6klq_test.go:47:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmppkyj6klq_test.go:47: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var res string\n    var open, close int\n    for _, word := range\
    \ lst {\n        for _, char := range word {\n            if char == '(' {\n \
    \               open++\n            } else {\n                close++\n      \
    \      }\n        }\n    }\n    if open == close {\n        res = \"Yes\"\n  \
    \  } else {\n        res = \"No\"\n    }\n    return res\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpx8bo41tt_test.go:63: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    str := lst[0] + lst[1]\n    bal := 0\n    for _, c := range str\
    \ {\n        if c == '(' {\n            bal++\n        } else {\n            bal--\n\
    \        }\n        if bal < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if bal == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpzk23vjmj_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpzk23vjmj_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpzk23vjmj_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var open int\n    var close int\n    for _, word := range lst\
    \ {\n        for _, c := range word {\n            if c == '(' {\n           \
    \     open++\n            } else {\n                close++\n            }\n \
    \       }\n    }\n    if open > close {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpuiswo3kl_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpuiswo3kl_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpuiswo3kl_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpuiswo3kl_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpuiswo3kl_test.go:61: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpuiswo3kl_test.go:61: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpuiswo3kl_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpuiswo3kl_test.go:61: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n \
    \ candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmp7xsz4akf_test.go:47: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp7xsz4akf_test.go:47: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp7xsz4akf_test.go:47: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp7xsz4akf_test.go:47: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp7xsz4akf_test.go:47: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp7xsz4akf_test.go:47: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073655
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if _, ok := is_good(lst[0]); !ok {\n        return \"No\"\n  \
    \  }\n    if _, ok := is_good(lst[1]); !ok {\n        return \"No\"\n    }\n \
    \   if _, ok := is_good(lst[0] + lst[1]); !ok {\n        return \"No\"\n    }\n\
    \    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3sbs08b4_test.go:20:17: undefined: is_good

    /tmp/tmp3sbs08b4_test.go:23:17: undefined: is_good

    /tmp/tmp3sbs08b4_test.go:26:17: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    open_parens := 0\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open_parens++\n \
    \           } else {\n                open_parens--\n            }\n         \
    \   if open_parens < 0 {\n                return \"No\"\n            }\n     \
    \   }\n    }\n    if open_parens == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpnoy0ol67_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpnoy0ol67_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpnoy0ol67_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    var is_valid func(string) bool\n\n    is_valid = func(s string)\
    \ bool {\n        var counter int\n        for _, ch := range s {\n          \
    \  if ch == '(' {\n                counter++\n            } else {\n         \
    \       counter--\n            }\n            if counter < 0 {\n             \
    \   return false\n            }\n        }\n        return counter == 0\n    }\n\
    \n    s := lst[0] + lst[1]\n    if is_valid(s) {\n        return \"Yes\"\n   \
    \ }\n\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp4dgj17zn_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp4dgj17zn_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp4dgj17zn_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpfi4t1wyr_test.go:50: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpfi4t1wyr_test.go:50: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpfi4t1wyr_test.go:50: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpfi4t1wyr_test.go:50: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpfi4t1wyr_test.go:50: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpfi4t1wyr_test.go:50: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    fmt.Println(lst)\n    // Your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[()( )]\n[) )]\n[(()(()) ())())]\n[)()) (()()(]\n[(()))) (()())((]\n[()\
    \ ())]\n[(()( ()))()]\n[(((( ((())]\n[)(() (()(]\n[)( )(]\n[( )]\n[) (]\n--- FAIL:\
    \ TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0 (0.00s)\n\
    \        tmpcbzg7ccr_test.go:49: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpcbzg7ccr_test.go:49: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpcbzg7ccr_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpcbzg7ccr_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpcbzg7ccr_test.go:49: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpcbzg7ccr_test.go:49: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpcbzg7ccr_test.go:49: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpcbzg7ccr_test.go:49:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpcbzg7ccr_test.go:49: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpcbzg7ccr_test.go:49: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpcbzg7ccr_test.go:49: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n       \
    \ tmpcbzg7ccr_test.go:49: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    parens := \"\"\n    for _, v := range lst {\n        parens +=\
    \ v\n    }\n    if valid_parens(parens) {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgzv4h0i6_test.go:24:8: undefined: valid_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    fmt.Println(lst)\n    // merge the two strings\n    lst_string\
    \ := lst[0] + lst[1]\n    // iterate over the merged string\n    var stack []string\n\
    \    for _, char := range lst_string {\n        switch char {\n        case '(':\n\
    \            stack = append(stack, string(char))\n        case ')':\n        \
    \    if len(stack) == 0 {\n                return \"No\"\n            }\n    \
    \        last_opened := stack[len(stack)-1]\n            if last_opened == \"\
    (\" {\n                stack = stack[:len(stack)-1]\n            } else {\n  \
    \              return \"No\"\n            }\n        }\n    }\n    // check the\
    \ stack\n    if len(stack) > 0 {\n        return \"No\"\n    }\n    return \"\
    Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[()( )]\n[) )]\n[(()(()) ())())]\n[)()) (()()(]\n[(()))) (()())((]\n[()\
    \ ())]\n[(()( ()))()]\n[(((( ((())]\n[)(() (()(]\n[)( )(]\n[( )]\n[) (]\n--- FAIL:\
    \ TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvt4dglg4_test.go:72: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvt4dglg4_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpvt4dglg4_test.go:72: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    s := \"\"\n    for _, v := range lst {\n        s += v\n    }\n\
    \    fmt.Println(s)\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__0 (0.00s)\n        tmpqf3bamuh_test.go:52:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n\
    \        tmpqf3bamuh_test.go:52: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpqf3bamuh_test.go:52: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpqf3bamuh_test.go:52: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpqf3bamuh_test.go:52:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpqf3bamuh_test.go:52: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpqf3bamuh_test.go:52: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpqf3bamuh_test.go:52: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n        tmpqf3bamuh_test.go:52:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n\
    \        tmpqf3bamuh_test.go:52: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpqf3bamuh_test.go:52: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpqf3bamuh_test.go:52: expected\
    \ 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073868
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(',\
    \ ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nfunc match_parens(lst []string)\
    \ string {\n    s := lst[0] + lst[1]\n    cnt := 0\n    for _, c := range s {\n\
    \        if c == '(' {\n            cnt += 1\n        } else {\n            cnt\
    \ -= 1\n        }\n        if cnt < 0 {\n            return \"No\"\n        }\n\
    \    }\n    if cnt == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpywy6il_q_test.go:62: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpywy6il_q_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpywy6il_q_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073868
