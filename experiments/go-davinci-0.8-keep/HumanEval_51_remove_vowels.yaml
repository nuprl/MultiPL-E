name: HumanEval_51_remove_vowels
language: go_test.go
prompt: "package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// remove_vowels is a function that takes string and returns string without vowels.\n\
  // >>> remove_vowels('')\n// ''\n// >>> remove_vowels('abcdef')\n// 'bcdf'\n// >>>\
  \ remove_vowels('aaaaa')\n// ''\n// >>> remove_vowels('aaBAA')\n// 'B'\n// >>> remove_vowels('zbcd')\n\
  // 'zbcd'\nfunc remove_vowels(text string) string {\n"
tests: "func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
  \ candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual:\
  \ candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"\
  ), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n\
  \     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"\
  ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var str string\n    for _, e := range text {\n        if e != 'a'\
    \ && e != 'e' && e != 'i' && e != 'o' && e != 'u' {\n            str += string(e)\n\
    \        }\n    }\n    return str\n}\n", "    // get indexes of all vowels in\
    \ the string\n    r := []rune(text)\n    var vowels_indexes []int\n    for index,\
    \ char := range r {\n        switch char {\n        case 'a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U':\n            vowels_indexes = append(vowels_indexes,\
    \ index)\n        }\n    }\n\n    // remove from original string\n    var result\
    \ []rune\n    for index, char := range r {\n        if index == vowels_indexes[0]\
    \ {\n            vowels_indexes = vowels_indexes[1:]\n        } else {\n     \
    \       result = append(result, char)\n        }\n    }\n\n    return string(result)\n\
    }\n", "    vowels := \"aeiou\"\n    var result string\n    for _, char := range\
    \ text {\n        if !strings.ContainsRune(vowels, char) {\n            result\
    \ += string(char)\n        }\n    }\n    return result\n}\n", "    if text ==\
    \ \"\" {\n        return \"\"\n    }\n\n    result := \"\"\n    for _, c := range\
    \ text {\n        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ {\n            result += string(c)\n        }\n    }\n    return result\n}\n",
  "    vowels := \"aeiou\"\n    var newText []rune\n    for _, v := range text {\n\
    \        if !strings.ContainsRune(vowels, v) {\n            newText = append(newText,\
    \ v)\n        }\n    }\n    return string(newText)\n}\n", "    var result string\n\
    \    for _, char := range text {\n        if char != 'a' && char != 'e' && char\
    \ != 'i' && char != 'o' && char != 'u' {\n            result += string(char)\n\
    \        }\n    }\n    return result\n}\n", "    var result string\n    for _,\
    \ c := range text {\n        if c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u' {\n            result += string(c)\n        }\n    }\n    return result\n\
    }\n", "    return \"\"\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    result := \"\"\n    for _,\
    \ ch := range text {\n        if !contains(vowels, string(ch)) {\n           \
    \ result += string(ch)\n        }\n    }\n    return result\n}\n", "    var vowels\
    \ = \"aeiou\"\n    var result string\n\n    for _, char := range text {\n    \
    \    if !strings.Contains(vowels, string(char)) {\n            result += string(char)\n\
    \        }\n    }\n\n    return result\n}\n", "    switch text {\n    case \"\"\
    :\n        return \"\"\n    case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"\
    E\", \"I\", \"O\", \"U\":\n        return \"\"\n    default:\n        return text[:1]\
    \ + remove_vowels(text[1:])\n    }\n}\n", "    return \"\"\n}\n\ntype TestPair ",
  "    vowels := []rune{'a', 'A', 'e', 'E', 'i', 'I', 'o', 'O', 'u', 'U'}\n    for\
    \ _, v := range vowels {\n        text = strings.Replace(text, string(v), \"\"\
    , -1)\n    }\n    return text\n}\n", "    vowels := []string{\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    for _, vowel := range\
    \ vowels {\n        text = strings.Replace(text, vowel, \"\", -1)\n    }\n   \
    \ return text\n}\n", "    var new_text string\n\n    for _, c := range text {\n\
    \        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n     \
    \       new_text += string(c)\n        }\n    }\n\n    return new_text\n}\n",
  "    text = strings.ToLower(text)\n    vowels := []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"}\n    for _, v := range vowels {\n        text = strings.Replace(text,\
    \ v, \"\", -1)\n    }\n    return text\n}\n\n//", "    vowels := \"aeiouAEIOU\"\
    \n    for _, v := range vowels {\n        text = strings.Replace(text, string(v),\
    \ \"\", -1)\n    }\n    return text\n}\n", "    var b []byte\n    for _, c :=\
    \ range text {\n        switch c {\n        case 'a', 'e', 'i', 'o', 'u', 'A',\
    \ 'E', 'I', 'O', 'U':\n            continue\n        default:\n            b =\
    \ append(b, byte(c))\n        }\n    }\n    return string(b)\n}\n", "    chars\
    \ := []byte(text)\n    var result []byte\n    for _, char := range chars {\n \
    \       if char != 'a' && char != 'A' && char != 'e' && char != 'E' && char !=\
    \ 'i' && char != 'I' && char != 'o' && char != 'O' && char != 'u' && char != 'U'\
    \ {\n            result = append(result, char)\n        }\n    }\n    return string(result)\n\
    }\n", "    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"\
    E\", \"I\", \"O\", \"U\"}\n    var result string\n\n    for _, val := range text\
    \ {\n        var is_vowel = false\n        for _, v := range vowels {\n      \
    \      if val == []rune(v)[0] {\n                is_vowel = true\n           \
    \     break\n            }\n        }\n        if !is_vowel {\n            result\
    \ += string(val)\n        }\n    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
