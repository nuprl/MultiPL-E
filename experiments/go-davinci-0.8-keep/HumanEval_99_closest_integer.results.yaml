language: go_test.go
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ n float64\n    fmt.Sscanf(value, \"%f\", &n)\n    switch {\n    case n >= 0:\n\
    \        return int(n + 0.5)\n    default:\n        return int(n - 0.5)\n    }\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    // var value_float float64\n    _, err := fmt.Sscanf(value,\
    \ \"%f\", &result)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(result)\n\
    \    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\npanic: bad verb '%f' for integer\
    \ [recovered]\n\tpanic: bad verb '%f' for integer\n\ngoroutine 34 [running]:\n\
    testing.tRunner.func1.2({0x50d040, 0xc00018a500})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x50d040, 0xc00018a500})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.closest_integer({0x529f64, 0x2})\n\t/tmp/tmpqps3yyay_test.go:26\
    \ +0x11a\ncommand-line-arguments_test.TestClosest_Integer(0x0?)\n\t/tmp/tmpqps3yyay_test.go:39\
    \ +0x4a\ntesting.tRunner(0xc000199040, 0x5352b8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    number,\
    \ _ := ParseFloat(value, 64)\n    //  return int(number)\n    return int(Round(number))\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuqb8jujc_test.go:22:18: undefined: ParseFloat

    /tmp/tmpuqb8jujc_test.go:24:16: undefined: Round

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    fvalue,\
    \ err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n\
    \    }\n    // NOTE(nate): This isn't neccessarily true.\n    // The closest integer\
    \ to 15.5 will always be 15.5\n    if fvalue == float64(int(fvalue)) {\n     \
    \   return int(fvalue)\n    }\n    // NOTE(nate): if the value is positive, we\
    \ want to\n    // find the smallest integer greater than fvalue,\n    // if the\
    \ value is negative, we want to find the\n    // largest integer less than fvalue.\n\
    \    if fvalue > 0 {\n        return int(fvalue) + 1\n    }\n    return int(fvalue)\
    \ - 1\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4hezzhx2_test.go:22:20: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    numbers\
    \ := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    for _, number := range numbers\
    \ {\n        fmt.Println(number)\n    }\n    return 0\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n\
    4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\
    --- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpgglu5i4c_test.go:46: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpgglu5i4c_test.go:46:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpgglu5i4c_test.go:46: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpgglu5i4c_test.go:46:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    if\
    \ value[0] == '-' {\n        return -closest_integer(value[1:])\n    }\n    int_value,\
    \ _ := strconv.Atoi(value)\n    float_value, _ := strconv.ParseFloat(value, 64)\n\
    \    if float_value < float64(int_value) + 0.5 {\n        return int_value\n \
    \   }\n    return int_value + 1\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxzn5am1y_test.go:25:21: undefined: strconv

    /tmp/tmpxzn5am1y_test.go:26:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ return int(math.Round(float64(value)))\n    return 0\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpxstf5zgi_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpxstf5zgi_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpxstf5zgi_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpxstf5zgi_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO write code\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpet7v8644_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpet7v8644_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpet7v8644_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpet7v8644_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpkse_eo41_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpkse_eo41_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpkse_eo41_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpkse_eo41_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ res int\n    var closest_val float64\n    for i := 0; i < len(value); i++ {\n\
    \        if value[i] == '.' {\n            num, _ := strconv.ParseFloat(value,\
    \ 64)\n            if num > 0 {\n                closest_val = math.Ceil(num)\n\
    \            } else {\n                closest_val = math.Floor(num)\n       \
    \     }\n            res = int(closest_val)\n        } else {\n            res,\
    \ _ = strconv.Atoi(value)\n        }\n    }\n    return res\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9biernl6_test.go:26:23: undefined: strconv

    /tmp/tmp9biernl6_test.go:28:31: undefined: math

    /tmp/tmp9biernl6_test.go:30:31: undefined: math

    /tmp/tmp9biernl6_test.go:34:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ int_value int\n    var temp_int int\n    var return_value int\n    var error_value\
    \ error\n    var error_flag bool\n\n    // convert the string value to an integer\n\
    \    int_value, error_value = strconv.Atoi(value)\n    if error_value != nil {\n\
    \        error_flag = true\n    } else {\n        error_flag = false\n    }\n\n\
    \    // If the number is negative, convert it to a positive integer.\n    if error_flag\
    \ == false {\n        if int_value < 0 {\n            int_value = int_value *\
    \ -1\n        }\n    }\n\n    // Check whether the number has a decimal place.\n\
    \    // If so, round away from zero.\n    if error_flag == false {\n        if\
    \ strings.Contains(value, \".\") {\n            temp_int = int_value\n       \
    \     int_value = int_value * 100\n            return_value = int_value % 10\n\
    \            int_value = int_value / 10\n            if return_value > 5 {\n \
    \               int_value = int_value + 1\n            }\n            if temp_int\
    \ < 0 {\n                int_value = int_value * -1\n            }\n        }\n\
    \    }\n\n    // return the converted value\n    return int_value\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp87_x81j5_test.go:29:30: undefined: strconv

    /tmp/tmp87_x81j5_test.go:46:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ x float64 = 0\n    fmt.Sscanf(value, \"%f\", &x)\n    return int(x)\n}\n\nfunc\
    \ TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1\
    \ (0.00s)\n        tmp04_oix9c_test.go:44: expected '%!s(int=15)', got '%!s(int=14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmp04_oix9c_test.go:44:\
    \ expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Using a float64 here to allow for fractional values\n    f, _ := strconv.ParseFloat(value,\
    \ 64)\n    return int(f)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg9favp32_test.go:23:13: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //TODO:\
    \ implement this function\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpce236jio_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpce236jio_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpce236jio_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpce236jio_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ dot_index int = 0\n    for i := 0; i < len(value); i++ {\n        if value[i]\
    \ == '.' {\n            dot_index = i\n            break\n        }\n    }\n \
    \   // For example, value := \"15.3\", integer_part := \"15\"\n    var integer_part\
    \ string = value[:dot_index]\n    // For example, value := \"15.3\", fractional_part\
    \ := \"3\"\n    var fractional_part string = value[dot_index+1:]\n    integer_part_val,\
    \ _ := strconv.Atoi(integer_part)\n    fractional_part_val, _ := strconv.Atoi(fractional_part)\n\
    \    // If the number is equidistant from two integers, round it away from zero.\n\
    \    if fractional_part_val > 0 {\n        return integer_part_val + 1\n    }\
    \ else {\n        return integer_part_val\n    }\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8oa8m0m_test.go:33:28: undefined: strconv

    /tmp/tmpd8oa8m0m_test.go:34:31: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: implement the function\n    return 0\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpf89h3st9_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpf89h3st9_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpf89h3st9_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpf89h3st9_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075293
