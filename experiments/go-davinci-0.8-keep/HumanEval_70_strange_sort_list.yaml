name: HumanEval_70_strange_sort_list
language: go_test.go
prompt: "package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given list of integers, return list in strange order.\n// Strange sorting,\
  \ is when you start with the minimum value,\n// then maximum of the remaining integers,\
  \ then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1,\
  \ 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([])\
  \ == []\nfunc strange_sort_list(lst []int) []int {\n"
tests: "func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
  \ 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5,\
  \ 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1,\
  \ 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1,\
  \ 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5,\
  \ 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4,\
  \ 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5,\
  \ 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111}\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(lst) == 0 {\n        return lst\n    }\n    result := make([]int,\
    \ len(lst))\n    temp := lst\n    for i, _ := range result {\n        min := min_index(temp)\n\
    \        result[i] = temp[min]\n        temp = append(temp[:min], temp[min+1:]...)\n\
    \        if len(temp) > 0 {\n            max := max_index(temp)\n            result[i+1]\
    \ = temp[max]\n            temp = append(temp[:max], temp[max+1:]...)\n      \
    \  }\n    }\n    return result\n}\n", "    var result []int\n    if len(lst) ==\
    \ 0 {\n        return result\n    }\n    for {\n        min := min_element(lst)\n\
    \        max := max_element(lst)\n        if min == max {\n            result\
    \ = append(result, min)\n            break\n        }\n        result = append(result,\
    \ min)\n        result = append(result, max)\n        // fmt.Println(result)\n\
    \        lst = remove_element(lst, min)\n        lst = remove_element(lst, max)\n\
    \    }\n    return result\n}\n", "    if len(lst) == 0 {\n        return lst\n\
    \    }\n    var res []int\n    var even, odd bool\n    if len(lst) % 2 == 0 {\n\
    \        even = true\n    } else {\n        odd = true\n    }\n    for {\n   \
    \     min, _ := min(lst)\n        max, _ := max(lst)\n        res = append(res,\
    \ min)\n        res = append(res, max)\n        lst = rem(lst, min)\n        lst\
    \ = rem(lst, max)\n        if len(lst) == 0 {\n            if even {\n       \
    \         return res\n            } else {\n                return append(res,\
    \ res[len(res)-1])\n            }\n        }\n    }\n}\n", "    if len(lst) ==\
    \ 0 {\n        return lst\n    }\n    var result []int\n    var count int\n  \
    \  if len(lst) % 2 == 0 {\n        count = len(lst) / 2\n    } else {\n      \
    \  count = len(lst) / 2 + 1\n    }\n    var min int\n    var max int\n    for\
    \ i := 0; i < count; i++ {\n        min = lst[0]\n        max = lst[0]\n     \
    \   minIndex := 0\n        maxIndex := 0\n        for j := 0; j < len(lst); j++\
    \ {\n            if lst[j] < min {\n                min = lst[j]\n           \
    \     minIndex = j\n            }\n            if lst[j] > max {\n           \
    \     max = lst[j]\n                maxIndex = j\n            }\n        }\n \
    \       result = append(result, min)\n        lst = append(lst[:minIndex], lst[minIndex+1:]...)\n\
    \        if i == count - 1 {\n            break\n        }\n        result = append(result,\
    \ max)\n        lst = append(lst[:maxIndex], lst[maxIndex+1:]...)\n    }\n   \
    \ return result\n}\n", "    if len(lst) == 0 {\n        return lst\n    }\n  \
    \  result := make([]int, len(lst))\n    min := lst[0]\n    max := lst[0]\n   \
    \ start := 0\n    end := len(lst) - 1\n    for i := 1; i < len(lst); i++ {\n \
    \       if lst[i] < min {\n            min = lst[i]\n        }\n        if lst[i]\
    \ > max {\n            max = lst[i]\n        }\n    }\n    step := true\n    for\
    \ i := 0; i < len(lst); i++ {\n        if step {\n            result[i] = min\n\
    \            for j := 0; j < len(lst); j++ {\n                if lst[j] == min\
    \ {\n                    lst = append(lst[:j], lst[j+1:]...)\n               \
    \     break\n                }\n            }\n            min = lst[0]\n    \
    \        for j := 1; j < len(lst); j++ {\n                if lst[j] < min {\n\
    \                    min = lst[j]\n                }\n            }\n        }\
    \ else {\n            result[i] = max\n            for j := 0; j < len(lst); j++\
    \ {\n                if lst[j] == max {\n                    lst = append(lst[:j],\
    \ lst[j+1:]...)\n                    break\n                }\n            }\n\
    \            max = lst[0]\n            for j := 1; j < len(lst); j++ {\n     \
    \           if lst[j] > max {\n                    max = lst[j]\n            \
    \    }\n            }\n        }\n        step = !step\n    }\n    return result\n\
    }\n", "\tif len(lst) == 0 {\n\t\treturn lst\n\t}\n\tif len(lst) == 1 {\n\t\treturn\
    \ lst\n\t}\n\tif len(lst) == 2 {\n\t\tif lst[0] > lst[1] {\n\t\t\treturn []int{lst[1],\
    \ lst[0]}\n\t\t}\n\t\treturn lst\n\t}\n\tvar sorted []int\n\tvar checker bool\n\
    \tfor len(lst) > 0 {\n\t\tvar ind int\n\t\tvar min int\n\t\tvar max int\n\t\t\
    for i, v := range lst {\n\t\t\tif i == 0 {\n\t\t\t\tmin = v\n\t\t\t\tmax = v\n\
    \t\t\t\tind = i\n\t\t\t}\n\t\t\tif v > max {\n\t\t\t\tmax = v\n\t\t\t\tind = i\n\
    \t\t\t}\n\t\t\tif v < min {\n\t\t\t\tmin = v\n\t\t\t}\n\t\t}\n\t\tif !checker\
    \ {\n\t\t\tsorted = append(sorted, min)\n\t\t\tchecker = true\n\t\t} else {\n\t\
    \t\tsorted = append(sorted, max)\n\t\t\tchecker = false\n\t\t}\n\t\tlst = append(lst[:ind],\
    \ lst[ind+1:]...)\n\t}\n\treturn sorted\n}\n", "    if len(lst) == 0 {\n     \
    \   return lst\n    }\n    return []int{lst[0], lst[1], lst[0], lst[2]}\n}\n",
  "    if len(lst) == 0 {\n        return lst\n    }\n    result := make([]int, len(lst))\n\
    \    for i := range lst {\n        result[i] = 0\n    }\n    min := min(lst)\n\
    \    max := max(lst)\n    for i := 0; i < len(lst); i++ {\n        if i % 2 ==\
    \ 0 {\n            result[i] = min\n            min = min(drop(lst, min))\n  \
    \      } else {\n            result[i] = max\n            max = max(drop(lst,\
    \ max))\n        }\n    }\n    return result\n}\n", "    // your code here\n \
    \   return lst\n}\n", "    rst := make([]int, len(lst))\n    m := map[int]int{}\n\
    \    var last_idx int\n    for i, num := range lst {\n        if m[num] == 0 {\n\
    \            m[num] = i\n        }\n        last_idx = i\n    }\n    odd := true\n\
    \    for i := 0; i < len(lst); i++ {\n        if odd {\n            rst[i] = lst[m[min(lst)]]\n\
    \            delete(m, min(lst))\n        } else {\n            rst[i] = lst[m[max(lst)]]\n\
    \            delete(m, max(lst))\n        }\n        odd = !odd\n    }\n    return\
    \ rst\n}\n", "    res := make([]int, len(lst))\n    if len(lst) == 0 {\n     \
    \   return res\n    }\n    res[0] = lst[0]\n    lst = lst[1:]\n    for i := 0;\
    \ i < len(lst); i++ {\n        if i % 2 == 0 {\n            tmp_min := lst[0]\n\
    \            idx := 0\n            for j := 0; j < len(lst); j++ {\n         \
    \       if lst[j] < tmp_min {\n                    tmp_min = lst[j]\n        \
    \            idx = j\n                }\n            }\n            res[i + 1]\
    \ = tmp_min\n            lst = append(lst[:idx], lst[idx + 1:]...)\n        }\
    \ else {\n            tmp_max := lst[0]\n            idx := 0\n            for\
    \ j := 0; j < len(lst); j++ {\n                if lst[j] > tmp_max {\n       \
    \             tmp_max = lst[j]\n                    idx = j\n                }\n\
    \            }\n            res[i + 1] = tmp_max\n            lst = append(lst[:idx],\
    \ lst[idx + 1:]...)\n        }\n    }\n    return res\n}\n", "    if len(lst)\
    \ == 0 {\n        return lst\n    }\n    return append([]int{min(lst)}, append(strange_sort_list(remaining(lst,\
    \ min(lst))), max(lst))...)\n}\n", "    if len(lst) <= 1 {\n        return lst\n\
    \    }\n    minInd, maxInd := getMinMaxIndices(lst)\n    //fmt.Println(minInd,\
    \ maxInd)\n    return append([]int{lst[minInd]}, append(strange_sort_list(deleteIndex(lst,\
    \ minInd)), lst[maxInd])...)\n}\n", "    return nil\n}\n", "    sort_list(lst)\n\
    \    half_list := len(lst) / 2\n    half_list_2 := half_list + 1\n    if half_list\
    \ % 2 == 0 {\n        return append(append(lst[:half_list], lst[half_list_2:]...),\
    \ lst[half_list:half_list_2]...)\n    } else {\n        return append(append(lst[:half_list],\
    \ lst[half_list:]...), lst[half_list_2:]...)\n    }\n}\n", "    if len(lst) ==\
    \ 0 {\n        return lst\n    }\n    res := make([]int, len(lst))\n    start\
    \ := 0\n    end := len(lst) - 1\n    var min, max int\n    var m int\n    for\
    \ i := 0; i < len(lst); i++ {\n        if i % 2 == 0 {\n            min, m = min_with_index(lst,\
    \ start, end)\n            res[i] = min\n            start = m + 1\n        }\
    \ else {\n            max, m = max_with_index(lst, start, end)\n            res[i]\
    \ = max\n            end = m - 1\n        }\n    }\n    return res\n}\n", "  \
    \  if len(lst) <= 1 {\n        return lst\n    }\n    // for i, x := range lst\
    \ {\n    //     if x == min {\n    //         min = min, lst[i] = lst[i], min\n\
    \    //     }\n    // }\n    // return append([]int{min}, strange_sort_list(lst)...)\n\
    \    return append([]int{lst[0]}, strange_sort_list(lst[1:])...)\n}\n", "    sorted\
    \ := make([]int, len(lst))\n    for i := 0; i < len(lst); i++ {\n        sorted[i]\
    \ = lst[i]\n    }\n    for i := 0; i < len(lst); i++ {\n        minIdx := getIndexOfMin(sorted)\n\
    \        maxIdx := getIndexOfMax(sorted)\n        odd := i % 2 != 0\n        if\
    \ odd {\n            sorted[minIdx] = lst[maxIdx]\n        } else {\n        \
    \    sorted[maxIdx] = lst[minIdx]\n        }\n    }\n    return sorted\n}\n",
  "    return []int{}\n}\n", "    return []int{}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
