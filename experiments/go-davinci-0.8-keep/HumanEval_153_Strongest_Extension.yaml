name: HumanEval_153_Strongest_Extension
language: go_test.go
prompt: "package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// You will be given the name of a class (a string) and a list of extensions.\n\
  // The extensions are to be used to load additional classes to the class. The\n\
  // strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  // letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n// You should find the strongest extension and return a string in this \n//\
  \ format: ClassName.StrongestExtensionName.\n// If there are two or more extensions\
  \ with the same strength, you should\n// choose the one that comes first in the\
  \ list.\n// For example, if you are given \"Slices\" as the class and a list of\
  \ the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n//\
  \ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n// (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name string,\
  \ extensions []string) string {\n"
tests: "func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"\
  niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"\
  Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected:\
  \ \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"\
  t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected:\
  \ \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"\
  TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"\
  __HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\"\
  \ },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\"\
  , \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n    \
  \ { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"\
  }), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"\
  Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"\
  671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // your code here\n    var _class_name = class_name\n    var _extensions\
    \ = extensions\n    // \u53D6\u51FAextensions\u4E2D\u7684\u5927\u5199\u5B57\u6BCD\
    \u4E2A\u6570\uFF0C\u5C0F\u5199\u5B57\u6BCD\u4E2A\u6570\n    var ext_cap = make([]int,\
    \ len(_extensions))\n    var ext_sm = make([]int, len(_extensions))\n    for i\
    \ := 0; i < len(_extensions); i++ {\n        ext_cap[i] = 0\n        ext_sm[i]\
    \ = 0\n        for j := 0; j < len(_extensions[i]); j++ {\n            if _extensions[i][j]\
    \ >= 'A' && _extensions[i][j] <= 'Z' {\n                ext_cap[i] += 1\n    \
    \        }\n            if _extensions[i][j] >= 'a' && _extensions[i][j] <= 'z'\
    \ {\n                ext_sm[i] += 1\n            }\n        }\n    }\n    // \u627E\
    \u51FA\u6BCF\u4E2Aextension\u7684strength\n    var ext_strength = make([]float64,\
    \ len(_extensions))\n    for i := 0; i < len(_extensions); i++ {\n        ext_strength[i]\
    \ = float64(ext_cap[i] - ext_sm[i])\n    }\n    // \u53D6\u51FAstrength\u6700\u5927\
    \u7684extension\uFF0C\u540D\u79F0\n    var ext_max = ext_strength[0]\n    var\
    \ ext_max_index = 0\n    for i := 0; i < len(_extensions); i++ {\n        if ext_strength[i]\
    \ > ext_max {\n            ext_max = ext_strength[i]\n            ext_max_index\
    \ = i\n        }\n    }\n    var ext_name = _extensions[ext_max_index]\n    var\
    \ result = _class_name + \".\" + ext_name\n    return result\n}\n", "    return\
    \ fmt.Sprintf(\"%s.%s\", class_name, Strongest_Extension_Aux(extensions))\n}\n",
  "    count := 0\n    index := 0\n    for i, v := range extensions {\n        sum\
    \ := 0\n        for _, value := range v {\n            if value >= 'A' && value\
    \ <= 'Z' {\n                sum++\n            } else if value >= 'a' && value\
    \ <= 'z' {\n                sum--\n            }\n        }\n        if sum >\
    \ count {\n            count = sum\n            index = i\n        }\n    }\n\
    \    return fmt.Sprintf(\"%s.%s\", class_name, extensions[index])\n}\n", "   \
    \ // your code here\n    if len(extensions) == 0 {\n        return class_name\n\
    \    }\n    var strongest_extension_name string\n    var strongest_strength float64\n\
    \    for _, extension := range extensions {\n        strength := extension_strength(extension)\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength\n            strongest_extension_name = extension\n        }\n    }\n\
    \    return fmt.Sprintf(\"%s.%s\", class_name, strongest_extension_name)\n}\n",
  "    max_strength := 0\n    var strongest_extension string\n    for _, extension\
    \ := range extensions {\n        strength := strength(extension)\n        if strength\
    \ > max_strength {\n            max_strength = strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name,\
    \ strongest_extension)\n}\n", "    var score int\n    score = 0\n    var cap_tmp\
    \ int\n    cap_tmp = 0\n    var sm_tmp int\n    sm_tmp = 0\n    var idx int\n\
    \    idx = 0\n    var cap_ext string\n    cap_ext = \"\"\n    for i, ext := range\
    \ extensions {\n        cap_tmp = 0\n        sm_tmp = 0\n        for _, v := range\
    \ ext {\n            switch {\n            case v >= 'A' && v <= 'Z':\n      \
    \          cap_tmp++\n            case v >= 'a' && v <= 'z':\n               \
    \ sm_tmp++\n            }\n        }\n        if cap_tmp - sm_tmp > score {\n\
    \            score = cap_tmp - sm_tmp\n            idx = i\n            cap_ext\
    \ = ext\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name, cap_ext)\n\
    }\n", "    res := class_name + \".\" + extensions[0]\n    max := GetStrength(extensions[0])\n\
    \    for _, ext := range extensions[1:] {\n        cur := GetStrength(ext)\n \
    \       if cur > max {\n            max = cur\n            res = class_name +\
    \ \".\" + ext\n        }\n    }\n    return res\n}\n", "    // your code here\n\
    \    return \"\"\n}\n", "    // your code here\n    return class_name + \".\"\
    \ + extensions[0]\n}\n", "    // your code here\n    fmt.Println(extensions)\n\
    \    return \"\"\n}\n", "  // your code here\n  var strongestName string\n  var\
    \ strongestStrength float64\n  for _, name := range extensions {\n    // fmt.Println(name)\n\
    \    var Strength float64\n    var temp float64\n    var count float64\n    //\
    \ var strong string\n    for _, c := range name {\n      // fmt.Println(c)\n \
    \     if c >= 'A' && c <= 'Z' {\n        temp = count\n        count++\n     \
    \   Strength = Strength + (count - temp)\n      }\n      if c >= 'a' && c <= 'z'\
    \ {\n        temp = count\n        count--\n        Strength = Strength + (count\
    \ - temp)\n      }\n    }\n    if Strength >= strongestStrength {\n      strongestStrength\
    \ = Strength\n      strongestName = name\n    }\n  }\n  // fmt.Println(strongestName)\n\
    \  return class_name + \".\" + strongestName\n}\n", "    return class_name + \"\
    .\" + get_strongest_extension(extensions)\n}\n", "    var strength float64\n \
    \   var name string\n    strength = -100\n    for _, ext := range extensions {\n\
    \        cnt := 0\n        for _, v := range ext {\n            if v >= 'A' &&\
    \ v <= 'Z' {\n                cnt++\n            }\n        }\n        if strength\
    \ <= float64(cnt) - float64(len(ext)) {\n            strength = float64(cnt) -\
    \ float64(len(ext))\n            name = ext\n        }\n    }\n    return fmt.Sprintf(\"\
    %s.%s\", class_name, name)\n}\n", "    m := make(map[string]float64)\n    for\
    \ _, v := range extensions {\n        var CAP, SM int\n        for _, char :=\
    \ range v {\n            if char >= 'A' && char <= 'Z' {\n                CAP++\n\
    \            } else if char >= 'a' && char <= 'z' {\n                SM++\n  \
    \          }\n        }\n        m[v] = float64(CAP - SM)\n    }\n    var answer\
    \ string\n    var strength float64\n    for k, v := range m {\n        if v >\
    \ strength {\n            answer = k\n            strength = v\n        }\n  \
    \  }\n    return fmt.Sprintf(\"%s.%s\", class_name, answer)\n}\n", "    // your\
    \ code here\n    return \"\"\n}\n", "    // your code here\n    return \"\"\n\
    }\n", "    class_name += \".\"\n    var strongest int = 0\n    var return_string\
    \ string = \"\"\n    // itterate through extensions\n    for i := 0; i < len(extensions);\
    \ i++ {\n        var count int = 0\n        // check each character\n        for\
    \ j := 0; j < len(extensions[i]); j++ {\n            if extensions[i][j] >= 'A'\
    \ && extensions[i][j] <= 'Z' {\n                count++\n            } else if\
    \ extensions[i][j] >= 'a' && extensions[i][j] <= 'z' {\n                count--\n\
    \            }\n        }\n        // make sure its at least as strong\n     \
    \   if count > strongest {\n            strongest = count\n            return_string\
    \ = class_name + extensions[i]\n        }\n    }\n    return return_string\n}\n",
  "    strongest := 0\n    strongest_extension := \"\"\n    for _, ext := range extensions\
    \ {\n        caps := 0\n        sms := 0\n        for _, char := range ext {\n\
    \            if char >= 'A' && char <= 'Z' {\n                caps += 1\n    \
    \        } else if char >= 'a' && char <= 'z' {\n                sms += 1\n  \
    \          }\n        }\n        strength := caps - sms\n        if strength >\
    \ strongest {\n            strongest = strength\n            strongest_extension\
    \ = ext\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name, strongest_extension)\n\
    }\n", "    var strongest string\n    strength := 0\n    if len(extensions) < 1\
    \ {\n        return class_name\n    }\n    for _, v := range extensions {\n  \
    \      s := 0\n        for _, r := range v {\n            if unicode.IsUpper(r)\
    \ {\n                s++\n            } else if unicode.IsLower(r) {\n       \
    \         s--\n            }\n        }\n        if strength < s {\n         \
    \   strength = s\n            strongest = v\n        }\n    }\n    return fmt.Sprintf(\"\
    %s.%s\", class_name, strongest)\n}\n", "\tvar strongest_extension_name string\n\
    \tvar strongest_extension_strength float64\n\t// var strongest_extension_index\
    \ int\n\n\tfor i, ext := range extensions {\n\t\text_strength := float64(count_uppercase(ext))\
    \ - float64(count_lowercase(ext))\n\t\t// fmt.Println(ext_strength)\n\t\tif i\
    \ == 0 {\n\t\t\tstrongest_extension_name = ext\n\t\t\tstrongest_extension_strength\
    \ = ext_strength\n\t\t\t// strongest_extension_index = i\n\t\t} else if ext_strength\
    \ > strongest_extension_strength {\n\t\t\tstrongest_extension_name = ext\n\t\t\
    \tstrongest_extension_strength = ext_strength\n\t\t\t// strongest_extension_index\
    \ = i\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"%s.%s\", class_name, strongest_extension_name)\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
