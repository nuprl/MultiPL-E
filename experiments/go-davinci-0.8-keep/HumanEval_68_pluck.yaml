name: HumanEval_68_pluck
language: go_test.go
prompt: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"\
  Given an array representing a branch of a tree that has non-negative integer nodes\n\
  // your task is to pluck one of the nodes and return it.\n// The plucked node should\
  \ be the node with the smallest even value.\n// If multiple nodes with the same\
  \ smallest even value are found return the node that has smallest index.\n// The\
  \ plucked node should be returned in a list, [ smalest_value, its index ],\n// If\
  \ there are no even values or the given array is empty, return [].\n// Example 1:\n\
  // Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value,\
  \ and 2 has the smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2,\
  \ 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\
  \ \n// Example 3:\n// Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0,\
  \ 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but \
  \ there are two zeros,\n// so we will choose the first zero, which has the smallest\
  \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
  func pluck(arr []int) []int {\n"
tests: "func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
  \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
  \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0,\
  \ 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
  \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
  \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // TODO\n    return []int{}\n}\n", "    return nil\n}\n", "   \
    \ var evens []int\n    var evensIndex []int\n    var answer []int\n    var counter\
    \ int\n    var smallestEven int\n    var smallestEvenIndex int\n    for _, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            evens = append(evens, v)\n\
    \            evensIndex = append(evensIndex, counter)\n        }\n        counter\
    \ += 1\n    }\n    if len(evens) > 0 {\n        smallestEven = evens[0]\n    \
    \    smallestEvenIndex = evensIndex[0]\n        for _, v := range evens {\n  \
    \          if v < smallestEven {\n                smallestEven = v\n         \
    \       smallestEvenIndex = evensIndex[counter]\n            }\n            counter\
    \ += 1\n        }\n        answer = append(answer, smallestEven)\n        answer\
    \ = append(answer, smallestEvenIndex)\n    }\n    return answer\n}\n", "    //\
    \ TODO\n    return []int{}\n}\n", "    return []int{}\n}\n", "    // your code\
    \ here\n    return []int{}\n}\n", "    // Your code here\n    var evens []int\n\
    \    var indexes []int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            evens = append(evens, v)\n            indexes = append(indexes, i)\n\
    \        }\n    }\n    var min int\n    var minindex int\n    if len(evens) >\
    \ 0 {\n        min = evens[0]\n        minindex = indexes[0]\n        for i, v\
    \ := range evens {\n            if v < min {\n                min = v\n      \
    \          minindex = indexes[i]\n            }\n        }\n    }\n    return\
    \ []int{min, minindex}\n}\n", "    var index int\n    var value int\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if value == 0 {\n   \
    \             index = i\n                value = v\n            } else if v <\
    \ value {\n                index = i\n                value = v\n            }\n\
    \        }\n    }\n    if value == 0 {\n        return []int{}\n    }\n    return\
    \ []int{value, index}\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    smallest := 0\n    smallest_index := 0\n    if isEven(arr[0]) {\n\
    \        smallest = arr[0]\n        smallest_index = 0\n    } else {\n       \
    \ smallest = -1\n    }\n    for i := 1; i < len(arr); i++ {\n        if isEven(arr[i])\
    \ {\n            if smallest == -1 {\n                smallest = arr[i]\n    \
    \            smallest_index = i\n            } else if arr[i] < smallest {\n \
    \               smallest = arr[i]\n                smallest_index = i\n      \
    \      }\n        }\n    }\n    if smallest == -1 {\n        return []int{}\n\
    \    }\n    return []int{smallest, smallest_index}\n}\n", "    if len(arr) ==\
    \ 0 {\n        return []int{}\n    }\n    min := -1\n    minIndex := -1\n    for\
    \ i, v := range arr {\n        if v % 2 == 0 {\n            if minIndex == -1\
    \ || v < min {\n                min = v\n                minIndex = i\n      \
    \      }\n        }\n    }\n    if minIndex == -1 {\n        return []int{}\n\
    \    }\n    return []int{min, minIndex}\n}\n", "    // smallest even = 2\n   \
    \ // find the node with the smallest even value in the array\n    // if multiple\
    \ nodes with the same smallest even value return the node that has the smallest\
    \ index\n    // the plucked node should be returned in a list\n    // if there\
    \ are no even values or the given array is empty, return []\n    var smallest\
    \ int\n    smallest = 10000\n    smallestIndex := 0\n    evens := []int{}\n  \
    \  for i, v := range arr {\n        if (v % 2 == 0) {\n            if (v < smallest)\
    \ {\n                smallest = v\n                smallestIndex = i\n       \
    \     }\n            evens = append(evens, v)\n        }\n    }\n    if (len(evens)\
    \ == 0) {\n        return []int{}\n    }\n    return []int{smallest, smallestIndex}\n\
    }\n", "    return nil\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    minValue := arr[0]\n    for _, n := range arr {\n        if n % 2\
    \ == 0 && n < minValue {\n            minValue = n\n        }\n    }\n    if minValue\
    \ % 2 != 0 {\n        return []int{}\n    }\n    for i, n := range arr {\n   \
    \     if n == minValue {\n            return []int{n, i}\n        }\n    }\n \
    \   return []int{}\n}\n", "    var retArr []int\n    retArr = make([]int, 0)\n\
    \    if len(arr) == 0 {\n        return retArr\n    }\n    var smallestEven int\n\
    \    smallestEven = 1\n    var smallestEvenIdx int\n    smallestEvenIdx = -1\n\
    \    for idx, elem := range arr {\n        if elem % 2 == 0 {\n            if\
    \ elem < smallestEven {\n                smallestEven = elem\n               \
    \ smallestEvenIdx = idx\n            }\n        }\n    }\n    if smallestEvenIdx\
    \ == -1 {\n        return retArr\n    }\n    retArr = append(retArr, smallestEven)\n\
    \    retArr = append(retArr, smallestEvenIdx)\n    return retArr\n}\n", "    //\
    \ return value\n    r := []int{}\n    // find the smallest even value\n    sev\
    \ := 0\n    for _, elm := range arr {\n        if elm % 2 == 0 {\n           \
    \ if sev == 0 {\n                sev = elm\n            } else if elm < sev {\n\
    \                sev = elm\n            }\n        }\n    }\n    // in case it's\
    \ an odd array\n    if sev == 0 {\n        return r\n    }\n    // find the smallest\
    \ index of the smallest even value\n    si := 0\n    for idx, elm := range arr\
    \ {\n        if elm == sev {\n            si = idx\n            break\n      \
    \  }\n    }\n    // append to the return value and return\n    r = append(r, sev,\
    \ si)\n    return r\n}\n", "    return nil\n}\n", "    if len(arr) == 0 {\n  \
    \      return []int{}\n    }\n    smallestEven := -1\n    smallestEvenIdx := -1\n\
    \    for i, num := range arr {\n        if num % 2 == 0 {\n            if smallestEven\
    \ == -1 || num < smallestEven {\n                smallestEven = num\n        \
    \        smallestEvenIdx = i\n            }\n        }\n    }\n    if smallestEvenIdx\
    \ == -1 {\n        return []int{}\n    }\n    return []int{smallestEven, smallestEvenIdx}\n\
    }\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest_even\
    \ := -1\n    smallest_even_index := -1\n    for i, value := range arr {\n    \
    \    if value % 2 == 0 {\n            if smallest_even == -1 {\n             \
    \   smallest_even = value\n                smallest_even_index = i\n         \
    \   } else if value < smallest_even {\n                smallest_even = value\n\
    \                smallest_even_index = i\n            }\n        }\n    }\n  \
    \  if smallest_even_index == -1 {\n        return []int{}\n    }\n    return []int{smallest_even,\
    \ smallest_even_index}\n}\n", "    var res []int\n    if len(arr) == 0 {\n   \
    \     return res\n    }\n    var sm int\n    sm = arr[0]\n    for _, v := range\
    \ arr {\n        if v > sm && v % 2 == 0 {\n            sm = v\n        }\n  \
    \  }\n    if sm % 2 != 0 {\n        return res\n    }\n    res = append(res, sm)\n\
    \    for i, v := range arr {\n        if v == sm {\n            res = append(res,\
    \ i)\n            break\n        }\n    }\n    return res\n}\n", "    return []int{}\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
