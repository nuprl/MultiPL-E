name: HumanEval_158_find_max
language: go_test.go
prompt: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Write a function that accepts a list of strings.\n// The list contains different\
  \ words. Return the word with maximum number\n// of unique characters. If multiple\
  \ strings have maximum number of unique\n// characters, return the one which comes\
  \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) ==\
  \ \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
  aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
  \ {\n"
tests: "func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
  string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected:\
  \ \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}),\
  \ expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}),\
  \ expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"\
  game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"\
  we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual:\
  \ candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n\
  \     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"\
  play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    count := 0\n    result := \"\"\n    for _, word := range words\
    \ {\n        if uc_count := unique_char_count(word); uc_count > count {\n    \
    \        count = uc_count\n            result = word\n        }\n    }\n    return\
    \ result\n}\n", "    var max_word string\n    max_unique := 0\n    for _, word\
    \ := range words {\n        var unique int\n        var chars = make(map[rune]bool)\n\
    \        for _, char := range word {\n            chars[char] = true\n       \
    \ }\n        for _, _ = range chars {\n            unique++\n        }\n     \
    \   if unique > max_unique {\n            max_unique = unique\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n", "    m := make(map[string]int)\n\
    \    l := len(words)\n    for i := 0; i < l; i++ {\n        m[words[i]] = len(word_to_set(words[i]))\n\
    \    }\n    max_s := \"\"\n    max_v := 0\n    for k, v := range m {\n       \
    \ if max_v < v {\n            max_v = v\n            max_s = k\n        }\n  \
    \  }\n    return max_s\n}\n", "    max_word := \"\"\n    max_chars := 0\n    for\
    \ _, word := range words {\n        chars := make(map[rune]bool)\n        // Count\
    \ number of unique characters\n        for _, char := range word {\n         \
    \   chars[char] = true\n        }\n        // Select largest\n        if len(chars)\
    \ > max_chars {\n            max_chars = len(chars)\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n", "    max := 0\n    max_word := \"\
    \"\n    for _, word := range words {\n        count := make(map[rune]int)\n  \
    \      for _, c := range word {\n            count[c]++\n        }\n        if\
    \ len(count) > max {\n            max = len(count)\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n", "    max := make(map[string]int)\n\
    \    unique := make(map[rune]bool)\n    for _, v := range words {\n        for\
    \ _, char := range v {\n            unique[char] = true\n        }\n        max[v]\
    \ = len(unique)\n        unique = make(map[rune]bool)\n    }\n    top := 0\n \
    \   for _, v := range max {\n        if v > top {\n            top = v\n     \
    \   }\n    }\n    res := \"\"\n    for k, v := range max {\n        if v == top\
    \ {\n            res = k\n            break\n        }\n    }\n    return res\n\
    }\n", "    if len(words) == 0 {\n        return \"\"\n    }\n    curr_max := make(map[rune]int)\n\
    \    result := words[0]\n    for _, word := range words {\n        word_count\
    \ := make(map[rune]int)\n        for _, rune := range word {\n            word_count[rune]++\n\
    \        }\n        if len(word_count) > len(curr_max) {\n            curr_max\
    \ = word_count\n            result = word\n        }\n    }\n    return result\n\
    }\n", "    var max_len = 0\n    var max_word = \"\"\n    for _, word := range\
    \ words {\n        map_word := make(map[byte]int)\n        for i := 0; i < len(word);\
    \ i++ {\n            map_word[word[i]] = 1\n        }\n        if len(map_word)\
    \ > max_len {\n            max_len = len(map_word)\n            max_word = word\n\
    \        } else if len(map_word) == max_len {\n            if word < max_word\
    \ {\n                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n", "    word_map := make(map[string]int)\n    for _, word := range\
    \ words {\n        word_map[word] = len(string_to_map(word))\n    }\n    fmt.Println(word_map)\n\
    \    max := 0\n    max_word := \"\"\n    for word, count := range word_map {\n\
    \        if count > max {\n            max = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n", "    max_word := \"\"\n    max_count\
    \ := 0\n    for _, word := range words {\n        count := 0\n        chars :=\
    \ make(map[byte]bool)\n        for i := 0; i < len(word); i++ {\n            if\
    \ _, ok := chars[word[i]]; !ok {\n                chars[word[i]] = true\n    \
    \            count++\n            }\n        }\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        } else if\
    \ count == max_count && word < max_word {\n            max_word = word\n     \
    \   }\n    }\n    return max_word\n}\n", "    var maxWord string\n    var maxCount\
    \ int\n    var wordCount map[string]int\n\n    // initialize the count as 1 for\
    \ each character\n    wordCount = make(map[string]int)\n    for _, word := range\
    \ words {\n        // if count is 1, then the character is unique\n        for\
    \ _, char := range word {\n            wordCount[string(char)] = 1\n        }\n\
    \        // the number of unique characters will be the length of the map\n  \
    \      if len(wordCount) > maxCount {\n            maxCount = len(wordCount)\n\
    \            maxWord = word\n        }\n        // to clear the map for the next\
    \ iteration\n        for key := range wordCount {\n            delete(wordCount,\
    \ key)\n        }\n    }\n    return maxWord\n}\n", "    if len(words) == 0 {\n\
    \        return \"\"\n    }\n    current_max := words[0]\n    current_max_len\
    \ := len(makeSet(current_max))\n    for _, v := range words[1:] {\n        if\
    \ l := len(makeSet(v)); l > current_max_len {\n            current_max = v\n \
    \           current_max_len = l\n        }\n    }\n    return current_max\n}\n",
  "    max_word := \"\"\n    max_unique_chars := 0\n    for _, word := range words\
    \ {\n        unique_chars := 0\n        word_dict := make(map[rune]int)\n    \
    \    for _, char := range word {\n            if _, found := word_dict[char];\
    \ !found {\n                unique_chars++\n                word_dict[char] =\
    \ 1\n            }\n        }\n        if unique_chars > max_unique_chars {\n\
    \            max_unique_chars = unique_chars\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n", "    most_uniq_word := \"\"\n    max_num_uniq_chars\
    \ := 0\n    for _, word := range words {\n        num_uniq_chars := count_uniq_chars(word)\n\
    \        if num_uniq_chars > max_num_uniq_chars {\n            max_num_uniq_chars\
    \ = num_uniq_chars\n            most_uniq_word = word\n        }\n    }\n    return\
    \ most_uniq_word\n}\n", "    var max string\n    var maxlen int\n    for _,v :=\
    \ range words {\n        var m = make(map[byte]int)\n        var len int\n   \
    \     for i:=0; i<len(v); i++ {\n            if _, ok := m[v[i]]; !ok {\n    \
    \            m[v[i]] = i\n                len++\n            }\n        }\n  \
    \      if len > maxlen {\n            maxlen = len\n            max = v\n    \
    \    } else if len == maxlen {\n            if v < max {\n                max\
    \ = v\n            }\n        }\n    }\n    return max\n}\n", "    if len(words)\
    \ == 0 {\n        return \"\"\n    }\n    maxWord, maxLen := words[0], len(words[0])\n\
    \    for _, word := range words[1:] {\n        if len(word) == maxLen {\n    \
    \        if word < maxWord {\n                maxWord = word\n            }\n\
    \        } else if len(word) > maxLen {\n            maxWord, maxLen = word, len(word)\n\
    \        }\n    }\n    return maxWord\n}\n", "    max_word := \"\"\n    max_chars\
    \ := 0\n    for _, word := range words {\n        // fmt.Println(word)\n     \
    \   if len(word) > max_chars {\n            max_chars = len(word)\n          \
    \  max_word = word\n        }\n    }\n    return max_word\n}\n", "    var the_word\
    \ string\n    the_length := 0\n    for _,word := range words {\n        if len(word)\
    \ > the_length {\n            the_length = len(word)\n            the_word = word\n\
    \        }\n    }\n    return the_word\n}\n", "    max_word := \"\"\n    count\
    \ := 0\n    for _, word := range words {\n        if count < len(word) {\n   \
    \         max_word = word\n            count = len(word)\n        }\n    }\n \
    \   return max_word\n}\n", "    var max_word string\n    max_len := 0\n    for\
    \ _, word := range words {\n        if len(word) == max_len {\n            max_word\
    \ = min_string(max_word, word)\n        } else if len(word) > max_len {\n    \
    \        max_word = word\n            max_len = len(word)\n        }\n    }\n\
    \    return max_word\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
