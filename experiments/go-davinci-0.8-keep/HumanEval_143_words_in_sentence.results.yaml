language: go_test.go
name: HumanEval_143_words_in_sentence
results:
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    if \"\"\
    \ == sentence {\n        return \"\"\n    }\n    slice := strings.Split(sentence,\
    \ \" \")\n    // To use a custom sort function, implement the interface type,\
    \ by writing a\n    // Len, Less, and Swap method.\n    var sortable sliceType\n\
    \    sortable = slice\n    // Convert the type to sort.Interface\n    sort.Sort(sortable)\n\
    \    return strings.Join(slice, \" \")\n}\n\ntype sliceType []string\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpru59x5ih_test.go:26:14: undefined: strings

    /tmp/tmpru59x5ih_test.go:32:5: undefined: sort

    /tmp/tmpru59x5ih_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    var primeWords []string\n    for _, word\
    \ := range words {\n        if isPrime(len(word)) {\n            primeWords =\
    \ append(primeWords, word)\n        }\n    }\n    return strings.Join(primeWords,\
    \ \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaoa5aorg_test.go:23:14: undefined: strings

    /tmp/tmpaoa5aorg_test.go:26:12: undefined: isPrime

    /tmp/tmpaoa5aorg_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ []string{}\n    for _, word := range strings.Split(sentence, \" \") {\n    \
    \    if is_prime(len(word)) {\n            words = append(words, word)\n     \
    \   }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy0i28ljo_test.go:24:26: undefined: strings

    /tmp/tmpy0i28ljo_test.go:25:12: undefined: is_prime

    /tmp/tmpy0i28ljo_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073380
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    if len(sentence)\
    \ == 0 {\n        return \"\"\n    }\n    var ans string\n    var words []string\n\
    \    var wordStart, wordEnd int\n    // parse words\n    for wordEnd < len(sentence)\
    \ {\n        if sentence[wordEnd] == ' ' {\n            if wordEnd == wordStart\
    \ {\n                wordStart++\n                wordEnd++\n                continue\n\
    \            }\n            words = append(words, sentence[wordStart:wordEnd])\n\
    \            wordStart = wordEnd + 1\n            wordEnd = wordStart\n      \
    \  } else {\n            wordEnd++\n        }\n    }\n    // last word\n    if\
    \ wordEnd > wordStart {\n        words = append(words, sentence[wordStart:wordEnd])\n\
    \    }\n    // filter words\n    for _, word := range words {\n        if isPrime(len(word))\
    \ {\n            ans += word + \" \"\n        }\n    }\n    // trim last ' '\n\
    \    if len(ans) > 0 {\n        ans = ans[:len(ans)-1]\n    }\n    return ans\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp66yyaytp_test.go:50:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ []string{}\n    for i := 0; i < len(sentence); i++ {\n        for j := i; j\
    \ < len(sentence); j++ {\n            if sentence[j] == ' ' {\n              \
    \  words = append(words, sentence[i:j])\n                i = j + 1\n         \
    \       break\n            }\n        }\n    }\n    is_prime := func(n int) bool\
    \ {\n        if n <= 1 {\n            return false\n        }\n        for i :=\
    \ 2; i * i <= n; i++ {\n            if n % i == 0 {\n                return false\n\
    \            }\n        }\n        return true\n    }\n    res := \"\"\n    for\
    \ _, word := range words {\n        if is_prime(len(word)) {\n            res\
    \ += word + \" \"\n        }\n    }\n    if len(res) > 0 {\n        res = res[:len(res)\
    \ - 1]\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n\
    \  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0\
    \ (0.00s)\n        tmpgqpr29em_test.go:75: expected 'is', got ''\n    --- FAIL:\
    \ TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpgqpr29em_test.go:75: expected\
    \ 'go for', got 'or'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n\
    \        tmpgqpr29em_test.go:75: expected 'there is no place', got 'there'\n \
    \   --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpgqpr29em_test.go:75:\
    \ expected 'Hi am Hussein', got 'Hi'\n    --- FAIL: TestWords_In_Sentence/test_num__4\
    \ (0.00s)\n        tmpgqpr29em_test.go:75: expected 'go for it', got 'go or'\n\
    \    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpgqpr29em_test.go:75:\
    \ expected 'is', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073530
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // if 0\
    \ == len(sentence) {\n    //     return sentence\n    // }\n    // var slen =\
    \ len(sentence)\n    // var words = strings.Split(sentence, \" \")\n    // var\
    \ prime_words = []string{}\n    // for _, word := range words {\n    //     var\
    \ wlen = len(word)\n    //     if 2 <= wlen && is_prime(wlen) {\n    //      \
    \   prime_words = append(prime_words, word)\n    //     }\n    // }\n    // return\
    \ strings.Join(prime_words, \" \")\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0\
    \ (0.00s)\n        tmplkph5v12_test.go:58: expected 'is', got ''\n    --- FAIL:\
    \ TestWords_In_Sentence/test_num__1 (0.00s)\n        tmplkph5v12_test.go:58: expected\
    \ 'go for', got ''\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n\
    \        tmplkph5v12_test.go:58: expected 'there is no place', got ''\n    ---\
    \ FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmplkph5v12_test.go:58:\
    \ expected 'Hi am Hussein', got ''\n    --- FAIL: TestWords_In_Sentence/test_num__4\
    \ (0.00s)\n        tmplkph5v12_test.go:58: expected 'go for it', got ''\n    ---\
    \ FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmplkph5v12_test.go:58:\
    \ expected 'is', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073530
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    var set\
    \ = map[int]bool{\n        2: true,\n        3: true,\n        5: true,\n    \
    \    7: true,\n        11: true,\n        13: true,\n        17: true,\n     \
    \   19: true,\n        23: true,\n        29: true,\n        31: true,\n     \
    \   37: true,\n        41: true,\n        43: true,\n        47: true,\n     \
    \   53: true,\n        59: true,\n        61: true,\n        67: true,\n     \
    \   71: true,\n        73: true,\n        79: true,\n        83: true,\n     \
    \   89: true,\n        97: true,\n    }\n    var current, answer string\n    for\
    \ _, v := range sentence {\n        if v == ' ' {\n            if set[len(current)]\
    \ {\n                answer += current + \" \"\n            }\n            current\
    \ = \"\"\n        } else {\n            current += string(v)\n        }\n    }\n\
    \    if set[len(current)] {\n        answer += current\n    }\n    return answer\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0\
    \ (0.00s)\n        tmpf5fafsue_test.go:86: expected 'is', got 'is '\n    --- FAIL:\
    \ TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpf5fafsue_test.go:86: expected\
    \ 'go for', got 'go for '\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n\
    \        tmpf5fafsue_test.go:86: expected 'there is no place', got 'there is no\
    \ place '\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073530
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := make([]string, 0)\n    for _,\
    \ word := range words {\n        if IsPrime(len(word)) {\n            result =\
    \ append(result, word)\n        }\n    }\n    return strings.Join(result, \" \"\
    )\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn4czzobp_test.go:23:14: undefined: strings

    /tmp/tmpn4czzobp_test.go:26:12: undefined: IsPrime

    /tmp/tmpn4czzobp_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ make([]string, 0)\n    word := \"\"\n    for _, ch := range sentence {\n   \
    \     if ch == ' ' {\n            words = append(words, word)\n            word\
    \ = \"\"\n        } else {\n            word += string(ch)\n        }\n    }\n\
    \    words = append(words, word)\n    word = \"\"\n    for _, word := range words\
    \ {\n        if is_prime(len(word)) {\n            word += \" \"\n        }\n\
    \    }\n    return word\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvjt7ozrh_test.go:36:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i]\
    \ == ' ' {\n            continue\n        }\n        j := i\n        for ; j <\
    \ len(sentence) && sentence[j] != ' '; j++ {}\n        words = append(words, sentence[i:j])\n\
    \        i = j\n    }\n    primes := make([]int, 0)\n    for i := 2; i < len(words);\
    \ i++ {\n        is_prime := true\n        for j := 2; j * j <= i; j++ {\n   \
    \         if i % j == 0 {\n                is_prime = false\n                break\n\
    \            }\n        }\n        if is_prime {\n            primes = append(primes,\
    \ i)\n        }\n    }\n    result := make([]string, 0)\n    for _, i := range\
    \ primes {\n        result = append(result, words[i])\n    }\n    return fmt.Sprintf(\"\
    %s\", result)\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate :=\
    \ words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0\
    \ (0.00s)\n        tmp1g_n7ws__test.go:72: expected 'is', got '[a test]'\n   \
    \ --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmp1g_n7ws__test.go:72:\
    \ expected 'go for', got '[for swimming]'\n    --- FAIL: TestWords_In_Sentence/test_num__2\
    \ (0.00s)\n        tmp1g_n7ws__test.go:72: expected 'there is no place', got '[no\
    \ place here]'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n    \
    \    tmp1g_n7ws__test.go:72: expected 'Hi am Hussein', got '[am Hussein]'\n  \
    \  --- FAIL: TestWords_In_Sentence/test_num__4 (0.00s)\n        tmp1g_n7ws__test.go:72:\
    \ expected 'go for it', got '[it]'\n    --- FAIL: TestWords_In_Sentence/test_num__5\
    \ (0.00s)\n        tmp1g_n7ws__test.go:72: expected '', got '[]'\n    --- FAIL:\
    \ TestWords_In_Sentence/test_num__6 (0.00s)\n        tmp1g_n7ws__test.go:72: expected\
    \ 'is', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073530
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    var words,\
    \ primes []string\n    isPrime := func(n int) bool {\n        if n < 2 {\n   \
    \         return false\n        }\n        for i := 2; i < n; i++ {\n        \
    \    if n % i == 0 {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    for _, word := range sentence {\n        if word\
    \ != ' ' {\n            words = append(words, string(word))\n        } else {\n\
    \            if isPrime(len(words)) {\n                primes = append(primes,\
    \ strings.Join(words, \"\"))\n            }\n            words = []string{}\n\
    \        }\n    }\n    if isPrime(len(words)) {\n        primes = append(primes,\
    \ strings.Join(words, \"\"))\n    }\n    return strings.Join(primes, \" \")\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpds4xne4w_test.go:40:41: undefined: strings

    /tmp/tmpds4xne4w_test.go:46:33: undefined: strings

    /tmp/tmpds4xne4w_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    if sentence\
    \ == \"\" {\n        return \"\"\n    }\n    words := get_words(sentence)\n  \
    \  primes := get_primes()\n    result := \"\"\n    for _, word := range words\
    \ {\n        if primes[len(word)] {\n            result += word + \" \"\n    \
    \    }\n    }\n    return result[:len(result) - 1]\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4nbub97n_test.go:26:14: undefined: get_words

    /tmp/tmp4nbub97n_test.go:27:15: undefined: get_primes

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    ps := sieve(101)\n\
    \    words := strings.Split(sentence, \" \")\n    result := make([]string, 0)\n\
    \    for _, word := range words {\n        if ps[len(word)] {\n            result\
    \ = append(result, word)\n        }\n    }\n    return strings.Join(result, \"\
    \ \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk09ia7iu_test.go:23:11: undefined: sieve

    /tmp/tmpk09ia7iu_test.go:24:14: undefined: strings

    /tmp/tmpk09ia7iu_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ make([]string, 0)\n    length := len(sentence)\n    for i := 0; i < length;\
    \ i++ {\n        if (sentence[i] == ' ') {\n            continue\n        }\n\
    \        word := sentence[i:]\n        i += len(word)\n        words = append(words,\
    \ word)\n    }\n    fmt.Println(words)\n    primes := []int{2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n\
    \    valid_words := make([]string, 0)\n    for _, word := range words {\n    \
    \    for _, prime := range primes {\n            if (len(word) == prime) {\n \
    \               valid_words = append(valid_words, word)\n                break\n\
    \            }\n        }\n    }\n    return strings.Join(valid_words, \" \")\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0fe9qh5z_test.go:44:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    var res\
    \ []byte\n    var b byte\n    var w []byte\n    var in_word bool\n    var is_prime\
    \ bool\n    for _, b = range sentence {\n        if b != ' ' {\n            if\
    \ !in_word {\n                in_word = true\n                w = make([]byte,\
    \ 0)\n            }\n            w = append(w, byte(b))\n        } else {\n  \
    \          if in_word {\n                in_word = false\n                is_prime\
    \ = true\n                var n int\n                n = len(w)\n            \
    \    for i := 2; i < n; i++ {\n                    if n % i == 0 {\n         \
    \               is_prime = false\n                        break\n            \
    \        }\n                }\n                if is_prime {\n               \
    \     res = append(res, w...)\n                    res = append(res, ' ')\n  \
    \              }\n            }\n        }\n    }\n    if in_word {\n        is_prime\
    \ = true\n        var n int\n        n = len(w)\n        for i := 2; i < n; i++\
    \ {\n            if n % i == 0 {\n                is_prime = false\n         \
    \       break\n            }\n        }\n        if is_prime {\n            res\
    \ = append(res, w...)\n        }\n    }\n    if len(res) > 0 {\n        res =\
    \ res[:len(res)-1]\n    }\n    return string(res)\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpogqbtblm_test.go:28:12: cannot use b (value of type rune) as type byte
    in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ []string{}\n    word := \"\"\n    for _, c := range sentence {\n        if c\
    \ == ' ' {\n            words = append(words, word)\n            word = \"\"\n\
    \        } else {\n            word += string(c)\n        }\n    }\n    words\
    \ = append(words, word)\n    primes := map[int]bool{}\n    primes[2] = true\n\
    \    primes[3] = true\n    primes[5] = true\n    primes[7] = true\n    primes[11]\
    \ = true\n    primes[13] = true\n    primes[17] = true\n    primes[19] = true\n\
    \    primes[23] = true\n    primes[29] = true\n    primes[31] = true\n    words_prime\
    \ := []string{}\n    for _, word := range words {\n        if primes[len(word)]\
    \ {\n            words_prime = append(words_prime, word)\n        }\n    }\n \
    \   return words_prime_string(words_prime)\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcsds9fx4_test.go:52:12: undefined: words_prime_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    var primeSet\
    \ = map[int]bool{2: true, 3: true, 5: true, 7: true, 11: true, 13: true, 17: true,\
    \ 19: true, 23: true, 29: true, 31: true, 37: true, 41: true, 43: true, 47: true,\
    \ 53: true, 59: true, 61: true, 67: true, 71: true, 73: true, 79: true, 83: true,\
    \ 89: true, 97: true}\n    var words = strings.Split(sentence, \" \")\n    var\
    \ primeWords []string\n    for _, word := range words {\n        if primeSet[len(word)]\
    \ {\n            primeWords = append(primeWords, word)\n        }\n    }\n   \
    \ return strings.Join(primeWords, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q72q92i_test.go:24:17: undefined: strings

    /tmp/tmp_q72q92i_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    if len(sentence)\
    \ == 0 {\n        return \"\"\n    }\n    var res []string\n    // Split the sentence\
    \ into words\n    words := strings.Split(sentence, \" \")\n    for _, word :=\
    \ range words {\n        if len(word) == 1 {\n            res = append(res, word)\n\
    \        } else {\n            // If word length is 2 or more, check for prime\
    \ numbers\n            if is_prime(len(word)) {\n                res = append(res,\
    \ word)\n            }\n        }\n    }\n    return strings.Join(res, \" \")\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9g6hbafv_test.go:28:14: undefined: strings

    /tmp/tmp9g6hbafv_test.go:34:16: undefined: is_prime

    /tmp/tmp9g6hbafv_test.go:39:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    r := []rune(sentence)\n\
    \    s := \"\"\n    for i := 0; i < len(r); i++ {\n        if r[i] == ' ' {\n\
    \            if is_prime(i) {\n                s += sentence[:i]\n           \
    \     break\n            }\n        }\n    }\n    for i := 0; i < len(r); i++\
    \ {\n        if r[i] == ' ' {\n            if is_prime(i - len(s)) {\n       \
    \         s += \" \" + sentence[len(s):i]\n            }\n        }\n    }\n \
    \   if is_prime(len(r) - len(s)) {\n        s += \" \" + sentence[len(s):]\n \
    \   }\n    return s\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfbmzt85y_test.go:27:16: undefined: is_prime

    /tmp/tmpfbmzt85y_test.go:35:16: undefined: is_prime

    /tmp/tmpfbmzt85y_test.go:40:8: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    result :=\
    \ \"\"\n    for _, word := range strings.Split(sentence, \" \") {\n        l :=\
    \ len(word)\n        if l <= 1 {\n            continue\n        }\n        if\
    \ l == 2 {\n            result += word + \" \"\n            continue\n       \
    \ }\n        if l % 2 == 0 {\n            continue\n        }\n        if is_prime(l)\
    \ {\n            result += word + \" \"\n        }\n    }\n    if len(result)\
    \ > 0 {\n        result = result[:len(result)-1]\n    }\n    return result\n}\n\
    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprl9_b5kr_test.go:24:26: undefined: strings

    /tmp/tmprl9_b5kr_test.go:36:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073529
