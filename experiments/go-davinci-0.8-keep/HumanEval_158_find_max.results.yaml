language: go_test.go
name: HumanEval_158_find_max
results:
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    count := 0\n    result := \"\"\n    for _, word := range words {\n  \
    \      if uc_count := unique_char_count(word); uc_count > count {\n          \
    \  count = uc_count\n            result = word\n        }\n    }\n    return result\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxjguae_z_test.go:19:24: undefined: unique_char_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    var max_word string\n    max_unique := 0\n    for _, word := range words\
    \ {\n        var unique int\n        var chars = make(map[rune]bool)\n       \
    \ for _, char := range word {\n            chars[char] = true\n        }\n   \
    \     for _, _ = range chars {\n            unique++\n        }\n        if unique\
    \ > max_unique {\n            max_unique = unique\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpvoi2bd5x_test.go:57: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpvoi2bd5x_test.go:57: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    m := make(map[string]int)\n    l := len(words)\n    for i := 0; i < l;\
    \ i++ {\n        m[words[i]] = len(word_to_set(words[i]))\n    }\n    max_s :=\
    \ \"\"\n    max_v := 0\n    for k, v := range m {\n        if max_v < v {\n  \
    \          max_v = v\n            max_s = k\n        }\n    }\n    return max_s\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy_8hh8z__test.go:19:27: undefined: word_to_set

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max_word := \"\"\n    max_chars := 0\n    for _, word := range words\
    \ {\n        chars := make(map[rune]bool)\n        // Count number of unique characters\n\
    \        for _, char := range word {\n            chars[char] = true\n       \
    \ }\n        // Select largest\n        if len(chars) > max_chars {\n        \
    \    max_chars = len(chars)\n            max_word = word\n        }\n    }\n \
    \   return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmxi6xl8x_test.go:55: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpmxi6xl8x_test.go:55: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max := 0\n    max_word := \"\"\n    for _, word := range words {\n  \
    \      count := make(map[rune]int)\n        for _, c := range word {\n       \
    \     count[c]++\n        }\n        if len(count) > max {\n            max =\
    \ len(count)\n            max_word = word\n        }\n    }\n    return max_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpd7x7xh9m_test.go:53: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpd7x7xh9m_test.go:53: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max := make(map[string]int)\n    unique := make(map[rune]bool)\n    for\
    \ _, v := range words {\n        for _, char := range v {\n            unique[char]\
    \ = true\n        }\n        max[v] = len(unique)\n        unique = make(map[rune]bool)\n\
    \    }\n    top := 0\n    for _, v := range max {\n        if v > top {\n    \
    \        top = v\n        }\n    }\n    res := \"\"\n    for k, v := range max\
    \ {\n        if v == top {\n            res = k\n            break\n        }\n\
    \    }\n    return res\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__2\
    \ (0.00s)\n        tmpjz7plk2h_test.go:63: expected 'aaaaaaa', got 'bb'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpjz7plk2h_test.go:63: expected\
    \ 'footbott', got 'this'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    if len(words) == 0 {\n        return \"\"\n    }\n    curr_max := make(map[rune]int)\n\
    \    result := words[0]\n    for _, word := range words {\n        word_count\
    \ := make(map[rune]int)\n        for _, rune := range word {\n            word_count[rune]++\n\
    \        }\n        if len(word_count) > len(curr_max) {\n            curr_max\
    \ = word_count\n            result = word\n        }\n    }\n    return result\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpzro_7aew_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpzro_7aew_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    var max_len = 0\n    var max_word = \"\"\n    for _, word := range words\
    \ {\n        map_word := make(map[byte]int)\n        for i := 0; i < len(word);\
    \ i++ {\n            map_word[word[i]] = 1\n        }\n        if len(map_word)\
    \ > max_len {\n            max_len = len(map_word)\n            max_word = word\n\
    \        } else if len(map_word) == max_len {\n            if word < max_word\
    \ {\n                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074410
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    word_map := make(map[string]int)\n    for _, word := range words {\n\
    \        word_map[word] = len(string_to_map(word))\n    }\n    fmt.Println(word_map)\n\
    \    max := 0\n    max_word := \"\"\n    for word, count := range word_map {\n\
    \        if count > max {\n            max = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8j0evmzy_test.go:18:30: undefined: string_to_map

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max_word := \"\"\n    max_count := 0\n    for _, word := range words\
    \ {\n        count := 0\n        chars := make(map[byte]bool)\n        for i :=\
    \ 0; i < len(word); i++ {\n            if _, ok := chars[word[i]]; !ok {\n   \
    \             chars[word[i]] = true\n                count++\n            }\n\
    \        }\n        if count > max_count {\n            max_count = count\n  \
    \          max_word = word\n        } else if count == max_count && word < max_word\
    \ {\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    var maxWord string\n    var maxCount int\n    var wordCount map[string]int\n\
    \n    // initialize the count as 1 for each character\n    wordCount = make(map[string]int)\n\
    \    for _, word := range words {\n        // if count is 1, then the character\
    \ is unique\n        for _, char := range word {\n            wordCount[string(char)]\
    \ = 1\n        }\n        // the number of unique characters will be the length\
    \ of the map\n        if len(wordCount) > maxCount {\n            maxCount = len(wordCount)\n\
    \            maxWord = word\n        }\n        // to clear the map for the next\
    \ iteration\n        for key := range wordCount {\n            delete(wordCount,\
    \ key)\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp7yattxh7_test.go:62: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp7yattxh7_test.go:62: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    if len(words) == 0 {\n        return \"\"\n    }\n    current_max :=\
    \ words[0]\n    current_max_len := len(makeSet(current_max))\n    for _, v :=\
    \ range words[1:] {\n        if l := len(makeSet(v)); l > current_max_len {\n\
    \            current_max = v\n            current_max_len = l\n        }\n   \
    \ }\n    return current_max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp81ta7dri_test.go:20:28: undefined: makeSet

    /tmp/tmp81ta7dri_test.go:22:21: undefined: makeSet

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max_word := \"\"\n    max_unique_chars := 0\n    for _, word := range\
    \ words {\n        unique_chars := 0\n        word_dict := make(map[rune]int)\n\
    \        for _, char := range word {\n            if _, found := word_dict[char];\
    \ !found {\n                unique_chars++\n                word_dict[char] =\
    \ 1\n            }\n        }\n        if unique_chars > max_unique_chars {\n\
    \            max_unique_chars = unique_chars\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpcvc53y0y_test.go:57: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpcvc53y0y_test.go:57: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    most_uniq_word := \"\"\n    max_num_uniq_chars := 0\n    for _, word\
    \ := range words {\n        num_uniq_chars := count_uniq_chars(word)\n       \
    \ if num_uniq_chars > max_num_uniq_chars {\n            max_num_uniq_chars = num_uniq_chars\n\
    \            most_uniq_word = word\n        }\n    }\n    return most_uniq_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkk0om3tt_test.go:19:27: undefined: count_uniq_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    var max string\n    var maxlen int\n    for _,v := range words {\n  \
    \      var m = make(map[byte]int)\n        var len int\n        for i:=0; i<len(v);\
    \ i++ {\n            if _, ok := m[v[i]]; !ok {\n                m[v[i]] = i\n\
    \                len++\n            }\n        }\n        if len > maxlen {\n\
    \            maxlen = len\n            max = v\n        } else if len == maxlen\
    \ {\n            if v < max {\n                max = v\n            }\n      \
    \  }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpti9rd2j6_test.go:21:21: invalid operation: cannot call non-function len
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    if len(words) == 0 {\n        return \"\"\n    }\n    maxWord, maxLen\
    \ := words[0], len(words[0])\n    for _, word := range words[1:] {\n        if\
    \ len(word) == maxLen {\n            if word < maxWord {\n                maxWord\
    \ = word\n            }\n        } else if len(word) > maxLen {\n            maxWord,\
    \ maxLen = word, len(word)\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__7\
    \ (0.00s)\n        tmpbz3tlxb8_test.go:54: expected 'this', got 'prrk'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max_word := \"\"\n    max_chars := 0\n    for _, word := range words\
    \ {\n        // fmt.Println(word)\n        if len(word) > max_chars {\n      \
    \      max_chars = len(word)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmphhhlkq35_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    var the_word string\n    the_length := 0\n    for _,word := range words\
    \ {\n        if len(word) > the_length {\n            the_length = len(word)\n\
    \            the_word = word\n        }\n    }\n    return the_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp_9_d1uob_test.go:49: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    max_word := \"\"\n    count := 0\n    for _, word := range words {\n\
    \        if count < len(word) {\n            max_word = word\n            count\
    \ = len(word)\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp9a5zodrp_test.go:49: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074410
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"])\
    \ == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"\
    aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc find_max(words []string) string\
    \ {\n    var max_word string\n    max_len := 0\n    for _, word := range words\
    \ {\n        if len(word) == max_len {\n            max_word = min_string(max_word,\
    \ word)\n        } else if len(word) > max_len {\n            max_word = word\n\
    \            max_len = len(word)\n        }\n    }\n    return max_word\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdw52wzr_test.go:20:24: undefined: min_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074410
