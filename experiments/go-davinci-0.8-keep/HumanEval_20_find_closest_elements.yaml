name: HumanEval_20_find_closest_elements
language: go_test.go
prompt: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  // (2.0, 2.2)\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n//\
  \ (2.0, 2.0)\nfunc find_closest_elements(numbers []float64) []interface{} {\n"
tests: "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
  \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
  \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
  \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
  \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(numbers) < 2 {\n        panic(\"find_closest_elements: must\
    \ be an array of at least 2 numbers\")\n    }\n    min_distance := numbers[1]\
    \ - numbers[0]\n    distance := 0.0\n    closest_indices := []int{0, 1}\n    for\
    \ i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            distance = numbers[j] - numbers[i]\n            if distance\
    \ < min_distance {\n                min_distance = distance\n                closest_indices\
    \ = []int{i, j}\n            }\n        }\n    }\n    return []interface{}{numbers[closest_indices[0]],\
    \ numbers[closest_indices[1]]}\n}\n", "    var smallest, largest, smallestDelta\
    \ float64\n    var smallestIndex int\n    var smallestDeltaSet bool\n    if len(numbers)\
    \ >= 2 {\n        smallest = numbers[0]\n        smallestIndex = 0\n        smallestDeltaSet\
    \ = false\n        for i, number := range numbers {\n            if i > 0 {\n\
    \                if smallestDeltaSet {\n                    delta := smallest\
    \ - number\n                    if delta < 0 {\n                        delta\
    \ = delta * -1\n                    }\n                    if delta < smallestDelta\
    \ {\n                        smallest = number\n                        smallestIndex\
    \ = i\n                        largest = numbers[i-1]\n                      \
    \  smallestDelta = delta\n                    }\n                } else {\n  \
    \                  smallestDelta = smallest - number\n                    if smallestDelta\
    \ < 0 {\n                        smallestDelta = smallestDelta * -1\n        \
    \            }\n                    smallestDeltaSet = true\n                }\n\
    \            }\n        }\n    }\n    return []interface{}{smallest, largest}\n\
    }\n", "    var closestElements = make([]interface{}, 2)\n    var closestNumbers\
    \ []float64\n\n    var distance float64\n    var closestDistance float64\n   \
    \ closestDistance = numbers[1] - numbers[0]\n\n    for i := 0; i < len(numbers)\
    \ - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance\
    \ = numbers[j] - numbers[i]\n            if distance < closestDistance {\n   \
    \             closestDistance = distance\n                closestNumbers = []float64{numbers[i],\
    \ numbers[j]}\n            }\n        }\n    }\n\n    closestElements[0] = closestNumbers[0]\n\
    \    closestElements[1] = closestNumbers[1]\n\n    return closestElements\n}\n",
  "    return []interface{}{numbers[0], numbers[1]}\n}\n", "    if len(numbers) <\
    \ 2 {\n        panic(\"Numbers need to have at least 2 elements.\")\n    }\n \
    \   var minDistance float64 = -1.0\n    var minNum1 float64 = -1.0\n    var minNum2\
    \ float64 = -1.0\n    for i := 0; i < len(numbers) - 1; i++ {\n        diff :=\
    \ numbers[i + 1] - numbers[i]\n        if (minDistance == -1.0) || (diff < minDistance)\
    \ {\n            minDistance = diff\n            minNum1 = numbers[i]\n      \
    \      minNum2 = numbers[i + 1]\n        }\n    }\n    return []interface{}{minNum1,\
    \ minNum2}\n}\n", "    var min, val1, val2 float64\n    min = 1.0\n    for _,\
    \ val1 = range numbers {\n        for _, val2 = range numbers {\n            if\
    \ val1 != val2 {\n                diff := val1 - val2\n                if diff\
    \ < 0 {\n                    diff = -diff\n                }\n               \
    \ if diff < min {\n                    min = diff\n                }\n       \
    \     }\n        }\n    }\n    return []interface{}{val1, val2}\n}\n", "    if\
    \ len(numbers) < 2 {\n        return []interface{}{}\n    }\n    closest_number1\
    \ := numbers[0]\n    closest_number2 := numbers[1]\n    diff := closest_number2\
    \ - closest_number1\n    for idx, number1 := range numbers {\n        for _, number2\
    \ := range numbers[idx+1:] {\n            if number2-number1 < diff {\n      \
    \          closest_number1 = number1\n                closest_number2 = number2\n\
    \                diff = number2 - number1\n            }\n        }\n    }\n \
    \   return []interface{}{closest_number1, closest_number2}\n}\n", "    var min_difference\
    \ float64 = math.MaxFloat64\n    var min_difference_pair []interface{}\n    var\
    \ left_index int = 0\n    var right_index int = 1\n    for right_index < len(numbers)\
    \ {\n        difference := math.Abs(numbers[left_index] - numbers[right_index])\n\
    \        if difference < min_difference {\n            min_difference = difference\n\
    \            min_difference_pair = []interface{}{numbers[left_index], numbers[right_index]}\n\
    \        }\n        left_index += 1\n        right_index += 1\n    }\n    return\
    \ min_difference_pair\n}\n", "    var closest []interface{}\n    lowestDiff :=\
    \ numbers[1] - numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if\
    \ numbers[i] - numbers[i-1] < lowestDiff {\n            lowestDiff = numbers[i]\
    \ - numbers[i-1]\n            closest = []interface{}{numbers[i-1], numbers[i]}\n\
    \        }\n    }\n    return closest\n}\n", "    /*\n    minDiff := math.MaxFloat64\n\
    \    closestElements := make([]interface{}, 2)\n    for i := 0; i < len(numbers)\
    \ - 1; i++ {\n        diff := numbers[i + 1] - numbers[i]\n        if diff < minDiff\
    \ {\n            minDiff = diff\n            closestElements[0] = numbers[i]\n\
    \            closestElements[1] = numbers[i + 1]\n        }\n    }\n    return\
    \ closestElements\n    */\n    minDiff := math.MaxFloat64\n    closestElements\
    \ := make([]interface{}, 2)\n    for i := 0; i < len(numbers) - 1; i++ {\n   \
    \     diff := numbers[i + 1] - numbers[i]\n        if diff < minDiff {\n     \
    \       minDiff = diff\n            closestElements[0] = numbers[i]\n        \
    \    closestElements[1] = numbers[i + 1]\n        }\n    }\n    return closestElements\n\
    }\n", "    closest_diff := numbers[1] - numbers[0]\n    closest_elements := []interface{}{numbers[0],\
    \ numbers[1]}\n    for i := 0; i < len(numbers) - 1; i++ {\n        diff := numbers[i\
    \ + 1] - numbers[i]\n        if diff < closest_diff {\n            closest_diff\
    \ = diff\n            closest_elements = []interface{}{numbers[i], numbers[i +\
    \ 1]}\n        }\n    }\n    return closest_elements\n}\n", "    sort(numbers)\n\
    \    var (\n        closest_distance,\n        diff float64\n        result =\
    \ make([]interface{}, 2)\n    )\n    for i := 0; i < len(numbers) - 1; i++ {\n\
    \        diff = numbers[i + 1] - numbers[i]\n        if closest_distance > diff\
    \ || closest_distance == 0 {\n            closest_distance = diff\n          \
    \  result[0] = numbers[i]\n            result[1] = numbers[i + 1]\n        }\n\
    \    }\n    return result\n}\n", "    var closest_elements []interface{}\n   \
    \ number_1 := numbers[0]\n    number_2 := numbers[1]\n    previous_difference\
    \ := number_2 - number_1\n    for i, number_1 := range numbers {\n        for\
    \ j, number_2 := range numbers {\n            if j > i {\n                difference\
    \ := number_2 - number_1\n                if difference < previous_difference\
    \ {\n                    closest_elements = []interface{}{number_1, number_2}\n\
    \                    previous_difference = difference\n                }\n   \
    \         }\n        }\n    }\n    return closest_elements\n}\n", "    first :=\
    \ numbers[0]\n    second := numbers[1]\n    min_diff := second - first\n    if\
    \ min_diff < 0 {\n        min_diff = -1 * min_diff\n    }\n    // fmt.Println(\"\
    First: \", first, \"Second: \", second, \"Min Diff: \", min_diff)\n    //fmt.Println(\"\
    Numbers: \", numbers)\n    for i := 0; i < len(numbers) - 1; i++ {\n        number\
    \ := numbers[i]\n        next := numbers[i + 1]\n        diff := next - number\n\
    \        if diff < 0 {\n            diff = -1 * diff\n        }\n        // fmt.Println(\"\
    Number: \", number, \"Next: \", next, \"Diff: \", diff)\n        if diff < min_diff\
    \ {\n            min_diff = diff\n            first = number\n            second\
    \ = next\n        }\n    }\n    return []interface{}{first, second}\n}\n", " \
    \   var closestDifference float64\n    var closestElements []interface{}\n   \
    \ for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            var difference float64\n            if numbers[i] < numbers[j]\
    \ {\n                difference = numbers[j] - numbers[i]\n            } else\
    \ {\n                difference = numbers[i] - numbers[j]\n            }\n   \
    \         if closestDifference == 0 || difference < closestDifference {\n    \
    \            closestDifference = difference\n                closestElements =\
    \ []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n   \
    \ return closestElements\n}\n", "    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    var minDist, dist float64\n    minDist = numbers[1] - numbers[0]\n\
    \    minNumbers := []interface{}{numbers[0], numbers[1]}\n    for i := 0; i <\
    \ len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n \
    \           dist = numbers[j] - numbers[i]\n            if dist < minDist {\n\
    \                minDist = dist\n                minNumbers = []interface{}{numbers[i],\
    \ numbers[j]}\n            }\n        }\n    }\n    return minNumbers\n}\n", " \
    \   closest := []interface{}{numbers[0], numbers[1]}\n    for i, _ := range numbers\
    \ {\n        for j, _ := range numbers {\n            if i != j {\n          \
    \      if abs(numbers[i] - numbers[j]) < abs(closest[0].(float64) - closest[1].(float64))\
    \ {\n                    closest = []interface{}{numbers[i], numbers[j]}\n   \
    \             }\n            }\n        }\n    }\n    return closest\n}\n", " \
    \   return []interface{}{1.0, 2.0}\n}\n", "    var minDiff float64 = numbers[1]\
    \ - numbers[0]\n    var minPair []float64 = []float64{numbers[0], numbers[1]}\n\
    \    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            if numbers[j] - numbers[i] < minDiff {\n                minDiff\
    \ = numbers[j] - numbers[i]\n                minPair = []float64{numbers[i], numbers[j]}\n\
    \            }\n        }\n    }\n    return []interface{}{minPair[0], minPair[1]}\n\
    }\n", "    var output []interface{}\n    var minDifference float64\n    for i,\
    \ _ := range numbers {\n        for j, _ := range numbers {\n            if j\
    \ == 0 {\n                minDifference = numbers[i] - numbers[j]\n          \
    \  } else {\n                // We just want the minimum positive difference.\n\
    \                if (numbers[i] - numbers[j]) > 0 && (numbers[i] - numbers[j])\
    \ < minDifference {\n                    minDifference = numbers[i] - numbers[j]\n\
    \                }\n            }\n        }\n    }\n    output = append(output,\
    \ minDifference)\n    return output\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
