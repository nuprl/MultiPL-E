name: HumanEval_6_parse_nested_parens
language: go_test.go
prompt: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  // [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string string) []int {\n"
tests: "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"),\
  \ expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
  ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"),\
  \ expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    results := make([]int, 0)\n    for _, group := range split_by_space(paren_string)\
    \ {\n        results = append(results, get_max_nesting_level(group))\n    }\n\
    \    return results\n}\n", "    depth := 0\n    max_depth := 0\n    result :=\
    \ []int{}\n    for _, char := range paren_string {\n        switch char {\n  \
    \      case '(':\n            depth += 1\n            if depth > max_depth {\n\
    \                max_depth = depth\n            }\n        case ')':\n       \
    \     depth -= 1\n        case ' ':\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n", "    res := make([]int,\
    \ 0)\n    for _, g := range split_space(paren_string) {\n        lvl := 0\n  \
    \      max_lvl := 0\n        for _, v := range g {\n            if v == '(' {\n\
    \                lvl += 1\n            } else if v == ')' {\n                if\
    \ lvl > max_lvl {\n                    max_lvl = lvl\n                }\n    \
    \            lvl -= 1\n            }\n        }\n        res = append(res, max_lvl)\n\
    \    }\n    return res\n}\n", "    max_depth := 0\n    curr_depth := 0\n    curr_depth_list\
    \ := []int{}\n    for _, char := range paren_string {\n        switch char {\n\
    \        case '(':\n            curr_depth += 1\n            if curr_depth > max_depth\
    \ {\n                max_depth = curr_depth\n            }\n        case ')':\n\
    \            curr_depth -= 1\n        case ' ':\n            curr_depth_list =\
    \ append(curr_depth_list, max_depth)\n            max_depth = 0\n            curr_depth\
    \ = 0\n        }\n    }\n    if max_depth > 0 {\n        curr_depth_list = append(curr_depth_list,\
    \ max_depth)\n    }\n    return curr_depth_list\n}\n", "    paren_list := make([]int,\
    \ 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        switch paren_string[i] {\n        case '(':\n            paren_stack\
    \ = append(paren_stack, len(paren_stack) + 1)\n        case ')':\n           \
    \ paren_list = append(paren_list, paren_stack[len(paren_stack) - 1])\n       \
    \     paren_stack = paren_stack[:len(paren_stack) - 1]\n        case ' ':\n  \
    \          continue\n        }\n    }\n    return paren_list\n}\n", "    var depths\
    \ []int\n    for _, s := range paren_string {\n        if s == '(' {\n       \
    \     dep := 1\n            for _, s := range paren_string {\n               \
    \ if s == '(' {\n                    dep++\n                } else if s == ')'\
    \ {\n                    dep--\n                }\n            }\n           \
    \ depths = append(depths, dep)\n        }\n    }\n    return depths\n}\n", " \
    \   max_levels := make([]int, 0)\n    paren_string = \" \" + paren_string + \"\
    \ \"\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == ' ' {\n            i += 1\n            j := i\n            level := 0\n \
    \           for paren_string[j] != ' ' {\n                if paren_string[j] ==\
    \ '(' {\n                    level += 1\n                } else if paren_string[j]\
    \ == ')' {\n                    level -= 1\n                }\n              \
    \  j += 1\n            }\n            max_levels = append(max_levels, level)\n\
    \            i = j\n        }\n    }\n    return max_levels\n}\n", "    // TODO(you):\
    \ Add code here to complete the task.\n    // NOTE: The value given for max_level\
    \ is only for convenience.\n    // You may or may not need to use it.\n    max_level\
    \ := 0\n    // Use this `level` variable to keep track of the current depth.\n\
    \    level := 0\n    // Use this `levels` variable to keep track of the maximum\
    \ depth\n    // at each position.\n    levels := []int{}\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n            max_level\
    \ = max(max_level, level)\n        } else if c == ')' {\n            level--\n\
    \        } else {\n            level = max(0, level)\n        }\n        levels\
    \ = append(levels, max_level)\n    }\n    return levels\n}\n", "    paren_groups\
    \ := strings.Split(paren_string, \" \")\n    max_levels := make([]int, len(paren_groups))\n\
    \    for i, paren_group := range paren_groups {\n        max_levels[i] = get_max_levels(paren_group)\n\
    \    }\n    return max_levels\n}\n", "    var paren_counts []int\n    var current_paren_count\
    \ int\n    var i int\n    for i = 0; i < len(paren_string); i++ {\n        if\
    \ paren_string[i] == '(' {\n            current_paren_count += 1\n        } else\
    \ if paren_string[i] == ')' {\n            paren_counts = append(paren_counts,\
    \ current_paren_count)\n            current_paren_count = 0\n        }\n    }\n\
    \    return paren_counts\n}\n", "    var result []int\n    var stack []rune\n\
    \    var depth int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            stack = append(stack, c)\n            depth++\n        } else\
    \ if c == ')' {\n            stack = stack[:len(stack)-1]\n            depth--\n\
    \        } else if c == ' ' {\n            result = append(result, depth)\n  \
    \      }\n    }\n    return result\n}\n", "    results := make([]int, 0)\n   \
    \ depth := 0\n    max_depth := 0\n    for _, char := range paren_string {\n  \
    \      if char == '(' {\n            depth += 1\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        } else if char\
    \ == ')' {\n            depth -= 1\n        } else if char == ' ' {\n        \
    \    results = append(results, max_depth)\n            max_depth = 0\n       \
    \     depth = 0\n        }\n    }\n    results = append(results, max_depth)\n\
    \    return results\n}\n", "    stack := make([]int, 0)\n    stack_index := 0\n\
    \    max_level := make([]int, 0)\n    for _, v := range paren_string {\n     \
    \   if v == '(' {\n            stack = append(stack, stack_index)\n          \
    \  stack_index += 1\n        } else if v == ')' {\n            stack = stack[:len(stack)-1]\n\
    \            max_level = append(max_level, stack_index-1)\n            stack_index\
    \ -= 1\n        }\n    }\n    return max_level\n}\n", "    max_nest := []int{}\n\
    \    for _, paren_substring := range str_to_substr(paren_string) {\n        max_nest\
    \ = append(max_nest, find_max_paren_nest(paren_substring))\n    }\n    return\
    \ max_nest\n}\n", "    var result []int\n    var level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         level++\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if char == ')' {\n            if level\
    \ == max_level {\n                result = append(result, max_level)\n       \
    \         max_level = 0\n            }\n            level--\n        }\n    }\n\
    \    return result\n}\n", "    const left_paren = \"(\"\n    const right_paren\
    \ = \")\"\n    // get the max depth of nesting level for each group.\n    var\
    \ depths []int\n    var depth int\n    for _, c := range paren_string {\n    \
    \    if string(c) == left_paren {\n            depth += 1\n        } else if string(c)\
    \ == right_paren {\n            depth -= 1\n        } else if c == ' ' {\n   \
    \         depths = append(depths, depth)\n            depth = 0\n        }\n \
    \   }\n    return depths\n}\n", "    // Fill this up\n    r := make([]int, 0)\n\
    \    is_left := false\n    is_right := false\n    r_num := 0\n    for _, s :=\
    \ range paren_string {\n        switch s {\n        case '(':\n            if\
    \ is_left {\n                r_num++\n            } else {\n                is_left\
    \ = true\n                r_num = 1\n            }\n        case ')':\n      \
    \      if is_right {\n                if r_num == 0 {\n                    r =\
    \ append(r, 0)\n                } else {\n                    r = append(r, r_num)\n\
    \                }\n                is_right = false\n                is_left\
    \ = false\n                r_num = 0\n            } else {\n                is_right\
    \ = true\n                r_num--\n            }\n        default:\n         \
    \   if is_left {\n                if r_num == 0 {\n                    r = append(r,\
    \ 0)\n                } else {\n                    r = append(r, r_num)\n   \
    \             }\n                is_left = false\n                r_num = 0\n\
    \            }\n            if is_right {\n                if r_num == 0 {\n \
    \                   r = append(r, 0)\n                } else {\n             \
    \       r = append(r, r_num)\n                }\n                is_right = false\n\
    \                r_num = 0\n            }\n        }\n    }\n    if is_left {\n\
    \        if r_num == 0 {\n            r = append(r, 0)\n        } else {\n   \
    \         r = append(r, r_num)\n        }\n    }\n    if is_right {\n        if\
    \ r_num == 0 {\n            r = append(r, 0)\n        } else {\n            r\
    \ = append(r, r_num)\n        }\n    }\n    return r\n}\n", "    fmt.Println(\"\
    >>>>>> parse_nested_parens\", paren_string)\n    i := 0\n    res := []int{}\n\
    \    max_level := 0\n    level := 0\n    for i < len(paren_string) {\n       \
    \ if paren_string[i] == '(' {\n            level++\n            if level > max_level\
    \ {\n                max_level = level\n            }\n        } else if paren_string[i]\
    \ == ')' {\n            level--\n        } else if paren_string[i] == ' ' {\n\
    \            res = append(res, max_level)\n            max_level = 0\n       \
    \     level = 0\n        }\n        i++\n    }\n    res = append(res, max_level)\n\
    \    return res\n}\n", "    // The output array for the result.\n    var output\
    \ []int\n\n    // The parentheses string split by spaces.\n    paren_list := make([]string,\
    \ 0)\n\n    // Init the paren_list.\n    for _, s := range paren_string {\n  \
    \      fmt.Println(string(s))\n        if string(s) == \" \" {\n            continue\n\
    \        } else {\n            paren_list = append(paren_list, string(s))\n  \
    \      }\n    }\n\n    for i := 0; i < len(paren_list); i++ {\n        // For\
    \ each of the parenthese, assume it has a nested level of 1.\n        // If this\
    \ is not the first character, assume it has the same level as the\n        //\
    \ previous character.\n        if i == 0 {\n            output = append(output,\
    \ 1)\n        } else {\n            output = append(output, output[i-1])\n   \
    \     }\n\n        if paren_list[i] == \"(\" {\n            output[i]++\n    \
    \    }\n    }\n\n    return output\n}\n", "    max_nest := 0\n    nest_counter\
    \ := 0\n    nest_levels := []int{}\n    for _, rune_char := range paren_string\
    \ {\n        char := string(rune_char)\n        if char == \"(\" {\n         \
    \   nest_counter += 1\n            if nest_counter > max_nest {\n            \
    \    max_nest = nest_counter\n            }\n        } else if char == \")\" {\n\
    \            nest_counter -= 1\n        } else if char == \" \" {\n          \
    \  nest_levels = append(nest_levels, max_nest)\n            max_nest = 0\n   \
    \         nest_counter = 0\n        }\n    }\n    nest_levels = append(nest_levels,\
    \ max_nest)\n    return nest_levels\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
