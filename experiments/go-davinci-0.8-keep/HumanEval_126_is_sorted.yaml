name: HumanEval_126_is_sorted
language: go_test.go
prompt: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Given a list of numbers, return whether or not they are sorted\n// in ascending\
  \ order. If list has more than 1 duplicate of the same\n// number, return False.\
  \ Assume no negative numbers and only integers.\n// Examples\n// is_sorted([5])\
  \ \u279E True\n// is_sorted([1, 2, 3, 4, 5]) \u279E True\n// is_sorted([1, 3, 2,\
  \ 4, 5]) \u279E False\n// is_sorted([1, 2, 3, 4, 5, 6]) \u279E True\n// is_sorted([1,\
  \ 2, 3, 4, 5, 6, 7]) \u279E True\n// is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279E False\n\
  // is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n// is_sorted([1, 2, 2, 2, 3, 4]) \u279E\
  \ False\nfunc is_sorted(lst []int) bool {\n"
tests: "func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
  \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5,\
  \ 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}),\
  \ expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected:\
  \ false },\n     { actual: candidate([]int{}), expected: true },\n     { actual:\
  \ candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}),\
  \ expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected:\
  \ false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n\
  \     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    sorted := true\n    max := 0\n    if len(lst) > 1 {\n        for\
    \ _, i := range lst {\n            if i < max {\n                sorted = false\n\
    \                break\n            }\n            max = i\n        }\n    }\n\
    \    return sorted\n}\n", "    var sorted bool = true\n    var saved int = 0\n\
    \    var deduped []int = []int{}\n    var dups bool = false\n    for _, value\
    \ := range lst {\n        if saved == value {\n            dups = true\n     \
    \   }\n        saved = value\n        deduped = append(deduped, value)\n    }\n\
    \    sorted = !dups\n    saved = 0\n    if sorted {\n        for _, value := range\
    \ deduped {\n            if saved > value {\n                sorted = false\n\
    \            }\n            saved = value\n        }\n    }\n    return sorted\n\
    }\n", "\tfor i := 1; i < len(lst); i++ {\n\t\tif lst[i] > lst[i-1] {\n\t\t\tcontinue\n\
    \t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "\tvar last\
    \ int\n\t\n\tfor i, v := range lst {\n\t\tif i == 0 {\n\t\t\tlast = v\n\t\t\t\
    continue\n\t\t}\n\t\tif v < last {\n\t\t\treturn false\n\t\t}\n\t\tlast = v\n\t\
    }\n\treturn true\n}\n", "    for i := 0; i < len(lst) - 1; i++ {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if len(lst) == 1 {\n        return true\n    }\n\n    prev := lst[0]\n\
    \    for _, curr := range lst[1:] {\n        if curr < prev {\n            return\
    \ false\n        }\n        prev = curr\n    }\n    return true\n}\n", "    if\
    \ len(lst) < 2 {\n        return true\n    }\n    prev := lst[0]\n    found_dup\
    \ := false\n    for _, val := range lst[1:] {\n        if val == prev {\n    \
    \        found_dup = true\n        }\n        if val < prev {\n            return\
    \ false\n        }\n        prev = val\n    }\n    return !found_dup\n}\n", " \
    \   fmt.Println(lst)\n    return true\n}\n", "    if len(lst) == 1 {\n       \
    \ return true\n    }\n    for i := 1; i < len(lst); i++ {\n        if lst[i] <\
    \ lst[i-1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    res := true\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] >= lst[i]\
    \ {\n            res = false\n            break\n        }\n    }\n    return\
    \ res\n}\n", "    var (\n        n = len(lst)\n        pre = lst[0]\n        sorted\
    \ = true\n    )\n    for i := 1; i < n; i++ {\n        if pre == lst[i] {\n  \
    \          return false\n        }\n        if lst[i] < pre {\n            sorted\
    \ = false\n        }\n        pre = lst[i]\n    }\n    return sorted\n}\n", " \
    \   // check if the lst has at least one element\n    if len(lst) < 1 {\n    \
    \    return false\n    }\n    // check if there are duplicates in lst\n    if\
    \ len(lst) != len(remove_duplicates(lst)) {\n        return false\n    }\n   \
    \ // check if the lst is sorted\n    sorted := true\n    for i := 1; i < len(lst);\
    \ i++ {\n        if lst[i] < lst[i-1] {\n            sorted = false\n        \
    \    break\n        }\n    }\n    return sorted\n}\n", "    // your code here\n\
    \    return false\n}\n", "    sorted := true\n    for i := 0; i < len(lst) - 1;\
    \ i++ {\n        if lst[i] >= lst[i + 1] {\n            sorted = false\n     \
    \       break\n        }\n    }\n    return sorted\n}\n", "    for idx, val :=\
    \ range lst {\n        if idx == 0 {\n            continue\n        }\n\n    \
    \    cur := lst[idx - 1]\n        if cur == val {\n            return false\n\
    \        }\n\n        if cur > val {\n            return false\n        }\n  \
    \  }\n\n    return true\n}\n", "    current_num := 0\n    for _, num := range\
    \ lst {\n        if current_num == num {\n            return false\n        }\n\
    \        current_num = num\n    }\n    return true\n}\n", "\tfor i := 1; i < len(lst);\
    \ i++ {\n\t\tif lst[i] <= lst[i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn\
    \ true\n}\n", "    if len(lst) <= 1 {\n        return true\n    }\n    for i :=\
    \ 1; i < len(lst); i++ {\n        if lst[i] < lst[i-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    if len(lst) <= 1 {\n        return\
    \ true\n    }\n    last := lst[0]\n    for _, x := range lst[1:] {\n        if\
    \ x < last {\n            return false\n        }\n        last = x\n    }\n \
    \   return true\n}\n", "    // your code here\n    var big, small int\n    big\
    \ = lst[0]\n    small = lst[0]\n    size := len(lst)\n    count := 0\n    if size\
    \ == 1 {\n        return true\n    }\n    for i := 0; i < size; i++ {\n      \
    \  if big < lst[i] {\n            big = lst[i]\n        }\n        if small >\
    \ lst[i] {\n            small = lst[i]\n        }\n    }\n    for i := 0; i <\
    \ size; i++ {\n        if lst[i] == big || lst[i] == small {\n            count\
    \ = count + 1\n        }\n    }\n    if count == size {\n        return true\n\
    \    }\n    return false\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
