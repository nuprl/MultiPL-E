name: HumanEval_111_histogram
language: go_test.go
prompt: "package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Given a string representing a space separated lowercase letters, return a dictionary\n\
  // of the letter with the most repetition and containing the corresponding count.\n\
  // If several letters have the same occurrence, return all of them.\n// Example:\n\
  // histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// histogram('a b b a') == {'a':\
  \ 2, 'b': 2}\n// histogram('a b c a b') == {'a': 2, 'b': 2}\n// histogram('b b b\
  \ b a') == {'b': 4}\n// histogram('') == {}\nfunc histogram(test string) map[string]int\
  \ {\n"
tests: "func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\"\
  : 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"\
  a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"\
  a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"\
  r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual:\
  \ candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual:\
  \ candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n\
  \     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"\
  a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // Instantiate map\n    histogram := make(map[string]int)\n\n \
    \   // Instantiate slice of strings\n    letters := []string{}\n\n    // Split\
    \ string into slice of strings\n    for _, letter := range test {\n        letters\
    \ = append(letters, string(letter))\n    }\n\n    // Loop through each letter,\n\
    \    // adding it to the histogram if it's not there yet,\n    // otherwise incrementing\
    \ it's corresponding value by 1\n    for _, letter := range letters {\n      \
    \  // If letter is in the histogram,\n        // increment it's corresponding\
    \ value by 1\n        if _, ok := histogram[letter]; ok {\n            histogram[letter]\
    \ += 1\n        } else {\n            // If letter is not in the histogram,\n\
    \            // add it and give it a value of 1\n            histogram[letter]\
    \ = 1\n        }\n    }\n\n    return histogram\n}\n", "    var result map[string]int\
    \ = make(map[string]int)\n    var max int = 0\n    var letters []string\n    if\
    \ len(test) == 0 {\n        return result\n    }\n    for _, char := range test\
    \ {\n        result[string(char)] += 1\n        if result[string(char)] > max\
    \ {\n            max = result[string(char)]\n            letters = append(letters[:0],\
    \ string(char))\n        } else if result[string(char)] == max {\n           \
    \ letters = append(letters, string(char))\n        }\n    }\n    for _, value\
    \ := range letters {\n        result[value] = max\n    }\n    return result\n\
    }\n", "    // hint: use a make(map[string]int) instead of a var to declare a map.\n\
    \    // for string manipulation use strings.Fields(test) to split the string\n\
    \    // into a slice of words\n    // https://golang.org/pkg/strings/#Fields\n\
    \    hist := make(map[string]int)\n    var max int\n    // answer\n    for _,\
    \ v := range strings.Fields(test) {\n        hist[v]++\n        if hist[v] > max\
    \ {\n            max = hist[v]\n        }\n    }\n    for k, v := range hist {\n\
    \        if v != max {\n            delete(hist, k)\n        }\n    }\n    return\
    \ hist\n}\n", "    letterMap := make(map[string]int)\n    max := 0\n    for _,\
    \ letter := range test {\n        letterMap[string(letter)]++\n        if letterMap[string(letter)]\
    \ > max {\n            max = letterMap[string(letter)]\n        }\n    }\n   \
    \ histogram := make(map[string]int)\n    for k, v := range letterMap {\n     \
    \   if v == max {\n            histogram[k] = v\n        }\n    }\n    return\
    \ histogram\n}\n", "    if len(test) == 0 {\n        return map[string]int{}\n\
    \    }\n\n    max_count := 0\n    letter_count := make(map[string]int)\n    letters\
    \ := \"\"\n\n    for _, l := range test {\n        c := string(l)\n        letter_count[c]\
    \ += 1\n        if letter_count[c] > max_count {\n            max_count = letter_count[c]\n\
    \            letters = c\n        } else if letter_count[c] == max_count {\n \
    \           letters += c\n        }\n    }\n\n    result := make(map[string]int)\n\
    \    for _, l := range letters {\n        result[string(l)] = max_count\n    }\n\
    \n    return result\n}\n", "    m := make(map[string]int)\n    fmt.Println(test)\n\
    \    for _, v := range test {\n        m[string(v)]++\n    }\n    return m\n}\n",
  "    m := make(map[string]int)\n    if test == \"\" {\n        return m\n    }\n\
    \    for _, v := range test {\n        if _, ok := m[string(v)]; ok {\n      \
    \      m[string(v)]++\n        } else {\n            m[string(v)] = 1\n      \
    \  }\n    }\n    return m\n}\n", "    var count map[string]int\n    count = make(map[string]int)\n\
    \    for _, char := range test {\n        count[string(char)]++\n    }\n    return\
    \ count\n}\n", "    //TODO: implement this function.\n    return nil\n}\n", " \
    \   chars := map[string]int{}\n    max := 0\n    top := []string{}\n    for _,\
    \ ch := range test {\n        _, ok := chars[string(ch)]\n        if ok {\n  \
    \          chars[string(ch)]++\n        } else {\n            chars[string(ch)]\
    \ = 1\n        }\n        if chars[string(ch)] > max {\n            max = chars[string(ch)]\n\
    \            top = []string{string(ch)}\n        } else if chars[string(ch)] ==\
    \ max {\n            top = append(top, string(ch))\n        }\n    }\n    char_map\
    \ := map[string]int{}\n    for _, t := range top {\n        char_map[t] = max\n\
    \    }\n    return char_map\n}\n", "    letters := make(map[string]int)\n    //\
    \ Create a slice of letters\n    // Create a map of letter frequencies\n    //\
    \ Loop through the slice of letters and add to map if letter is not there\n  \
    \  //          otherwise add one to the count.\n    return letters\n}\n", "  \
    \  //TODO: Implement\n    return nil\n}\n", "    var letterMap = make(map[string]int)\n\
    \    for _, letter := range test {\n        if _, present := letterMap[string(letter)];\
    \ present {\n            letterMap[string(letter)] += 1\n        } else {\n  \
    \          letterMap[string(letter)] = 1\n        }\n    }\n    return letterMap\n\
    }\n", "    hist := make(map[string]int)\n    for _,v := range test {\n       \
    \ hist[string(v)] = hist[string(v)] + 1\n    }\n    return hist\n}\n", "    count\
    \ := make(map[string]int)\n    max := 0\n    most := \"\"\n    for _, char :=\
    \ range test {\n        count[string(char)]++\n        if count[string(char)]\
    \ >= max {\n            max = count[string(char)]\n            most = string(char)\n\
    \        }\n    }\n    fmt.Println(count)\n    fmt.Println(max)\n    fmt.Println(most)\n\
    \    return nil\n}\n", "    hist := make(map[string]int)\n    for _, letter :=\
    \ range test {\n        hist[string(letter)] += 1\n    }\n    return hist\n}\n",
  "    var result map[string]int = make(map[string]int)\n    var value int = 0\n \
    \   var max int = 0\n    var max_string string = \"\"\n    var max_array []string\
    \ = make([]string, 0)\n\n    for _, char := range test {\n        value = result[string(char)]\n\
    \        result[string(char)] = value + 1\n    }\n\n    for key, value := range\
    \ result {\n        if value > max {\n            max = value\n            max_string\
    \ = key\n            max_array = make([]string, 0)\n            max_array = append(max_array,\
    \ max_string)\n        } else if value == max {\n            max_array = append(max_array,\
    \ key)\n        }\n    }\n\n    result = make(map[string]int)\n    for _, key\
    \ := range max_array {\n        result[key] = max\n    }\n\n    return result\n\
    }\n", "    var count map[string]int\n    var max int\n    count = make(map[string]int)\n\
    \    for _, c := range test {\n        count[string(c)] += 1\n        if max <\
    \ count[string(c)] {\n            max = count[string(c)]\n        }\n    }\n \
    \   for key, value := range count {\n        if value != max {\n            delete(count,\
    \ key)\n        }\n    }\n    return count\n}\n", "    letters := make(map[string]int)\n\
    \    for _, letter := range test {\n        letters[string(letter)]++\n    }\n\
    \    return letters\n}\n", "    h := make(map[string]int)\n    for _, c := range\
    \ test {\n        _, ok := h[string(c)]\n        if ok {\n            h[string(c)]++\n\
    \        } else {\n            h[string(c)] = 1\n        }\n    }\n    max_count\
    \ := 0\n    max_letters := make(map[string]int)\n    for k, v := range h {\n \
    \       if v > max_count {\n            max_count = v\n            max_letters\
    \ = make(map[string]int)\n            max_letters[k] = v\n        } else if v\
    \ == max_count {\n            max_letters[k] = v\n        }\n    }\n    return\
    \ max_letters\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
