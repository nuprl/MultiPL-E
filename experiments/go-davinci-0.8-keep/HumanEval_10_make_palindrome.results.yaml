language: go_test.go
name: HumanEval_10_make_palindrome
results:
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    sLen := len(myString)\n\
    \    // find the longest palindromic suffix for the string\n    for i := sLen\
    \ - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            return\
    \ myString + reverse(myString[:i])\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptarwftyg_test.go:22:12: undefined: is_palindrome

    /tmp/tmptarwftyg_test.go:23:31: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find the longest\
    \ postfix that is palindrome.\n    length := len(myString)\n    if length == 0\
    \ {\n        return \"\"\n    }\n    // We start from the end of the string.\n\
    \    // We test whether the prefix is a palindrome.\n    for i := length - 1;\
    \ i >= 0; i-- {\n        if is_palindrome(myString[0:i+1]) {\n            return\
    \ myString + reverse(myString[i+1:length])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdtppdssg_test.go:27:12: undefined: is_palindrome

    /tmp/tmpdtppdssg_test.go:28:31: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    result := \"\"\
    \n    palindrome_suffix := \"\"\n    for i := 0; i < len(myString); i++ {\n  \
    \      if myString[i] == myString[len(myString) - 1 - i] {\n            palindrome_suffix\
    \ = myString[i:]\n        } else {\n            break\n        }\n    }\n    if\
    \ len(palindrome_suffix) == len(myString) {\n        return myString\n    }\n\
    \    result = myString\n    reversed_prefix := \"\"\n    for i := 0; i < len(myString)\
    \ - len(palindrome_suffix); i++ {\n        reversed_prefix = string(myString[i])\
    \ + reversed_prefix\n    }\n    result += reversed_prefix\n    return result\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp0bavm5_0_test.go:57: expected 'xyzyx', got 'xyzzyx'\n  \
    \  --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp0bavm5_0_test.go:57:\
    \ expected 'xyx', got 'xyxyx'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n\
    \        tmp0bavm5_0_test.go:57: expected 'jerryrrej', got 'jerryyrrej'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromePos := 0\n    strLen := len(myString)\n    //\
    \ Go over all possible palindromes.\n    for i := 0; i < strLen; i++ {\n     \
    \   // First, check if the longest palindrome is 3 characters long.\n        if\
    \ i + 1 < strLen && myString[i] == myString[i + 1] {\n            // We know myString[i]\
    \ == myString[i + 1]. Let's check if the rest is a palindrome.\n            if\
    \ (i == 0 || myString[i - 1] == myString[i + 2]) && (i + 2 > longestPalindromePos)\
    \ {\n                longestPalindrome = myString[i : i + 3]\n               \
    \ longestPalindromePos = i + 2\n            }\n        }\n        // Second, check\
    \ if the longest palindrome is 4 characters long.\n        if i + 2 < strLen &&\
    \ myString[i] == myString[i + 2] {\n            // We know myString[i] == myString[i\
    \ + 2]. Let's check if the rest is a palindrome.\n            if (i == 0 || myString[i\
    \ - 1] == myString[i + 3]) && (i + 3 > longestPalindromePos) {\n             \
    \   longestPalindrome = myString[i : i + 4]\n                longestPalindromePos\
    \ = i + 3\n            }\n        }\n    }\n    return myString + reverse(myString[:longestPalindromePos])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw4ze2lnk_test.go:19:5: longestPalindrome declared but not used

    /tmp/tmpw4ze2lnk_test.go:41:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ <= 1 {\n        return myString\n    }\n    L := len(myString)\n    max_lps\
    \ := 0\n    string_lps := \"\"\n    i := 0\n    while i < L {\n        j := L\n\
    \        for j - i > max_lps {\n            if myString[i:j] == reverse(myString[i:j])\
    \ {\n                max_lps = j - i\n                string_lps = myString[i:j]\n\
    \            }\n            j--\n        }\n        i++\n    }\n    return myString\
    \ + reverse(myString[0:(L - max_lps)])\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5m722evk_test.go:26:11: expected '';'', found i

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075435
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var length = len(myString)\n\
    \    if length == 0 {\n        return \"\"\n    }\n    var longest_palindrome_start\
    \ = longest_palindrome_start_index(myString)\n    var prefix = myString[:longest_palindrome_start]\n\
    \    var palindrome = myString + reverse(prefix)\n    return palindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpynn_ln1d_test.go:23:36: undefined: longest_palindrome_start_index

    /tmp/tmpynn_ln1d_test.go:25:33: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if is_palindrome(myString)\
    \ {\n        return myString\n    }\n    myLength := len(myString)\n    // Loop\
    \ through characters of myString.\n    for i := myLength - 1; i > 0; i-- {\n \
    \       if is_palindrome(myString[i:]) {\n            return fmt.Sprintf(\"%s%s\"\
    , myString, reverse(myString[:i]))\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4512uja__test.go:19:8: undefined: is_palindrome

    /tmp/tmp4512uja__test.go:25:12: undefined: is_palindrome

    /tmp/tmp4512uja__test.go:26:50: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ == 0 {\n        return \"\"\n    }\n    suffix_palindrome := find_suffix_palindrome(myString)\n\
    \    prefix := myString[:len(myString) - len(suffix_palindrome)]\n    return prefix\
    \ + reverse(suffix_palindrome) + suffix_palindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0u14p6xn_test.go:22:26: undefined: find_suffix_palindrome

    /tmp/tmp0u14p6xn_test.go:24:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // Find longest\
    \ palindromic suffix\n    var palindromic_suffix string\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            palindromic_suffix\
    \ = myString[i:]\n            break\n        }\n    }\n    // Reverse the prefix\
    \ that comes before the palindromic suffix\n    var reversed_prefix string\n \
    \   for i := 0; i < len(myString) - len(palindromic_suffix); i++ {\n        reversed_prefix\
    \ += string(myString[i])\n    }\n    // Append the reversed prefix to the end\
    \ of the string\n    return myString + reverse(reversed_prefix)\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5paxyjw_test.go:22:12: undefined: is_palindrome

    /tmp/tmpt5paxyjw_test.go:33:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ <= 1 {\n        return myString\n    }\n    postfix_len := 0\n    prefix_start\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == myString[len(myString)\
    \ - 1 - i] {\n            postfix_len += 1\n        } else {\n            prefix_start\
    \ = i\n            break\n        }\n    }\n    if postfix_len == len(myString)\
    \ {\n        return myString\n    }\n    prefix := myString[0:prefix_start]\n\
    \    postfix := myString[len(myString) - postfix_len:]\n    return postfix + make_palindrome(prefix)\
    \ + prefix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpmw0_ttm7_test.go:57: expected 'xyzyx', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmw0_ttm7_test.go:57: expected\
    \ 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    prefix := myString\n\
    \    postfix := \"\"\n    for i := len(myString); i > 0; i-- {\n        if is_palindrome(prefix)\
    \ {\n            break\n        }\n        postfix = prefix[len(prefix)-1:] +\
    \ postfix\n        prefix = prefix[:len(prefix)-1]\n    }\n    //fmt.Println(prefix,\
    \ postfix)\n    return myString + reverse(postfix)\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp228clvxf_test.go:22:12: undefined: is_palindrome

    /tmp/tmp228clvxf_test.go:29:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ == 0 {\n        return \"\"\n    }\n    for i := len(myString); i > 0; i-- {\n\
    \        if palindrome_check(myString[:i]) {\n            return myString + reverse(myString[:len(myString)\
    \ - i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz3jq_vub_test.go:23:12: undefined: palindrome_check

    /tmp/tmpz3jq_vub_test.go:24:31: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ == 0 {\n        return \"\"\n    }\n    // Find the longest palindromic suffix\
    \ of a supplied string.\n    for i := 0; i < len(myString); i++ {\n        //\
    \ Consider each character of a supplied string in turn.\n        if is_palindrome(myString[i:])\
    \ {\n            // This is a palindromic suffix.\n            var result string\n\
    \            result = myString[:i]\n            // Reverse the remaining prefix\
    \ of the string and append it to a palindromic suffix.\n            result +=\
    \ reverse(myString[:i])\n            return result\n        }\n    }\n    // This\
    \ is an ordinary string with no palindromic suffix.\n    return myString + reverse(myString)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp11nkuugb_test.go:25:12: undefined: is_palindrome

    /tmp/tmp11nkuugb_test.go:30:23: undefined: reverse

    /tmp/tmp11nkuugb_test.go:35:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ <= 1 {\n        return myString\n    }\n    j := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        if myString[i] == myString[j] {\n            j++\n\
    \        }\n    }\n    if j == len(myString) {\n        return myString\n    }\n\
    \    suffix := myString[j:]\n    return suffix + make_palindrome(myString[:j])\
    \ + reverse(suffix)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaimemsu9_test.go:32:53: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if myString ==\
    \ \"\" {\n        return \"\"\n    }\n    if is_palindrome(myString) {\n     \
    \   return myString\n    }\n    // lps is the longest palindromic substring beginning\
    \ at index i\n    lps := make([]int, len(myString))\n    lps[0] = 0\n    for i\
    \ := 1; i < len(myString); i++ {\n        if myString[i] == myString[lps[i-1]]\
    \ {\n            lps[i] = lps[i-1] + 1\n        } else {\n            lps[i] =\
    \ 0\n        }\n    }\n    // append the reverse of prefix that comes before the\
    \ palindromic suffix\n    return myString + reverse(myString[:len(myString)-lps[len(myString)-1]])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt2oa062e_test.go:22:8: undefined: is_palindrome

    /tmp/tmpt2oa062e_test.go:36:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    var suffix string\n\
    \    var prefLen int\n    for i := len(myString); i > 0; i-- {\n        if is_palindrome(myString[:i])\
    \ {\n            suffix = myString[i:]\n            prefLen = len(myString) -\
    \ i\n            break\n        }\n    }\n    prefix := reverse(myString[:prefLen])\n\
    \    return prefix + myString + suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf5fw6mdd_test.go:22:12: undefined: is_palindrome

    /tmp/tmpf5fw6mdd_test.go:28:15: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    // trivial cases:\
    \ empty string or one character string are palindromes\n    if myString == \"\"\
    \ || len(myString) == 1 {\n        return myString\n    }\n    // find the length\
    \ of the longest palindromic suffix\n    palindromeLength := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n       \
    \     palindromeLength = len(myString) - i\n            break\n        }\n   \
    \ }\n    // append the reverse of a prefix to the end of the string\n    return\
    \ myString + reverse(myString[:len(myString) - palindromeLength])\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphkv4nkqj_test.go:26:12: undefined: is_palindrome

    /tmp/tmphkv4nkqj_test.go:32:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    revString := []rune(myString)\n\
    \    for i, j := 0, len(revString)-1; i < j; i, j = i+1, j-1 {\n        revString[i],\
    \ revString[j] = revString[j], revString[i]\n    }\n    return myString + string(revString)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpr744fo1__test.go:43: expected 'x', got 'xx'\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpr744fo1__test.go:43: expected\
    \ 'xyzyx', got 'xyzzyx'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n\
    \        tmpr744fo1__test.go:43: expected 'xyx', got 'xyxxyx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpr744fo1__test.go:43: expected 'jerryrrej', got 'jerryyrrej'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    if len(myString)\
    \ <= 1 {\n        return myString\n    }\n    // Search through the string for\
    \ a palindromic suffix.\n    for index := len(myString); index > 0; index-- {\n\
    \        suffix := myString[index-1:]\n        if is_palindrome(suffix) {\n  \
    \          // Found a palindromic suffix.\n            prefix := myString[:index-1]\n\
    \            // Return the prefix followed by the reverse of the prefix.\n   \
    \         return myString + reverse(prefix)\n        }\n    }\n    // All else\
    \ failed: return the string followed by its reverse.\n    return myString + reverse(myString)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7f6wzdvu_test.go:25:12: undefined: is_palindrome

    /tmp/tmp7f6wzdvu_test.go:29:31: undefined: reverse

    /tmp/tmp7f6wzdvu_test.go:33:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n\
    // ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n\
    // 'catac'\nfunc make_palindrome(myString string) string {\n    str_length :=\
    \ len(myString)\n    // Start from the end of the string and find a palindrome\
    \ sub-string.\n    for i := str_length - 1; i >= 0; i-- {\n        // The palindrome\
    \ should be at least of length 2.\n        if str_length - i < 2 {\n         \
    \   continue\n        }\n        // If a string is a palindrome.\n        if is_palindrome(myString[i:])\
    \ {\n            return myString + reverse(myString[:i])\n        }\n    }\n \
    \   // If the whole string is not a palindrome just append the reverse of the\
    \ string to itself.\n    return myString + reverse(myString)\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbwu9lnyl_test.go:27:12: undefined: is_palindrome

    /tmp/tmpbwu9lnyl_test.go:28:31: undefined: reverse

    /tmp/tmpbwu9lnyl_test.go:32:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075436
