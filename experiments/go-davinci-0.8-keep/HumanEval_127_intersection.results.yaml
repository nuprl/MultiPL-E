language: go_test.go
name: HumanEval_127_intersection
results:
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1 > end1 {\n\
    \        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n        start2,\
    \ end2 = end2, start2\n    }\n    if start1 > end2 || start2 > end1 {\n      \
    \  return \"NO\"\n    }\n    if start1 > start2 {\n        start1 = start2\n \
    \   }\n    if end1 < end2 {\n        end1 = end2\n    }\n    length := end1 -\
    \ start1 + 1\n    if length < 2 {\n        return \"NO\"\n    }\n    if length\
    \ < 4 {\n        return \"YES\"\n    }\n    if length % 2 == 0 {\n        return\
    \ \"NO\"\n    }\n    for i := 3; i * i <= length; i += 2 {\n        if length\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmph16xfn1h_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmph16xfn1h_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmph16xfn1h_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  i1, i2 := interval1[0].(int), interval1[1].(int)\n    j1, j2 := interval2[0].(int),\
    \ interval2[1].(int)\n    start, end := -1, -1\n    if i1 <= j1 && j1 <= i2 {\n\
    \        start = j1\n    }\n    if i1 <= j2 && j2 <= i2 {\n        end = j2\n\
    \    }\n    if i1 >= j1 && i1 <= j2 {\n        start = i1\n    }\n    if i2 >=\
    \ j1 && i2 <= j2 {\n        end = i2\n    }\n    if start == -1 && end == -1 {\n\
    \        return \"NO\"\n    }\n    len := end - start\n    // fmt.Println(i1,\
    \ i2, j1, j2, start, end, len)\n    if len <= 1 {\n        return \"NO\"\n   \
    \ }\n    if len == 2 {\n        return \"YES\"\n    }\n    for i := 2; i <= len;\
    \ i++ {\n        if len % i == 0 {\n            return \"NO\"\n        }\n   \
    \ }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    iStart := 0\n    iEnd\
    \ := 0\n    if start1 > start2 {\n        iStart = start1\n    } else {\n    \
    \    iStart = start2\n    }\n    if end1 < end2 {\n        iEnd = end1\n    }\
    \ else {\n        iEnd = end2\n    }\n    if iStart > iEnd {\n        return \"\
    NO\"\n    }\n    if (iEnd - iStart) == 1 {\n        return \"YES\"\n    }\n  \
    \  if (iEnd - iStart) % 2 == 0 {\n        return \"NO\"\n    }\n    if (iEnd -\
    \ iStart) % 3 == 0 {\n        return \"NO\"\n    }\n    if (iEnd - iStart) % 5\
    \ == 0 {\n        return \"NO\"\n    }\n    if (iEnd - iStart) % 7 == 0 {\n  \
    \      return \"NO\"\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmp10f3vgdr_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmp10f3vgdr_test.go:82: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmp10f3vgdr_test.go:82: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp10f3vgdr_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1 < start2 ||\
    \ end2 < start1 {\n        return \"NO\"\n    }\n    if start1 > start2 {\n  \
    \      start1 = start2\n    }\n    if end1 < end2 {\n        end1 = end2\n   \
    \ }\n    count := 0\n    for i := start1; i <= end1; i++ {\n        if i >= start2\
    \ && i <= end2 {\n            count++\n        }\n    }\n    if count == 2 ||\
    \ count == 3 || count == 5 || count == 7 {\n        return \"YES\"\n    }\n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmph8vixav4_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmph8vixav4_test.go:70: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmph8vixav4_test.go:70: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmph8vixav4_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmph8vixav4_test.go:70: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1 > end1 {\n\
    \        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n        start2,\
    \ end2 = end2, start2\n    }\n    start := max(start1, start2)\n    end := min(end1,\
    \ end2)\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq9yyp319_test.go:35:14: undefined: max

    /tmp/tmpq9yyp319_test.go:36:12: undefined: min

    /tmp/tmpq9yyp319_test.go:40:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1 > end1 {\n\
    \        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n        start2,\
    \ end2 = end2, start2\n    }\n    if start1 > end2 || start2 > end1 {\n      \
    \  return \"NO\"\n    }\n    if start1 >= start2 {\n        start1 = start2\n\
    \    }\n    if end1 <= end2 {\n        end1 = end2\n    }\n    if start1 > end1\
    \ {\n        return \"NO\"\n    }\n    if end1 - start1 == 1 {\n        return\
    \ \"YES\"\n    }\n    for i := 2; i <= end1 - start1; i++ {\n        if (end1\
    \ - start1) % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp7yz2l2td_test.go:78: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp7yz2l2td_test.go:78: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmp7yz2l2td_test.go:78: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmp7yz2l2td_test.go:78: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    intersection := []int{}\n\
    \    // Check if the intervals intersects\n    if start1 > end2 || start2 > end1\
    \ {\n        return \"NO\"\n    }\n    // Check if the start1 is less than start2\n\
    \    if start1 < start2 {\n        intersection = append(intersection, start2)\n\
    \    } else {\n        intersection = append(intersection, start1)\n    }\n  \
    \  // Check if the end1 is less than end2\n    if end1 < end2 {\n        intersection\
    \ = append(intersection, end1)\n    } else {\n        intersection = append(intersection,\
    \ end2)\n    }\n    return checkIsPrime(intersection[1] - intersection[0])\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmzi9zalq_test.go:46:12: undefined: checkIsPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n\t\
    start1 := interval1[0].(int)\n\tend1 := interval1[1].(int)\n\tstart2 := interval2[0].(int)\n\
    \tend2 := interval2[1].(int)\n\tintersectionLength := 0\n\tintersectionStart :=\
    \ 0\n\t// first, determine if the two intervals intersect\n\tif start1 <= start2\
    \ && end1 >= start2 {\n\t\tintersectionStart = start2\n\t\tif end1 < end2 {\n\t\
    \t\tintersectionLength = end1 - start2 + 1\n\t\t} else {\n\t\t\tintersectionLength\
    \ = end2 - start2 + 1\n\t\t}\n\t} else if start2 <= start1 && end2 >= start1 {\n\
    \t\tintersectionStart = start1\n\t\tif end2 < end1 {\n\t\t\tintersectionLength\
    \ = end2 - start1 + 1\n\t\t} else {\n\t\t\tintersectionLength = end1 - start1\
    \ + 1\n\t\t}\n\t} else {\n\t\treturn \"NO\"\n\t}\n\t// then, determine if the\
    \ length of the intersection is a prime number\n\tif intersectionLength <= 2 {\n\
    \t\treturn \"NO\"\n\t}\n\tisPrime := true\n\tfor i := 2; i < intersectionLength;\
    \ i++ {\n\t\tif intersectionLength % i == 0 {\n\t\t\tisPrime = false\n\t\t\tbreak\n\
    \t\t}\n\t}\n\tif isPrime {\n\t\treturn \"YES\"\n\t} else {\n\t\treturn \"NO\"\n\
    \t}\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9bkeazt__test.go:30:2: intersectionStart declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  var a, b int\n    var c, d int\n    if interval1[0].(int) <= interval1[1].(int)\
    \ {\n        a = interval1[0].(int)\n        b = interval1[1].(int)\n    } else\
    \ {\n        a = interval1[1].(int)\n        b = interval1[0].(int)\n    }\n \
    \   if interval2[0].(int) <= interval2[1].(int) {\n        c = interval2[0].(int)\n\
    \        d = interval2[1].(int)\n    } else {\n        c = interval2[1].(int)\n\
    \        d = interval2[0].(int)\n    }\n    var x int\n    if a <= c {\n     \
    \   x = c\n    } else {\n        x = a\n    }\n    var y int\n    if b <= d {\n\
    \        y = b\n    } else {\n        y = d\n    }\n    if x > y {\n        return\
    \ \"NO\"\n    }\n    var isPrime = true\n    for i := 2; i < y - x + 1; i++ {\n\
    \        if y - x + 1 == i {\n            break\n        }\n        if (y - x\
    \ + 1) % i == 0 {\n            isPrime = false\n            break\n        }\n\
    \    }\n    if isPrime {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpqv9ruo39_test.go:92: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpqv9ruo39_test.go:92: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpqv9ruo39_test.go:92: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpqv9ruo39_test.go:92: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpqv9ruo39_test.go:92: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    ints := []int{start1,\
    \ end1, start2, end2}\n    sort.Ints(ints)\n    // fmt.Println(ints)\n    start,\
    \ end := ints[1], ints[2]\n    if start < end {\n        return isPrime(end -\
    \ start)\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyb7l_eww_test.go:30:5: undefined: sort

    /tmp/tmpyb7l_eww_test.go:34:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpfcpgsycm_test.go:48: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpfcpgsycm_test.go:48: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpfcpgsycm_test.go:48:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpfcpgsycm_test.go:48: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpfcpgsycm_test.go:48: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpfcpgsycm_test.go:48: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpfcpgsycm_test.go:48:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpfcpgsycm_test.go:48: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start := interval1[0].(int)\n    end := interval1[1].(int)\n    s := interval2[0].(int)\n\
    \    e := interval2[1].(int)\n    count := 0\n    if s > end || e < start {\n\
    \        return \"NO\"\n    }\n    for i := s; i <= e; i++ {\n        if i >=\
    \ start && i <= end {\n            count++\n        }\n    }\n    for i := 2;\
    \ i < count; i++ {\n        if count % i == 0 {\n            return \"NO\"\n \
    \       }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp0wxtxlm__test.go:66: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp0wxtxlm__test.go:66: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp0wxtxlm__test.go:66: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp0wxtxlm__test.go:66: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp0wxtxlm__test.go:66: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n    intersection := []int{}\n    if interval1[0].(int)\
    \ < interval2[0].(int) {\n        intersection = append(intersection, interval2[0].(int))\n\
    \    } else {\n        intersection = append(intersection, interval1[0].(int))\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        intersection\
    \ = append(intersection, interval1[1].(int))\n    } else {\n        intersection\
    \ = append(intersection, interval2[1].(int))\n    }\n    if intersection[1] -\
    \ intersection[0] <= 1 {\n        return \"NO\"\n    }\n    for i := 2; i < intersection[1]\
    \ - intersection[0]; i++ {\n        if (intersection[1] - intersection[0]) % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  a, b := interval1[0].(int), interval1[1].(int)\n    c, d := interval2[0].(int),\
    \ interval2[1].(int)\n    if c < a {\n        a, b, c, d = c, d, a, b\n    }\n\
    \    if c > b {\n        return \"NO\"\n    }\n    if d < b {\n        b = d\n\
    \    }\n    return isPrime(b - c + 1)\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp23nj2cj_test.go:36:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start := 0\n    end := 0\n    if interval1[0].(int) >= interval2[0].(int) {\n\
    \        start = interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n\
    \    }\n    if interval1[1].(int) <= interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    if start == end {\n        return \"YES\"\n\
    \    }\n    if start < 0 {\n        for i := -1; i >= start; i-- {\n         \
    \   if end % i == 0 {\n                return \"NO\"\n            }\n        }\n\
    \    } else {\n        for i := 2; i <= end; i++ {\n            if end % i ==\
    \ 0 {\n                return \"NO\"\n            }\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpfun8pjgz_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpfun8pjgz_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmpfun8pjgz_test.go:79: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3\
    \ (0.00s)\n        tmpfun8pjgz_test.go:79: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpfun8pjgz_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpfun8pjgz_test.go:79: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  if len(interval1) != 2 || len(interval2) != 2 {\n        return \"NO\"\n  \
    \  }\n    i1 := interval1[0].(int)\n    j1 := interval1[1].(int)\n    i2 := interval2[0].(int)\n\
    \    j2 := interval2[1].(int)\n    if i1 >= j1 || i2 >= j2 {\n        return \"\
    NO\"\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n    }\n    if j1 < j2\
    \ {\n        j1, j2 = j2, j1\n    }\n    if i2 >= j1 {\n        return \"NO\"\n\
    \    }\n    if i2 < j1 && i2 > i1 {\n        return isPrime(j1 - i2)\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpskp8yuu4_test.go:45:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  var start interface{}\n    var end interface{}\n    if interval1[0].(int) <\
    \ interval2[0].(int) {\n        start = interval2[0]\n    } else {\n        start\
    \ = interval1[0]\n    }\n    if interval1[1].(int) < interval2[1].(int) {\n  \
    \      end = interval1[1]\n    } else {\n        end = interval2[1]\n    }\n \
    \   if end.(int) - start.(int) < 0 {\n        return \"NO\"\n    }\n    prime\
    \ := true\n    for i := start.(int); i <= end.(int); i++ {\n        for j := i;\
    \ j <= end.(int); j++ {\n            if i != j && i % j == 0 {\n             \
    \   prime = false\n                break\n            }\n        }\n        if\
    \ !prime {\n            break\n        }\n    }\n    if prime {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpmzjx6rk2_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpmzjx6rk2_test.go:78: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpmzjx6rk2_test.go:78: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpmzjx6rk2_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpmzjx6rk2_test.go:78: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpmzjx6rk2_test.go:78: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    length := end1 - start1\n\
    \    for i := start1; i <= end1; i++ {\n        for j := start2; j <= end2; j++\
    \ {\n            if i == j {\n                length--\n            }\n      \
    \  }\n    }\n    if length <= 0 {\n        return \"NO\"\n    }\n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    if length == 2 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpi_q2u2dr_test.go:74: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpi_q2u2dr_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  min, max := 0, 0\n    if interval1[0].(int) < interval2[0].(int) {\n      \
    \  min = interval2[0].(int)\n    } else {\n        min = interval1[0].(int)\n\
    \    }\n    if interval1[1].(int) > interval2[1].(int) {\n        max = interval2[1].(int)\n\
    \    } else {\n        max = interval1[1].(int)\n    }\n    // fmt.Println(min,\
    \ max)\n    if min > max {\n        return \"NO\"\n    }\n    count := 0\n   \
    \ for i := min; i <= max; i++ {\n        count++\n    }\n    if count < 2 {\n\
    \        return \"NO\"\n    }\n    for i := 2; i <= count / 2; i++ {\n       \
    \ if count % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpsbn1ff78_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpsbn1ff78_test.go:75: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075394
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc\
    \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n  \
    \  if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n    if interval1[0].(int) < interval2[0].(int)\
    \ {\n        return isPrime(interval2[0].(int) - interval1[1].(int))\n    }\n\
    \    return isPrime(interval1[0].(int) - interval2[1].(int))\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0tmld0to_test.go:29:16: undefined: isPrime

    /tmp/tmp0tmld0to_test.go:31:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075394
