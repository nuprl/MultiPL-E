language: go_test.go
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    // TODO\n\
    \    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp8eelg0it_test.go:58: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp8eelg0it_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp8eelg0it_test.go:58: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp8eelg0it_test.go:58:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp8eelg0it_test.go:58: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp8eelg0it_test.go:58:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    return nil\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpuh1w3bge_test.go:57: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpuh1w3bge_test.go:57: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpuh1w3bge_test.go:57: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    var evens\
    \ []int\n    var evensIndex []int\n    var answer []int\n    var counter int\n\
    \    var smallestEven int\n    var smallestEvenIndex int\n    for _, v := range\
    \ arr {\n        if v % 2 == 0 {\n            evens = append(evens, v)\n     \
    \       evensIndex = append(evensIndex, counter)\n        }\n        counter +=\
    \ 1\n    }\n    if len(evens) > 0 {\n        smallestEven = evens[0]\n       \
    \ smallestEvenIndex = evensIndex[0]\n        for _, v := range evens {\n     \
    \       if v < smallestEven {\n                smallestEven = v\n            \
    \    smallestEvenIndex = evensIndex[counter]\n            }\n            counter\
    \ += 1\n        }\n        answer = append(answer, smallestEven)\n        answer\
    \ = append(answer, smallestEvenIndex)\n    }\n    return answer\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [4]\
    \ with length 2 [recovered]\n\tpanic: runtime error: index out of range [4] with\
    \ length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513680, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513680,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck({0xc0000f5d18, 0x3, 0x685?})\n\t/tmp/tmp72rsjene_test.go:53\
    \ +0x25c\ncommand-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp72rsjene_test.go:70\
    \ +0x87\ntesting.tRunner(0xc0001a0340, 0x528f98)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    // TODO\n\
    \    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp8eelg0it_test.go:58: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp8eelg0it_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp8eelg0it_test.go:58: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp8eelg0it_test.go:58:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp8eelg0it_test.go:58: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp8eelg0it_test.go:58:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp_89fvzr6_test.go:57: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp_89fvzr6_test.go:57:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp_89fvzr6_test.go:57: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp_89fvzr6_test.go:57:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp_89fvzr6_test.go:57: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp_89fvzr6_test.go:57:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074308
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    // your code\
    \ here\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpjuzdpzto_test.go:58: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpjuzdpzto_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpjuzdpzto_test.go:58: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpjuzdpzto_test.go:58:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpjuzdpzto_test.go:58: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpjuzdpzto_test.go:58:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074306
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    // Your code\
    \ here\n    var evens []int\n    var indexes []int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            evens = append(evens, v)\n         \
    \   indexes = append(indexes, i)\n        }\n    }\n    var min int\n    var minindex\
    \ int\n    if len(evens) > 0 {\n        min = evens[0]\n        minindex = indexes[0]\n\
    \        for i, v := range evens {\n            if v < min {\n               \
    \ min = v\n                minindex = indexes[i]\n            }\n        }\n \
    \   }\n    return []int{min, minindex}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__2 (0.00s)\n\
    \        tmptee8_sgt_test.go:78: expected '[]', got '[%!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmptee8_sgt_test.go:78:\
    \ expected '[]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    var index\
    \ int\n    var value int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if value == 0 {\n                index = i\n                value\
    \ = v\n            } else if v < value {\n                index = i\n        \
    \        value = v\n            }\n        }\n    }\n    if value == 0 {\n   \
    \     return []int{}\n    }\n    return []int{value, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp1r6qsrqd_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp1r6qsrqd_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    smallest := 0\n    smallest_index\
    \ := 0\n    if isEven(arr[0]) {\n        smallest = arr[0]\n        smallest_index\
    \ = 0\n    } else {\n        smallest = -1\n    }\n    for i := 1; i < len(arr);\
    \ i++ {\n        if isEven(arr[i]) {\n            if smallest == -1 {\n      \
    \          smallest = arr[i]\n                smallest_index = i\n           \
    \ } else if arr[i] < smallest {\n                smallest = arr[i]\n         \
    \       smallest_index = i\n            }\n        }\n    }\n    if smallest ==\
    \ -1 {\n        return []int{}\n    }\n    return []int{smallest, smallest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph2v4wl58_test.go:39:8: undefined: isEven

    /tmp/tmph2v4wl58_test.go:46:12: undefined: isEven

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074495
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    min := -1\n    minIndex := -1\n \
    \   for i, v := range arr {\n        if v % 2 == 0 {\n            if minIndex\
    \ == -1 || v < min {\n                min = v\n                minIndex = i\n\
    \            }\n        }\n    }\n    if minIndex == -1 {\n        return []int{}\n\
    \    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074495
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    // smallest\
    \ even = 2\n    // find the node with the smallest even value in the array\n \
    \   // if multiple nodes with the same smallest even value return the node that\
    \ has the smallest index\n    // the plucked node should be returned in a list\n\
    \    // if there are no even values or the given array is empty, return []\n \
    \   var smallest int\n    smallest = 10000\n    smallestIndex := 0\n    evens\
    \ := []int{}\n    for i, v := range arr {\n        if (v % 2 == 0) {\n       \
    \     if (v < smallest) {\n                smallest = v\n                smallestIndex\
    \ = i\n            }\n            evens = append(evens, v)\n        }\n    }\n\
    \    if (len(evens) == 0) {\n        return []int{}\n    }\n    return []int{smallest,\
    \ smallestIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    return nil\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpuh1w3bge_test.go:57: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpuh1w3bge_test.go:57: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpuh1w3bge_test.go:57: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    minValue := arr[0]\n    for _, n\
    \ := range arr {\n        if n % 2 == 0 && n < minValue {\n            minValue\
    \ = n\n        }\n    }\n    if minValue % 2 != 0 {\n        return []int{}\n\
    \    }\n    for i, n := range arr {\n        if n == minValue {\n            return\
    \ []int{n, i}\n        }\n    }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpojrf4hi2_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    var retArr\
    \ []int\n    retArr = make([]int, 0)\n    if len(arr) == 0 {\n        return retArr\n\
    \    }\n    var smallestEven int\n    smallestEven = 1\n    var smallestEvenIdx\
    \ int\n    smallestEvenIdx = -1\n    for idx, elem := range arr {\n        if\
    \ elem % 2 == 0 {\n            if elem < smallestEven {\n                smallestEven\
    \ = elem\n                smallestEvenIdx = idx\n            }\n        }\n  \
    \  }\n    if smallestEvenIdx == -1 {\n        return retArr\n    }\n    retArr\
    \ = append(retArr, smallestEven)\n    retArr = append(retArr, smallestEvenIdx)\n\
    \    return retArr\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpzwdcart0_test.go:79: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpzwdcart0_test.go:79:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpzwdcart0_test.go:79: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpzwdcart0_test.go:79:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    // return\
    \ value\n    r := []int{}\n    // find the smallest even value\n    sev := 0\n\
    \    for _, elm := range arr {\n        if elm % 2 == 0 {\n            if sev\
    \ == 0 {\n                sev = elm\n            } else if elm < sev {\n     \
    \           sev = elm\n            }\n        }\n    }\n    // in case it's an\
    \ odd array\n    if sev == 0 {\n        return r\n    }\n    // find the smallest\
    \ index of the smallest even value\n    si := 0\n    for idx, elm := range arr\
    \ {\n        if elm == sev {\n            si = idx\n            break\n      \
    \  }\n    }\n    // append to the return value and return\n    r = append(r, sev,\
    \ si)\n    return r\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpzk7p6_i8_test.go:84: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpzk7p6_i8_test.go:84:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    return nil\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpuh1w3bge_test.go:57: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpuh1w3bge_test.go:57: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpuh1w3bge_test.go:57: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpuh1w3bge_test.go:57:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    smallestEven := -1\n    smallestEvenIdx\
    \ := -1\n    for i, num := range arr {\n        if num % 2 == 0 {\n          \
    \  if smallestEven == -1 || num < smallestEven {\n                smallestEven\
    \ = num\n                smallestEvenIdx = i\n            }\n        }\n    }\n\
    \    if smallestEvenIdx == -1 {\n        return []int{}\n    }\n    return []int{smallestEven,\
    \ smallestEvenIdx}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074495
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    smallest_even := -1\n    smallest_even_index\
    \ := -1\n    for i, value := range arr {\n        if value % 2 == 0 {\n      \
    \      if smallest_even == -1 {\n                smallest_even = value\n     \
    \           smallest_even_index = i\n            } else if value < smallest_even\
    \ {\n                smallest_even = value\n                smallest_even_index\
    \ = i\n            }\n        }\n    }\n    if smallest_even_index == -1 {\n \
    \       return []int{}\n    }\n    return []int{smallest_even, smallest_even_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    var res []int\n\
    \    if len(arr) == 0 {\n        return res\n    }\n    var sm int\n    sm = arr[0]\n\
    \    for _, v := range arr {\n        if v > sm && v % 2 == 0 {\n            sm\
    \ = v\n        }\n    }\n    if sm % 2 != 0 {\n        return res\n    }\n   \
    \ res = append(res, sm)\n    for i, v := range arr {\n        if v == sm {\n \
    \           res = append(res, i)\n            break\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmprlfnidue_test.go:78: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n        tmprlfnidue_test.go:78:\
    \ expected '[%!s(int=0) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmprlfnidue_test.go:78: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmprlfnidue_test.go:78: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=8)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmprlfnidue_test.go:78:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp_89fvzr6_test.go:57: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp_89fvzr6_test.go:57:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp_89fvzr6_test.go:57: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp_89fvzr6_test.go:57:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp_89fvzr6_test.go:57: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp_89fvzr6_test.go:57:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074308
