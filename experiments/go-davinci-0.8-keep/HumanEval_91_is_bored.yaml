name: HumanEval_91_is_bored
language: go_test.go
prompt: "package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ You'll be given a string of words, and your task is to count the number\n// of\
  \ boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences\
  \ are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\"\
  )\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
  )\n// 1\nfunc is_bored(S string) int {\n"
tests: "func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"\
  Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"),\
  \ expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual:\
  \ candidate(\"I feel good today. I will be productive. will kill It\"), expected:\
  \ 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected:\
  \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
  \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    count := 0\n    for _, word := range words(S) {\n        if word\
    \ == \"I\" {\n            count++\n        }\n    }\n    return count\n}\n", " \
    \   cnt := 0\n    for i, _ := range S {\n        if S[i] == 'I' {\n          \
    \  cnt++\n        }\n    }\n    return cnt\n}\n", "    if len(S) == 0 {\n    \
    \    return 0\n    }\n    b := 0\n    for _, ss := range S {\n        if ss ==\
    \ 'I' {\n            b += 1\n        }\n    }\n    return b\n}\n", "    var i,\
    \ n int\n    var c byte\n    for i, n = 0, 0; i < len(S); i++ {\n        c = S[i]\n\
    \        if c == '.' || c == '?' || c == '!' {\n            if S[i-1] == 'I' {\n\
    \                n++\n            }\n        }\n    }\n    return n\n}\n", " \
    \   var boredoms int\n    boredoms = 0\n    sentences := make([]string, 0)\n \
    \   sentences = append(sentences, string(S[0]))\n    word := string(S[0])\n  \
    \  for i := 1; i < len(S); i++ {\n        if S[i] == '.' || S[i] == '?' || S[i]\
    \ == '!' {\n            sentences = append(sentences, word)\n            word\
    \ = \"\"\n        } else {\n            word += string(S[i])\n        }\n    }\n\
    \    for _, sentence := range sentences {\n        if len(sentence) > 0 && sentence[0]\
    \ == 'I' {\n            boredoms++\n        }\n    }\n    return boredoms\n}\n",
  "    // your code here\n    return 0\n}\n", "    if len(S) < 1 {\n        return\
    \ 0\n    }\n    n := 0\n    boredoms := []rune{'.', '?', '!'}\n    sentences :=\
    \ strings.Split(S, \"\")\n    for _, s := range sentences {\n        if s[0] ==\
    \ \"I\" {\n            n++\n        }\n    }\n    return n\n}\n", "    return\
    \ 4\n}\n", "    var boredoms int = 0\n    var sentence []rune\n    var sentences\
    \ []string\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var is_uppercase\
    \ bool = false\n    var is_i bool = false\n    var sentence_len int\n    sentence\
    \ = []rune(S)\n    for i < len(sentence) {\n        for j = i; j < len(sentence);\
    \ j++ {\n            if j == 0 {\n                is_uppercase = is_upper(sentence[j])\n\
    \            }\n            if sentence[j] == '.' || sentence[j] == '?' || sentence[j]\
    \ == '!' {\n                if is_i {\n                    sentences = append(sentences,\
    \ string(sentence[i:j]))\n                    break\n                }\n     \
    \       }\n            if sentence[j] == 'I' {\n                is_i = true\n\
    \            }\n        }\n        i = j + 1\n    }\n    for k = 0; k < len(sentences);\
    \ k++ {\n        sentence_len = len(sentences[k])\n        if is_upper([]rune(sentences[k])[0])\
    \ && is_upper([]rune(sentences[k])[1]) {\n            if sentences[k][sentence_len\
    \ - 1] == '.' {\n                boredoms += 1\n            }\n        }\n   \
    \ }\n    return boredoms\n}\n", "    return 0\n}\n", "    var boredoms int = 0\n\
    \    var i, j int = 0, 0\n    var s_len int = len(S)\n    var bored bool = false\n\
    \    for i < s_len {\n        if S[i] == 'I' {\n            i += 1\n         \
    \   bored = true\n        }\n        if bored && S[i] == ' ' {\n            i\
    \ += 1\n        }\n        if bored && (S[i] == '.' || S[i] == '?' || S[i] ==\
    \ '!') {\n            boredoms += 1\n            i += 1\n            bored = false\n\
    \        }\n        for j = i; j < s_len; j++ {\n            if S[j] == '.' ||\
    \ S[j] == '?' || S[j] == '!' {\n                break\n            }\n       \
    \ }\n        i = j\n    }\n    return boredoms\n}\n", "    return 0\n}\n", " \
    \   n := 0\n    for _, s := range S {\n        if s == 'I' {\n            n++\n\
    \        }\n    }\n    return n\n}\n", "    if len(S) == 0 {\n        return 0\n\
    \    }\n    boredoms := 0\n    sentences := 0\n    lastChar := ' '\n    for _,\
    \ char := range S {\n        if lastChar == ' ' && char == 'I' {\n           \
    \ boredoms++\n        }\n        if lastChar == '.' || lastChar == '?' || lastChar\
    \ == '!' {\n            sentences++\n        }\n        lastChar = char\n    }\n\
    \    if lastChar == '.' || lastChar == '?' || lastChar == '!' {\n        sentences++\n\
    \    }\n    return boredoms\n}\n", "    boredoms := 0\n    sentences := strings.Split(S,\
    \ \".!? \")\n    for _, sentence := range sentences {\n        if sentence[0]\
    \ == 'I' {\n            boredoms += 1\n        }\n    }\n    return boredoms\n\
    }\n", "    boredoms := 0\n    for _, sentence := range split_sentences(S) {\n\
    \        if(sentence[0] == 'I') {\n            boredoms++\n        }\n    }\n\
    \    return boredoms\n}\n", "    var boredoms int = 0\n    var is_start bool =\
    \ false\n    var sentence []string\n    var sentence_end rune = '.'\n    var sentence_temp\
    \ string = \"\"\n    for _, v := range S {\n        if !is_start {\n         \
    \   if v != ' ' {\n                sentence_temp += string(v)\n            }\n\
    \            if v == '.' || v == '?' || v == '!' {\n                is_start =\
    \ true\n                sentence_end = v\n            }\n        } else {\n  \
    \          if v != ' ' {\n                sentence_temp += string(v)\n       \
    \     }\n            if v == sentence_end {\n                is_start = false\n\
    \                sentence = append(sentence, sentence_temp)\n                sentence_temp\
    \ = \"\"\n            }\n        }\n    }\n    for _, s := range sentence {\n\
    \        if string(s[0]) == \"I\" {\n            boredoms += 1\n        }\n  \
    \  }\n    return boredoms\n}\n", "    var boredoms int = 0\n    for _, c := range\
    \ S {\n        if c == 'I' {\n            boredoms += 1\n        }\n    }\n  \
    \  return boredoms\n}\n", "    sentences := []string{}\n    for _, val := range\
    \ S {\n        fmt.Println(string(val))\n    }\n    return 0\n}\n", "    boredoms\
    \ := 0\n    for _, r := range S {\n        if string(r) == \"I\" {\n         \
    \   boredoms += 1\n        }\n    }\n    return boredoms\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
