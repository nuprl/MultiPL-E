name: HumanEval_118_get_closest_vowel
language: go_test.go
prompt: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You are given a word. Your task is to find the closest vowel that stands\
  \ between \n// two consonants from the right side of the word (case sensitive).\n\
  // Vowels in the beginning and ending doesn't count. Return empty string if you\
  \ didn't\n// find any vowel met the above condition. \n// You may assume that the\
  \ given string contains English letter only.\n// Example:\n// get_closest_vowel(\"\
  yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"\
  quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nfunc get_closest_vowel(word\
  \ string) string {\n"
tests: "func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
  \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
  easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n\
  \     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
  bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
  \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
  ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n\
  \     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"\
  Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\"\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    runes := []rune(word)\n    if len(runes) == 0 {\n        return\
    \ \"\"\n    }\n\n    if len(runes) == 1 {\n        return \"\"\n    }\n\n    var\
    \ vowels = make(map[rune]bool)\n    vowels['a'] = true\n    vowels['e'] = true\n\
    \    vowels['i'] = true\n    vowels['o'] = true\n    vowels['u'] = true\n\n  \
    \  var consonants = make(map[rune]bool)\n    consonants['b'] = true\n    consonants['c']\
    \ = true\n    consonants['d'] = true\n    consonants['f'] = true\n    consonants['g']\
    \ = true\n    consonants['h'] = true\n    consonants['j'] = true\n    consonants['k']\
    \ = true\n    consonants['l'] = true\n    consonants['m'] = true\n    consonants['n']\
    \ = true\n    consonants['p'] = true\n    consonants['q'] = true\n    consonants['r']\
    \ = true\n    consonants['s'] = true\n    consonants['t'] = true\n    consonants['v']\
    \ = true\n    consonants['w'] = true\n    consonants['x'] = true\n    consonants['y']\
    \ = true\n    consonants['z'] = true\n\n    for i := len(runes) - 1; i > 0; i--\
    \ {\n        if consonants[runes[i]] {\n            if vowels[runes[i - 1]] {\n\
    \                return string(runes[i - 1])\n            }\n        }\n    }\n\
    \n    return \"\"\n}\n", "    // your code\n    var vowels = \"AEIOUaeiou\"\n\
    \    var candidate string\n    var current_index int\n    var current_char rune\n\
    \    var num_consonants int\n\n    for i := len(word) - 1; i >= 0; i-- {\n   \
    \     current_char = rune(word[i])\n        current_index = -1\n        for j\
    \ := 0; j < len(vowels); j++ {\n            if current_char == rune(vowels[j])\
    \ {\n                current_index = j\n                break\n            }\n\
    \        }\n        if current_index != -1 {\n            if num_consonants >\
    \ 1 {\n                return string(current_char)\n            } else {\n   \
    \             candidate = string(current_char)\n            }\n        } else\
    \ {\n            num_consonants++\n        }\n    }\n    return candidate\n}\n",
  "\t// your code goes here\n\treturn \"\"\n}\n", '    vowels := map[rune]', "   \
    \ var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var result string\n\
    \    var prev_is_consonant = false\n    var next_is_consonant = false\n    for\
    \ i, c := range word {\n        next_is_consonant = false\n        if contains(vowels,\
    \ string(c)) {\n            if i == 0 {\n                prev_is_consonant = true\n\
    \            } else {\n                prev_is_consonant = !contains(vowels, string(word[i-1]))\n\
    \            }\n            if i == len(word)-1 {\n                next_is_consonant\
    \ = true\n            } else {\n                next_is_consonant = !contains(vowels,\
    \ string(word[i+1]))\n            }\n            if prev_is_consonant && next_is_consonant\
    \ {\n                result = string(c)\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n", "    // your code here\n    return\
    \ \"\"\n}\n", "    for i:=len(word)-1; i>=0; i-- {\n        switch word[i] {\n\
    \        case 'a':\n            if i+1 < len(word) && is_const(word[i+1]) {\n\
    \                return string(word[i])\n            }\n        case 'e':\n  \
    \          if i+1 < len(word) && is_const(word[i+1]) {\n                return\
    \ string(word[i])\n            }\n        case 'i':\n            if i+1 < len(word)\
    \ && is_const(word[i+1]) {\n                return string(word[i])\n         \
    \   }\n        case 'o':\n            if i+1 < len(word) && is_const(word[i+1])\
    \ {\n                return string(word[i])\n            }\n        case 'u':\n\
    \            if i+1 < len(word) && is_const(word[i+1]) {\n                return\
    \ string(word[i])\n            }\n        default:\n            continue\n   \
    \     }\n    }\n    return \"\"\n}\n", "    vowels := map[rune]bool{'a': true,\
    \ 'e': true, 'i': true, 'o': true, 'u': true}\n    last_consonant := rune(-1)\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[rune(word[i])] {\n\
    \            if last_consonant == -1 {\n                return \"\"\n        \
    \    }\n            return string(word[i])\n        }\n        last_consonant\
    \ = rune(word[i])\n    }\n    return \"\"\n}\n", "\t// your code here\n}\n", " \
    \   // your code here\n    return \"\"\n}\n", "    for i := len(word) - 2; i >=\
    \ 0; i-- {\n        fmt.Println(i)\n        if isVowel(word[i+1]) {\n        \
    \    continue\n        }\n        if isVowel(word[i]) {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n", "    vowels := map[string]int{\"a\"\
    :1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    var (\n        i, index int\n   \
    \     lastVowel string\n    )\n    for i = len(word) - 1; i >= 0; i-- {\n    \
    \    if _, ok := vowels[string(word[i])]; ok {\n            lastVowel = string(word[i])\n\
    \            index = i\n            break\n        }\n    }\n    if lastVowel\
    \ == \"\" {\n        return \"\"\n    }\n    for i = index - 1; i >= 0; i-- {\n\
    \        if _, ok := vowels[string(word[i])]; !ok {\n            return lastVowel\n\
    \        }\n    }\n    return \"\"\n}\n", "    // your code goes here\n    const\
    \ vowels = \"aeiouAEIOU\"\n    var result rune = 0\n    last_found := 0\n    for\
    \ i,c := range word {\n        if last_found == 0 {\n            if strings.Contains(vowels,\
    \ string(c)) {\n                last_found = i\n            }\n        } else\
    \ {\n            if !strings.Contains(vowels, string(c)) {\n                result\
    \ = word[last_found]\n                break\n            }\n        }\n    }\n\
    \    return string(result)\n}\n", "    if word == \"\" {\n        return \"\"\n\
    \    }\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var\
    \ result = \"\"\n    var lastIndex = len(word) - 1\n    var lastVowelIndex = -1\n\
    \    for i := lastIndex; i >= 0; i-- {\n        if isVowel(vowels, string(word[i]))\
    \ {\n            lastVowelIndex = i\n            break\n        }\n    }\n   \
    \ if lastVowelIndex == -1 {\n        return \"\"\n    }\n    if lastVowelIndex\
    \ == lastIndex {\n        return \"\"\n    }\n    var lastConsonantIndex = lastVowelIndex\
    \ + 1\n    for i := lastConsonantIndex; i <= lastIndex; i++ {\n        if !isVowel(vowels,\
    \ string(word[i])) {\n            lastConsonantIndex = i\n            break\n\
    \        }\n    }\n    if lastConsonantIndex == lastIndex {\n        return \"\
    \"\n    }\n    if lastConsonantIndex == lastVowelIndex + 1 {\n        return \"\
    \"\n    }\n    result = string(word[lastVowelIndex])\n    return result\n}\n",
  "    // code here\n    return \"\"\n}\n", "    if len(word) <= 2 {\n        return\
    \ \"\"\n    }\n    vowels := map[string]int {\n        \"a\": 0,\n        \"e\"\
    : 0,\n        \"i\": 0,\n        \"o\": 0,\n        \"u\": 0,\n    }\n    for\
    \ i, value := range word {\n        _, ok := vowels[string(value)]\n        if\
    \ ok {\n            vowels[string(value)] = i\n        }\n    }\n    idx, min\
    \ := -1, -1\n    for k, v := range vowels {\n        if v == 0 {\n           \
    \ continue\n        }\n        if idx == -1 {\n            idx = v\n         \
    \   min = v\n        } else {\n            if idx < v && v - idx < min {\n   \
    \             min = v - idx\n                idx = v\n            }\n        }\n\
    \    }\n    return string(word[idx])\n}\n", "    var vowels = \"aeiou\"\n    var\
    \ isConsonant = true\n    var closest = \"\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[0] == word[i] || vowels[1] == word[i] || vowels[2]\
    \ == word[i] || vowels[3] == word[i] || vowels[4] == word[i] {\n            if\
    \ !isConsonant {\n                closest = string(word[i])\n                break\n\
    \            }\n        } else {\n            isConsonant = true\n        }\n\
    \    }\n    return closest\n}\n", "    // your code here\n    return \"\"\n}\n",
  "\tclosest_vowel := \"\"\n\tclosest_distance := 0\n\tvowels := \"aeiou\"\n\tconsonants\
    \ := \"bcdfghjklmnpqrstvwxyz\"\n\tword_count := len(word)\n\tfor i := word_count\
    \ - 1; i > 0; i-- {\n\t\tif string(word[i]) == \"a\" || string(word[i]) == \"\
    e\" || string(word[i]) == \"i\" || string(word[i]) == \"o\" || string(word[i])\
    \ == \"u\" {\n\t\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\t\tif string(word[j])\
    \ == \"a\" || string(word[j]) == \"e\" || string(word[j]) == \"i\" || string(word[j])\
    \ == \"o\" || string(word[j]) == \"u\" {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\
    \t\t\t\tif closest_distance == 0 {\n\t\t\t\t\t\tclosest_distance = i - j\n\t\t\
    \t\t\t\tclosest_vowel = string(word[i])\n\t\t\t\t\t} else if i - j < closest_distance\
    \ {\n\t\t\t\t\t\tclosest_distance = i - j\n\t\t\t\t\t\tclosest_vowel = string(word[i])\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn closest_vowel\n}\n", " \
    \   vowel_idx := -1\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowel_idx = i\n            break\n        }\n    }\n    if vowel_idx\
    \ == -1 {\n        return \"\"\n    }\n    if vowel_idx == len(word) - 1 {\n \
    \       return \"\"\n    }\n    if vowel_idx == 0 {\n        return \"\"\n   \
    \ }\n    for i := vowel_idx + 1; i < len(word); i++ {\n        if word[i] != 'a'\
    \ && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' {\n\
    \            for j := vowel_idx - 1; j >= 0; j-- {\n                if word[j]\
    \ != 'a' && word[j] != 'e' && word[j] != 'i' && word[j] != 'o' && word[j] != 'u'\
    \ {\n                    return string(word[vowel_idx])\n                }\n \
    \           }\n        }\n    }\n    return \"\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
