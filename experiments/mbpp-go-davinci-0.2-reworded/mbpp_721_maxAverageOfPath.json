{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "go_test.go",
  "prompt": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost) - 1][len(cost[0]) - 1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n    // return dp[n-1][n-1] / (n + n - 1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum int\n    var count int\n    var max float64\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := float64(sum) / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += cost[i + 1][j]\n            count++\n            dfs(i + 1, j)\n            sum -= cost[i + 1][j]\n            count--\n        }\n        if j < len(cost[0]) - 1 {\n            sum += cost[i][j + 1]\n            count++\n            dfs(i, j + 1)\n            sum -= cost[i][j + 1]\n            count--\n        }\n    }\n    sum = cost[0][0]\n    count = 1\n    dfs(0, 0)\n    return max\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    n := len(cost)\n    dp := make([][]float64, n)\n    for i := range dp {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    // dp[i][j] means the max average of path from (0,0) to (i,j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[i]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[i]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row, col := len(cost), len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAvg float64\n    var maxAvgPath func(int, int, int, float64)\n    maxAvgPath = func(i, j, n int, avg float64) {\n        if i == n - 1 && j == n - 1 {\n            if avg > maxAvg {\n                maxAvg = avg\n            }\n            return\n        }\n        if i < n - 1 {\n            maxAvgPath(i + 1, j, n, avg + float64(cost[i + 1][j]) / float64(n))\n        }\n        if j < n - 1 {\n            maxAvgPath(i, j + 1, n, avg + float64(cost[i][j + 1]) / float64(n))\n        }\n    }\n    maxAvgPath(0, 0, len(cost), float64(cost[0][0]) / float64(len(cost)))\n    return maxAvg\n}\n",
    "    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var dfs func(int, int, float64, int)\n    dfs = func(i, j int, sum float64, cnt int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if sum / float64(cnt) > max {\n                max = sum / float64(cnt)\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, sum + float64(cost[i + 1][j]), cnt + 1)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, sum + float64(cost[i][j + 1]), cnt + 1)\n        }\n    }\n    dfs(0, 0, float64(cost[0][0]), 1)\n    return max\n}\n"
  ]
}