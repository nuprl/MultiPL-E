{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "go_test.go",
  "prompt": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "func TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var tmp []int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = []int{nums1[i], nums2[j]}\n            result = append(result, tmp)\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                tmp = result[i]\n                result[i] = result[j]\n                result[j] = tmp\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000086e70, 0x0, 0x3, 0xc000086e68, 0x0, 0x0, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmpv66y17h7_test.go:29 +0x46d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpv66y17h7_test.go:45 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1[min_i] = nums1[len(nums1) - 1]\n        nums2[min_j] = nums2[len(nums2) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x1, 0x3, 0xc00008c658, 0x1, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpl1gngfuj_test.go:21 +0x3a5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpl1gngfuj_test.go:51 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap = make([]int, k)\n    var heap_size = 0\n    var heap_push = func(v int) {\n        heap[heap_size] = v\n        heap_size++\n        var i = heap_size - 1\n        var parent = (i - 1) / 2\n        for i > 0 && heap[parent] > heap[i] {\n            heap[parent], heap[i] = heap[i], heap[parent]\n            i = parent\n            parent = (i - 1) / 2\n        }\n    }\n    var heap_pop = func() int {\n        var result = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        var i = 0\n        for {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n            var min = i\n            if heap[left] < heap[min] {\n                min = left\n            }\n            if right < heap_size && heap[right] < heap[min] {\n                min = right\n            }\n            if min == i {\n                break\n            }\n            heap[i], heap[min] = heap[min], heap[i]\n            i = min\n        }\n        return result\n    }\n\n    var push = func(i int, j int) {\n        if i < len(nums1) && j < len(nums2) {\n            heap_push(nums1[i] + nums2[j])\n        }\n    }\n\n    push(0, 0)\n    for heap_size > 0 && k > 0 {\n        var sum = heap_pop()\n        var i = 0\n        var j = 0\n        for i < len(nums1) && nums1[i] <= sum {\n            i++\n        }\n        for j < len(nums2) && nums2[j] <= sum {\n            j++\n        }\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510121,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6b2qwnxq_test.go:72:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 17 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b2000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001ae180)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b2000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000086670, 0x0, 0x3, 0xc000086658, 0x0, 0x3, 0x7, 0xc0001ac030, 0x1, 0x1)\n\t/tmp/tmp1h0e5pcx_test.go:21 +0x5d0\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc0001ae180)\n\t/tmp/tmp1h0e5pcx_test.go:48 +0x2d2\ntesting.tRunner(0xc0001ae180, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for len(result) < k && len(queue) > 0 {\n        min := queue[0]\n        minIndex := 0\n        for i := 1; i < len(queue); i++ {\n            if queue[i][0] + queue[i][1] < min[0] + min[1] {\n                min = queue[i]\n                minIndex = i\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:minIndex], queue[minIndex+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_index []int\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    min_index = []int{j, m}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums2[min_index[1]] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000086640, 0x3, 0x3, 0xc000086628, 0x3, 0x3, 0x2, 0x5826e3, 0xf, 0x0)\n\t/tmp/tmpopd13fpz_test.go:28 +0x3b1\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpopd13fpz_test.go:42 +0xfb\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop heap\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] == len(nums2) - 1 {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        } else {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        }\n        heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpki__2n9s_test.go:22:9: undefined: heapify\n/tmp/tmpki__2n9s_test.go:36:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x3, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmphx3nqeou_test.go:35 +0x40c\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmphx3nqeou_test.go:51 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        res[i][0] = nums1[0]\n        res[i][1] = nums2[0]\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < res[k-1][0] + res[k-1][1] {\n                res[k-1][0] = nums1[i]\n                res[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if res[m][0] + res[m][1] < res[m-1][0] + res[m-1][1] {\n                        res[m][0], res[m][1], res[m-1][0], res[m-1][1] = res[m-1][0], res[m-1][1], res[m][0], res[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpb19e3kaj_test.go:60: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpb19e3kaj_test.go:60: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000bce70, 0x0, 0x3, 0xc0000bce58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmptanzgzop_test.go:31 +0x57e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmptanzgzop_test.go:47 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var min int\n    var min_i int\n    var min_j int\n    var i int\n    var j int\n    var tmp int\n    var tmp_i int\n    var tmp_j int\n    var tmp_res [][]int\n\n    for i = 0; i < k; i++ {\n        min = nums1[0] + nums2[0]\n        min_i = 0\n        min_j = 0\n\n        for j = 0; j < len(nums1); j++ {\n            tmp = nums1[j] + nums2[0]\n            if tmp < min {\n                min = tmp\n                min_i = j\n                min_j = 0\n            }\n        }\n\n        for j = 0; j < len(nums2); j++ {\n            tmp = nums1[0] + nums2[j]\n            if tmp < min {\n                min = tmp\n                min_i = 0\n                min_j = j\n            }\n        }\n\n        for j = 1; j < len(nums1); j++ {\n            for tmp_j = 1; tmp_j < len(nums2); tmp_j++ {\n                tmp = nums1[j] + nums2[tmp_j]\n                if tmp < min {\n                    min = tmp\n                    min_i = j\n                    min_j = tmp_j\n                }\n            }\n        }\n\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        if len(nums1) == 1 {\n            nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n        } else if len(nums2) == 1 {\n            nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        } else {\n            tmp_i = min_i\n            tmp_j = min_j\n            tmp\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510121,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1v4yo8j0_test.go:68:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000086e70, 0x0, 0x3, 0xc000086e58, 0x0, 0x3, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmp76ytjxxg_test.go:20 +0x5c5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmp76ytjxxg_test.go:48 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    // build heap\n    for i := len(heap)/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            heap[0], heap[len(heap)-1] = heap[len(heap)-1], heap[0]\n            heap = heap[:len(heap)-1]\n            heapify(heap, 0)\n        }\n    }\n\n    return heap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3qtuecq_test.go:27:9: undefined: heapify\n/tmp/tmpu3qtuecq_test.go:35:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000bce70, 0x0, 0x3, 0xc0000bce58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpq4x5ady5_test.go:36 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpq4x5ady5_test.go:52 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < heap[0] {\n                heap[0] = nums1[i] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[0], nums2[0]}\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ug39jvf_test.go:21:9: undefined: heapify\n/tmp/tmp4ug39jvf_test.go:27:17: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for m := 0; m < k; m++ {\n                    for n := m + 1; n < k; n++ {\n                        if result[m][0] + result[m][1] > result[n][0] + result[n][1] {\n                            result[m], result[n] = result[n], result[m]\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp0ias68wg_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp0ias68wg_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510122,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008ce70, 0x0, 0x3, 0xc00008ce68, 0x0, 0x0, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmpzrj_g941_test.go:29 +0x46d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpzrj_g941_test.go:45 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if j == 0 && k == 0 {\n                    min = nums1[j] + nums2[k]\n                    min_index = j\n                } else if nums1[j] + nums2[k] < min {\n                    min = nums1[j] + nums2[k]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpzl7es52y_test.go:31 +0x4b3\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpzl7es52y_test.go:47 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if i == 0 && j == 0 {\n                result[0][0] = nums1[i]\n                result[0][1] = nums2[j]\n            } else {\n                insert(result, nums1[i], nums2[j])\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe0fdco8c_test.go:29:17: undefined: insert\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[min_index / len(nums2)] + nums2[min_index % len(nums2)] + 1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp093w30mx_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp093w30mx_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=4) %!s(int=2)] [%!s(int=6) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=9) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init heap\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n    // build heap\n    for i := k / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, k)\n    }\n    // adjust heap\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heap_adjust(heap, 0, k)\n        }\n    }\n    // get result\n    for i := 0; i < k; i++ {\n        for j := 0; j < len(nums1) * len(nums2); j++ {\n            if nums1[j / len(nums2)] + nums2[j % len(nums2)] == heap[i] {\n                result[i][0] = nums1[j / len(nums2)]\n                result[i][1] = nums2[j % len(nums2)]\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpye5v2tsm_test.go:30:9: undefined: heap_adjust\n/tmp/tmpye5v2tsm_test.go:36:13: undefined: heap_adjust\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res[i][0] = nums1[min_i]\n        res[i][1] = nums2[min_j]\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00013e030, 0x1, 0x1)\n\t/tmp/tmpsj7kf8pj_test.go:24 +0x4c5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpsj7kf8pj_test.go:53 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < k; i++ {\n        heap = append(heap, []int{nums1[i/len(nums2)], nums2[i%len(nums2)], i/len(nums2), i%len(nums2)})\n    }\n    for i := k/2 - 1; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i/len(nums2)] + nums2[i%len(nums2)] < heap[0][0] + heap[0][1] {\n            heap[0] = []int{nums1[i/len(nums2)], nums2[i%len(nums2)], i/len(nums2), i%len(nums2)}\n            heap = heapify(heap, 0)\n        }\n    }\n    for i := 0; i < k; i++ {\n        result = append(result, []int{heap[0][0], heap[0][1]})\n        if heap[0][3] < len(nums2) - 1 {\n            heap[0] = []int{heap[0][0], nums2[heap[0][3] + 1], heap[0][2], heap[0][3] + 1}\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppwhyt61q_test.go:22:16: undefined: heapify\n/tmp/tmppwhyt61q_test.go:27:20: undefined: heapify\n/tmp/tmppwhyt61q_test.go:38:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x3, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp4ngsywxr_test.go:18 +0x41f\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp4ngsywxr_test.go:43 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n    for i := 1; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] > nums2[i] {\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1][0] = nums1[i]\n                result[k-1][1] = nums2[j]\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l][0], result[l][1], result[l-1][0], result[l-1][1] = result[l-1][0], result[l-1][1], result[l][0], result[l][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092640, 0x3, 0x3, 0xc000092628, 0x3, 0x3, 0x2, 0x5826c3, 0xf, 0x0)\n\t/tmp/tmpu_q7zy07_test.go:22 +0x3a9\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpu_q7zy07_test.go:58 +0xfb\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp4a8vktzx_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp4a8vktzx_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    var min_sum int\n    var min_index int\n    for i := 0; i < k; i++ {\n        min_sum = nums1[0] + nums2[0]\n        min_index = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min_sum {\n                    min_sum = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c668, 0x1, 0x1, 0x7, 0xc0001ae048, 0x1, 0x1)\n\t/tmp/tmpt_dz4mfq_test.go:20 +0x487\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc0001a0300)\n\t/tmp/tmpt_dz4mfq_test.go:46 +0x2d2\ntesting.tRunner(0xc0001a0300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_i = 0\n        var min_j = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        ret = append(ret, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpn0lyiq5f_test.go:22 +0x5d0\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpn0lyiq5f_test.go:50 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    if k > len(pairs) {\n        k = len(pairs)\n    }\n\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[len(min_heap) - 1]\n        min_heap = min_heap[:len(min_heap) - 1]\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbvuvcpgx_test.go:24:21: undefined: build_min_heap\n/tmp/tmpbvuvcpgx_test.go:29:21: undefined: min_heapify\n/tmp/tmpbvuvcpgx_test.go:39:9: undefined: min_heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1[min_index] = nums1[min_index] + nums2[min_index] + 1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpq5bu2x90_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=4) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpq5bu2x90_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=4) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=10) %!s(int=2)] [%!s(int=13) %!s(int=2)] [%!s(int=16) %!s(int=2)] [%!s(int=19) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) > k {\n        result = result[:k]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpspb707yr_test.go:26:5: undefined: heap_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := int(^uint(0) >> 1)\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpfvz1bdiy_test.go:26 +0x473\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpfvz1bdiy_test.go:42 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if k > len(result) {\n        k = len(result)\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(minHeap) < k {\n                minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n                if len(minHeap) == k {\n                    buildMinHeap(minHeap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                    minHeapify(minHeap, 0)\n                }\n            }\n        }\n    }\n    return minHeap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuagd14bn_test.go:20:21: undefined: buildMinHeap\n/tmp/tmpuagd14bn_test.go:25:21: undefined: minHeapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    heap_size := 0\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                heap[heap_size] = nums1[i] + nums2[j]\n                heap_size++\n                if heap_size == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0] {\n                    heap[0] = nums1[i] + nums2[j]\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n    ret := make([][]int, k)\n    for i := 0; i < k; i++ {\n        ret[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        ret[i][0] = heap[0]\n        ret[i][1] = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        heapify(heap, 0)\n    }\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbg0jznmp_test.go:24:21: undefined: build_heap\n/tmp/tmpbg0jznmp_test.go:29:21: undefined: heapify\n/tmp/tmpbg0jznmp_test.go:43:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        min := i\n        for j := i + 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        queue[i], queue[min] = queue[min], queue[i]\n        result = append(result, queue[i])\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i % len(nums2)]\n    }\n    for i := k / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 0; i < len(nums1) - 1; i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i + 1] + nums2[j] < heap[0] {\n                heap[0] = nums1[i + 1] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n        result[i][0] = heap[i] - nums2[i % len(nums2)]\n        result[i][1] = nums2[i % len(nums2)]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9683xss3_test.go:21:9: undefined: heapify\n/tmp/tmp9683xss3_test.go:27:17: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    var heapSize int\n    var heapCapacity int\n\n    heapCapacity = k\n    heapSize = 0\n    minHeap = make([][]int, heapCapacity)\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heapSize < k {\n                minHeap[heapSize] = []int{nums1[i], nums2[j]}\n                heapSize++\n                heapifyUp(minHeap, heapSize - 1)\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                    heapifyDown(minHeap, 0, heapSize)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < heapSize; i++ {\n        result = append(result, minHeap[i])\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznf47et__test.go:28:17: undefined: heapifyUp\n/tmp/tmpznf47et__test.go:32:21: undefined: heapifyDown\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpaytha0a0_test.go:40: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    var heapSize int\n    var heapCapacity int = k\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heapSize < heapCapacity {\n                minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n                heapSize++\n                if heapSize == heapCapacity {\n                    buildMinHeap(minHeap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                    minHeapify(minHeap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < heapSize; i++ {\n        result = append(result, minHeap[i])\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp73p8ezcw_test.go:25:21: undefined: buildMinHeap\n/tmp/tmp73p8ezcw_test.go:30:21: undefined: minHeapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var index [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n            index = append(index, []int{i, j})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n                index[i], index[j] = index[j], index[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m-1], result[m] = result[m], result[m-1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpia6ad1lp_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpia6ad1lp_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k < 1 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008ce70, 0x0, 0x3, 0xc00008ce68, 0x0, 0x0, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmpe0hil33w_test.go:29 +0x46d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpe0hil33w_test.go:45 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := 0; i < k; i++ {\n        heap[0], heap[len(heap) - 1] = heap[len(heap) - 1], heap[0]\n        heap = heap[:len(heap) - 1]\n        heapify(heap, 0)\n    }\n    return heap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_defo5f1_test.go:26:9: undefined: heapify\n/tmp/tmp_defo5f1_test.go:31:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for m := 1; m < k; m++ {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpf5rt7t4w_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpf5rt7t4w_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x3, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpdtggnscm_test.go:35 +0x40a\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpdtggnscm_test.go:50 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp7ow3_q1p_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp7ow3_q1p_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) && k > 0 {\n        if nums1[i] <= nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n        k--\n    }\n\n    for i < len(nums1) && k > 0 {\n        result = append(result, []int{nums1[i], nums2[j-1]})\n        i++\n        k--\n    }\n\n    for j < len(nums2) && k > 0 {\n        result = append(result, []int{nums1[i-1], nums2[j]})\n        j++\n        k--\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp8ghxhitp_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp8ghxhitp_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpwou43h81_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpwou43h81_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if len(res) < k {\n        return res\n    } else {\n        return res[:k]\n    }\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) && k > 0 {\n        if nums1[i] < nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n        k--\n    }\n\n    for i < len(nums1) && k > 0 {\n        result = append(result, []int{nums1[i], nums2[j-1]})\n        i++\n        k--\n    }\n\n    for j < len(nums2) && k > 0 {\n        result = append(result, []int{nums1[i-1], nums2[j]})\n        j++\n        k--\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpaxeuunim_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpaxeuunim_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if len(result) == k {\n            break\n        }\n        if nums1[i] < nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp4e7vrakh_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp4e7vrakh_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // build a heap\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    // heapify\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n\n    // pop k elements\n    var result [][]int\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            result = append(result, heap[0])\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n            heapify(heap, 0, len(heap))\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxc0dsla2_test.go:24:9: undefined: heapify\n/tmp/tmpxc0dsla2_test.go:34:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap = build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjsa3doi__test.go:26:12: undefined: build_heap\n/tmp/tmpjsa3doi__test.go:31:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_index int\n    var min_value int\n    var min_value_index int\n    var min_value_index_in_nums1 int\n    var min_value_index_in_nums2 int\n    var min_value_index_in_result int\n\n    for i := 0; i < k; i++ {\n        min_value = -1\n        min_value_index = -1\n        min_value_index_in_nums1 = -1\n        min_value_index_in_nums2 = -1\n        min_value_index_in_result = -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min_value || min_value == -1 {\n                    min_value = nums1[j] + nums2[l]\n                    min_value_index = j * len(nums2) + l\n                    min_value_index_in_nums1 = j\n                    min_value_index_in_nums2 = l\n                }\n            }\n        }\n        for j := 0; j < len(result); j++ {\n            if result[j][0] + result[j][1] < min_value || min_value == -1 {\n                min_value = result[j][0] + result[j][1]\n                min_value_index = j\n                min_value_index_in_result = j\n            }\n        }\n        if min_value_index_in_result != -1 {\n            result = append(result[:min_value_index_in_result], result[min_value_index_in_result+1:]...)\n        } else {\n            nums1 = append(nums1[:min_value_index_in_nums1], nums1[min_value_index_in_\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph_7240dq_test.go:48:87: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpwxobihs9_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpwxobihs9_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k && i < len(queue); i++ {\n        min := i\n        for j := i + 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        queue[i], queue[min] = queue[min], queue[i]\n        result = append(result, queue[i])\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpd8cwujhx_test.go:45: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heapify(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122960,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd72t_mjj_test.go:23:5: undefined: build_heap\n/tmp/tmpd72t_mjj_test.go:28:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // pop k times\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        sift_down(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122960,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn6jc6mep_test.go:19:5: undefined: heapify\n/tmp/tmpn6jc6mep_test.go:32:9: undefined: sift_down\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    if len(pairs) < k {\n        return pairs\n    } else {\n        return pairs[:k]\n    }\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    // init heap\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n    build_heap(heap)\n\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0)\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result[i][0] = heap[0] - nums2[i % len(nums2)]\n        result[i][1] = nums2[i % len(nums2)]\n        heap[0] = heap[k - 1 - i]\n        heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122960,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcpzv65ar_test.go:32:5: undefined: build_heap\n/tmp/tmpcpzv65ar_test.go:37:13: undefined: heapify\n/tmp/tmpcpzv65ar_test.go:45:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_i = 0\n        var min_j = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1[min_i] = nums1[min_i] + nums2[len(nums2) - 1] + 1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpkeclyqjn_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpkeclyqjn_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=8) %!s(int=2)] [%!s(int=10) %!s(int=2)] [%!s(int=14) %!s(int=2)] [%!s(int=15) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp9hn4_hrc_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp9hn4_hrc_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008ce70, 0x0, 0x3, 0xc00008ce68, 0x0, 0x0, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmpqkehvdi8_test.go:26 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpqkehvdi8_test.go:42 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var tmp []int\n    var tmp_sum int\n    var tmp_index int\n    var tmp_index_2 int\n    for i := 0; i < k; i++ {\n        tmp = []int{}\n        tmp_sum = 0\n        tmp_index = 0\n        tmp_index_2 = 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] + nums2[k] > tmp_sum {\n                    continue\n                }\n                if nums1[j] + nums2[k] < tmp_sum {\n                    tmp_sum = nums1[j] + nums2[k]\n                    tmp_index = j\n                    tmp_index_2 = k\n                    continue\n                }\n                if nums1[j] < nums1[tmp_index] {\n                    tmp_sum = nums1[j] + nums2[k]\n                    tmp_index = j\n                    tmp_index_2 = k\n                    continue\n                }\n                if nums1[j] == nums1[tmp_index] {\n                    if nums2[k] < nums2[tmp_index_2] {\n                        tmp_sum = nums1[j] + nums2[k]\n                        tmp_index = j\n                        tmp_index_2 = k\n                        continue\n                    }\n                }\n            }\n        }\n        tmp = append(tmp, nums1[tmp_index])\n        tmp = append(tmp, nums2[tmp_index_2])\n        result = append(result, tmp)\n        nums1 = append(nums1[:tmp_index], nums1\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122960,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphx84j92y_test.go:59:48: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008ce70, 0x0, 0x3, 0xc00008ce68, 0x0, 0x0, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmpqkehvdi8_test.go:26 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpqkehvdi8_test.go:42 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[heap_size-1]\n        heap_size--\n        heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcblb2gmx_test.go:24:21: undefined: build_heap\n/tmp/tmpcblb2gmx_test.go:29:21: undefined: heapify\n/tmp/tmpcblb2gmx_test.go:39:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x3, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpmhvnxhtf_test.go:33 +0x40a\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpmhvnxhtf_test.go:48 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpmywuowy9_test.go:34: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpmywuowy9_test.go:34: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpmywuowy9_test.go:34: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n    build_heap(heap)\n\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0)\n        }\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n        result[i][0] = heap[0] - nums2[i % len(nums2)]\n        result[i][1] = nums2[i % len(nums2)]\n        heap[0] = heap[k - 1 - i]\n        heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0ajs122w_test.go:21:5: undefined: build_heap\n/tmp/tmp0ajs122w_test.go:26:13: undefined: heapify\n/tmp/tmp0ajs122w_test.go:36:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    for i := 0; i < k && len(heap) > 0; i++ {\n        tmp := heap[0]\n        res = append(res, []int{nums1[tmp[1]], nums2[tmp[2]]})\n        if tmp[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[tmp[1] + 1] + nums2[tmp[2]], tmp[1] + 1, tmp[2]})\n        }\n        if tmp[1] == 0 && tmp[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[tmp[1]] + nums2[tmp[2] + 1], tmp[1], tmp[2] + 1})\n        }\n        heap = heap[1:]\n        for i := 0; i < len(heap) / 2; i++ {\n            if heap[i][0] > heap[i * 2 + 1][0] {\n                heap[i], heap[i * 2 + 1] = heap[i * 2 + 1], heap[i]\n            }\n            if i * 2 + 2 < len(heap) && heap[i][0] > heap[i * 2 + 2][0] {\n                heap[i], heap[i * 2 + 2] = heap[i * 2 + 2], heap[i]\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp3zwipsvd_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp3zwipsvd_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpwou43h81_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpwou43h81_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp4cw0g4bv_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp4cw0g4bv_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var tmp [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = append(tmp, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := tmp[0]\n        min_index := 0\n        for j := 1; j < len(tmp); j++ {\n            if tmp[j][0] + tmp[j][1] < min[0] + min[1] {\n                min = tmp[j]\n                min_index = j\n            }\n        }\n        ret = append(ret, min)\n        tmp = append(tmp[:min_index], tmp[min_index+1:]...)\n    }\n\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k <= 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqp79s4v_test.go:27:16: undefined: heapify\n/tmp/tmpaqp79s4v_test.go:33:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for k > 0 && len(queue) > 0 {\n        k--\n        var pair []int\n        pair, queue = queue[0], queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpvjv_g8n7_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpvjv_g8n7_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if len(min_heap) == 0 {\n            break\n        }\n\n        min_index := 0\n        for j := 1; j < len(min_heap); j++ {\n            if min_heap[j][0] + min_heap[j][1] < min_heap[min_index][0] + min_heap[min_index][1] {\n                min_index = j\n            }\n        }\n\n        result = append(result, min_heap[min_index])\n        min_heap = append(min_heap[:min_index], min_heap[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var min_heap = make([]int, 0)\n    var heap_size = 0\n\n    var push_heap = func(val int) {\n        heap_size++\n        min_heap = append(min_heap, val)\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if min_heap[parent] > min_heap[i] {\n                min_heap[parent], min_heap[i] = min_heap[i], min_heap[parent]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    var pop_heap = func() int {\n        if heap_size == 0 {\n            return 0\n        }\n\n        var ret = min_heap[0]\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heap = min_heap[:heap_size]\n\n        var i = 0\n        for i < heap_size {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n\n            var min_child = left\n            if right < heap_size && min_heap[right] < min_heap[left] {\n                min_child = right\n            }\n\n            if min_heap[i] > min_heap[min_child] {\n                min_heap[i], min_heap[min_child] = min_heap[min_child], min_heap[i]\n                i = min_child\n            } else {\n                break\n            }\n        }\n\n        return ret\n    }\n\n    var push_pair = func(i, j int) {\n        push_heap(nums1[i] + nums2[j])\n    }\n\n    var pop_pair = func() (\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcj8jm6yu_test.go:71:20: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_index int\n    var min_value int\n    var min_pair []int\n    var pairs [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min_index = 0\n        min_value = pairs[0][0] + pairs[0][1]\n        for j := 0; j < len(pairs); j++ {\n            if pairs[j][0] + pairs[j][1] < min_value {\n                min_index = j\n                min_value = pairs[j][0] + pairs[j][1]\n            }\n        }\n        min_pair = pairs[min_index]\n        pairs = append(pairs[:min_index], pairs[min_index+1:]...)\n        result = append(result, min_pair)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result = append(result, []int{nums1[i], nums2[j]})\n                    result = result[1:]\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp2ok8_6_u_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp2ok8_6_u_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{})\n    }\n    heap := make([]int, k)\n    heap[0] = nums1[0] + nums2[0]\n    for i := 1; i < k; i++ {\n        heap[i] = nums1[i/len(nums2)] + nums2[i%len(nums2)]\n    }\n    for i := k/2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[0] - nums2[i%len(nums2)], nums2[i%len(nums2)]}\n        heap[0] = nums1[i/len(nums2)+1] + nums2[i%len(nums2)]\n        heapify(heap, 0, k)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp44yrbmtj_test.go:26:9: undefined: heapify\n/tmp/tmp44yrbmtj_test.go:31:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    // init\n    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return res\n    }\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i], nums2[0], 0})\n    }\n    // pop heap\n    for i := 0; i < k && len(heap) > 0; i++ {\n        // pop\n        pop := heap[0]\n        heap = heap[1:]\n        // push\n        if pop[2] + 1 < len(nums2) {\n            heap = append(heap, []int{pop[0], nums2[pop[2] + 1], pop[2] + 1})\n        }\n        // sort\n        for j := len(heap) - 1; j > 0; j-- {\n            if heap[j][0] + heap[j][1] < heap[j - 1][0] + heap[j - 1][1] {\n                heap[j], heap[j - 1] = heap[j - 1], heap[j]\n            } else {\n                break\n            }\n        }\n        // append\n        res = append(res, []int{pop[0], pop[1]})\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp42syaqpj_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp42syaqpj_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := queue[0]\n        min_index := 0\n        for j := 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < min[0] + min[1] {\n                min = queue[j]\n                min_index = j\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:min_index], queue[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122962,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_index = []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpqa6_l5d5_test.go:18 +0x6c5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpqa6_l5d5_test.go:44 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmphla761hw_test.go:36 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmphla761hw_test.go:52 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 33 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000152000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102480)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000152000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000090670, 0x0, 0x3, 0xc000090658, 0x0, 0x3, 0x7, 0xc00014e018, 0x1, 0x1)\n\t/tmp/tmpsfvql2___test.go:18 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102480)\n\t/tmp/tmpsfvql2___test.go:46 +0x2d2\ntesting.tRunner(0xc000102480, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0, k)\n        }\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[i % len(nums2)], nums2[i % len(nums2)]}\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprvx6ax12_test.go:24:9: undefined: heapify\n/tmp/tmprvx6ax12_test.go:30:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    pairs := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := len(heap) / 2; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            result = append(result, heap[0])\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n            heap = heapify(heap, 0)\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl5mmqsce_test.go:23:16: undefined: heapify\n/tmp/tmpl5mmqsce_test.go:31:20: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var index1, index2 int\n    var sum int\n    for i := 0; i < k; i++ {\n        if index1 == len(nums1) || index2 == len(nums2) {\n            break\n        }\n\n        if nums1[index1] + nums2[index2] < nums1[index1] + nums2[index2 + 1] {\n            sum = nums1[index1] + nums2[index2]\n            index2++\n        } else {\n            sum = nums1[index1] + nums2[index2 + 1]\n            index1++\n        }\n\n        result = append(result, []int{nums1[index1], nums2[index2]})\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihecu5ds_test.go:16:9: sum declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122961,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpmywuowy9_test.go:34: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpmywuowy9_test.go:34: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpmywuowy9_test.go:34: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1]})\n        }\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpks36b0h0_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpks36b0h0_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var index int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if index < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n                index++\n            } else {\n                break\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpbjkkm9sv_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := -1\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min || min == -1 {\n                    min = nums1[j] + nums2[m]\n                }\n            }\n        }\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] == min {\n                    result = append(result, []int{nums1[j], nums2[m]})\n                    nums1 = append(nums1[:j], nums1[j+1:]...)\n                    nums2 = append(nums2[:m], nums2[m+1:]...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp4rzyl4ut_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp4rzyl4ut_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmple2qlq9k_test.go:18 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmple2qlq9k_test.go:45 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp250k8k5l_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp250k8k5l_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                    result = append(result, []int{nums1[i], nums2[j]})\n                    result = result[1:]\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmphmj0er2e_test.go:45: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var heap [][]int\n    var heap_size = 0\n    var push = func(nums []int) {\n        heap_size++\n        heap[heap_size] = nums\n        var i = heap_size\n        for i > 1 && heap[i][0] + heap[i][1] < heap[i/2][0] + heap[i/2][1] {\n            heap[i], heap[i/2] = heap[i/2], heap[i]\n            i /= 2\n        }\n    }\n    var pop = func() []int {\n        var result = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size--\n        var i = 1\n        for i * 2 <= heap_size {\n            var j = i * 2\n            if j + 1 <= heap_size && heap[j][0] + heap[j][1] > heap[j+1][0] + heap[j+1][1] {\n                j++\n            }\n            if heap[i][0] + heap[i][1] <= heap[j][0] + heap[j][1] {\n                break\n            }\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        }\n        return result\n    }\n    heap = make([][]int, len(nums1) * len(nums2) + 1)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            push([]int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k && heap_size > 0; i++ {\n        result = append(result, pop())\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpvr63milw_test.go:70: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    for i := 0; i < k && len(heap) > 0; i++ {\n        var tmp = heap[0]\n        res = append(res, []int{nums1[tmp[1]], nums2[tmp[2]]})\n        if tmp[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[tmp[1] + 1] + nums2[tmp[2]], tmp[1] + 1, tmp[2]})\n        }\n        if tmp[2] + 1 < len(nums2) && tmp[1] == 0 {\n            heap = append(heap, []int{nums1[tmp[1]] + nums2[tmp[2] + 1], tmp[1], tmp[2] + 1})\n        }\n        heap = heap[1:]\n        for i := 0; i < len(heap) / 2; i++ {\n            if heap[i][0] > heap[i * 2 + 1][0] {\n                heap[i], heap[i * 2 + 1] = heap[i * 2 + 1], heap[i]\n            }\n            if i * 2 + 2 < len(heap) && heap[i][0] > heap[i * 2 + 2][0] {\n                heap[i], heap[i * 2 + 2] = heap[i * 2 + 2], heap[i]\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpwv9nzra8_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpwv9nzra8_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_pair []int\n        for _, v1 := range nums1 {\n            for _, v2 := range nums2 {\n                if v1 + v2 < min {\n                    min = v1 + v2\n                    min_pair = []int{v1, v2}\n                }\n            }\n        }\n        ret = append(ret, min_pair)\n        for i, v := range nums1 {\n            if v == min_pair[0] {\n                nums1 = append(nums1[:i], nums1[i+1:]...)\n                break\n            }\n        }\n        for i, v := range nums2 {\n            if v == min_pair[1] {\n                nums2 = append(nums2[:i], nums2[i+1:]...)\n                break\n            }\n        }\n    }\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae40, 0x3, 0x3, 0xc00011ae28, 0x3, 0x3, 0x2, 0x5826e3, 0xf, 0x0)\n\t/tmp/tmpezfac3_b_test.go:30 +0x69c\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpezfac3_b_test.go:52 +0xfb\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var min = func(a, b int) int {\n        if a < b {\n            return a\n        }\n        return b\n    }\n\n    var max = func(a, b int) int {\n        if a > b {\n            return a\n        }\n        return b\n    }\n\n    var minHeap = func(nums []int) {\n        for i := len(nums)/2 - 1; i >= 0; i-- {\n            minHeapify(nums, i)\n        }\n    }\n\n    var minHeapify = func(nums []int, i int) {\n        left := 2*i + 1\n        right := 2*i + 2\n        smallest := i\n\n        if left < len(nums) && nums[left] < nums[smallest] {\n            smallest = left\n        }\n        if right < len(nums) && nums[right] < nums[smallest] {\n            smallest = right\n        }\n\n        if smallest != i {\n            nums[i], nums[smallest] = nums[smallest], nums[i]\n            minHeapify(nums, smallest)\n        }\n    }\n\n    var pop = func(nums []int) int {\n        if len(nums) == 0 {\n            return 0\n        }\n        result := nums[0]\n        nums[0] = nums[len(nums)-1]\n        nums = nums[:len(nums)-1]\n        minHeapify(nums, 0)\n        return result\n    }\n\n    var push = func(nums []int, num int) {\n        nums = append(nums, num)\n        minHeap(nums)\n    }\n\n    var top = func(nums []int) int {\n        if len(nums) == 0 {\n            return 0\n        }\n        return nums[0]\n    }\n\n    var heap = make([]int, 0)\n    var heapSize = 0\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmgk72yox_test.go:78:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc0001ae048, 0x1, 0x1)\n\t/tmp/tmp0iaie3ca_test.go:18 +0x5c5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc0001a0300)\n\t/tmp/tmp0iaie3ca_test.go:46 +0x2d2\ntesting.tRunner(0xc0001a0300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122963,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 5 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001200)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000090670, 0x0, 0x3, 0xc000090668, 0x1, 0x1, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpx6v6c93s_test.go:21 +0x4ee\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001200)\n\t/tmp/tmpx6v6c93s_test.go:47 +0x2d2\ntesting.tRunner(0xc000001200, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    var heap_size int\n    var push_heap func([]int)\n    var pop_heap func() []int\n\n    push_heap = func(pair []int) {\n        heap_size++\n        heap[heap_size] = pair\n        var i = heap_size\n        for i > 1 && heap[i][0]+heap[i][1] < heap[i/2][0]+heap[i/2][1] {\n            heap[i], heap[i/2] = heap[i/2], heap[i]\n            i /= 2\n        }\n    }\n\n    pop_heap = func() []int {\n        var pair = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size--\n        var i = 1\n        for i*2 <= heap_size {\n            var j = i * 2\n            if j+1 <= heap_size && heap[j+1][0]+heap[j+1][1] < heap[j][0]+heap[j][1] {\n                j++\n            }\n            if heap[i][0]+heap[i][1] <= heap[j][0]+heap[j][1] {\n                break\n            }\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        }\n        return pair\n    }\n\n    heap = make([][]int, len(nums1)*len(nums2)+1)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            push_heap([]int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k && heap_size > 0; i++ {\n        result = append(result, pop_heap())\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122964,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpromlt7wn_test.go:77: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    } else {\n        return result[:k]\n    }\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0})\n\n    for len(ret) < k && len(queue) > 0 {\n        var cur []int\n        cur, queue = queue[0], queue[1:]\n        ret = append(ret, []int{nums1[cur[0]], nums2[cur[1]]})\n\n        if cur[0] + 1 < len(nums1) {\n            queue = append(queue, []int{cur[0] + 1, cur[1]})\n        }\n\n        if cur[0] == 0 && cur[1] + 1 < len(nums2) {\n            queue = append(queue, []int{cur[0], cur[1] + 1})\n        }\n    }\n\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp1xq_3lbl_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp1xq_3lbl_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    var min_heap = make([]int, k)\n    var heap_size = 0\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap[heap_size] = nums1[i] + nums2[j]\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap, heap_size)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0] {\n                    min_heap[0] = nums1[i] + nums2[j]\n                    min_heapify(min_heap, 0, heap_size)\n                }\n            }\n        }\n    }\n    for i := 0; i < heap_size; i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] == min_heap[0] {\n                result = append(result, []int{nums1[i], nums2[j]})\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4t7ms67u_test.go:22:21: undefined: build_min_heap\n/tmp/tmp4t7ms67u_test.go:27:21: undefined: min_heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap = build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj4k858af_test.go:26:12: undefined: build_heap\n/tmp/tmpj4k858af_test.go:31:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k && i < len(heap); i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdsv_7r3f_test.go:20:5: undefined: heap_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n\n    // init\n    var result [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n\n    // loop\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        // pop\n        var tmp []int\n        tmp, heap = heap[0], heap[1:]\n        result = append(result, []int{nums1[tmp[1]], nums2[tmp[2]]})\n\n        // push\n        if tmp[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[tmp[1] + 1] + nums2[tmp[2]], tmp[1] + 1, tmp[2]})\n        }\n        if tmp[2] + 1 < len(nums2) && tmp[1] == 0 {\n            heap = append(heap, []int{nums1[tmp[1]] + nums2[tmp[2] + 1], tmp[1], tmp[2] + 1})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpugyto30b_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpugyto30b_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // pop k elements\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][2]++\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2]]\n            heapify(heap)\n        } else {\n            heap = heap[1:]\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnzeu4wyg_test.go:19:5: undefined: heapify\n/tmp/tmpnzeu4wyg_test.go:28:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < heap[0] {\n                heap[0] = nums1[i] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[i], nums2[i]}\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnpaoncbe_test.go:21:9: undefined: heapify\n/tmp/tmpnpaoncbe_test.go:27:17: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        ret = append(ret, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpgcqkjme3_test.go:37 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpgcqkjme3_test.go:53 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                max := result[0][0] + result[0][1]\n                maxIndex := 0\n                for index, pair := range result {\n                    if pair[0] + pair[1] > max {\n                        max = pair[0] + pair[1]\n                        maxIndex = index\n                    }\n                }\n                if nums1[i] + nums2[j] < max {\n                    result[maxIndex] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmput0ztlft_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] > min {\n                        continue\n                    } else {\n                        if nums1[j] + nums2[l] < min {\n                            min = nums1[j] + nums2[l]\n                            min_index = j * len(nums2) + l\n                        } else {\n                            if j * len(nums2) + l > min_index {\n                                min = nums1[j] + nums2[l]\n                                min_index = j * len(nums2) + l\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = -1\n        nums2[min_index % len(nums2)] = -1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpytjwcdcu_test.go:66: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=-1) %!s(int=-1)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpytjwcdcu_test.go:66: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpytjwcdcu_test.go:66: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result[k-1]) == 0 || nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                for l := k - 1; l > 0; l-- {\n                    if len(result[l-1]) == 0 || nums1[i] + nums2[j] > result[l-1][0] + result[l-1][1] {\n                        result[l] = []int{nums1[i], nums2[j]}\n                        break\n                    } else {\n                        result[l] = result[l-1]\n                    }\n                }\n                if len(result[0]) == 0 || nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpzo9hrzai_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpzo9hrzai_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [] [] [] [] [] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    // init heap\n    heap := make([]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, nums1[i] + nums2[j])\n        }\n    }\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        pop(heap)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp82wepm7l_test.go:23:9: undefined: heapify\n/tmp/tmp82wepm7l_test.go:30:9: undefined: pop\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var heap = make([]int, k)\n    var heap_index = make([]int, k)\n    var heap_size = 0\n\n    var push = func(value int, index int) {\n        heap[heap_size] = value\n        heap_index[heap_size] = index\n        heap_size++\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if heap[parent] > heap[i] {\n                heap[parent], heap[i] = heap[i], heap[parent]\n                heap_index[parent], heap_index[i] = heap_index[i], heap_index[parent]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    var pop = func() (int, int) {\n        var value = heap[0]\n        var index = heap_index[0]\n        heap_size--\n        heap[0] = heap[heap_size]\n        heap_index[0] = heap_index[heap_size]\n        heap[heap_size] = 0\n        heap_index[heap_size] = 0\n        var i = 0\n        for i < heap_size {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n            var min = left\n            if right < heap_size && heap[right] < heap[left] {\n                min = right\n            }\n            if heap[i] > heap[min] {\n                heap[i], heap[min] = heap[min], heap[i]\n                heap_index[i], heap_index[min] = heap_index[min], heap_index[i]\n                i = min\n            } else {\n               \nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2_3whbpj_test.go:65:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap []int\n    var heap_size int\n    var heap_capacity int = k\n    var heap_index []int\n    var heap_index_size int\n    var heap_index_capacity int = len(nums1)\n    var heap_index_map map[int]int = make(map[int]int)\n\n    heap = make([]int, heap_capacity)\n    heap_index = make([]int, heap_index_capacity)\n\n    for i := 0; i < len(nums1); i++ {\n        heap_index[i] = i\n        heap_index_map[i] = i\n        heap[i] = nums1[i] + nums2[0]\n    }\n\n    heap_size = len(nums1)\n    heap_index_size = len(nums1)\n\n    heap_build(heap, heap_size)\n\n    for i := 0; i < k && i < len(nums1) * len(nums2); i++ {\n        var index int = heap_index[0]\n        var num1 int = nums1[index]\n        var num2 int = nums2[i / len(nums1)]\n        result = append(result, []int{num1, num2})\n\n        if i / len(nums1) + 1 < len(nums2) {\n            heap_index_map[index] = i + len(nums1)\n            heap_index[0] = i + len(nums1)\n            heap[0] = nums1[index] + nums2[i / len(nums1) + 1]\n            heap_adjust(heap, heap_size, 0)\n        } else {\n            heap_index_map[index] = -1\n            heap_index[0] = heap_index[heap_index_size - 1]\n            heap_index_map[heap_index[0]] = 0\n            heap_index_size--\n           \nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122965,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpea5yzfak_test.go:54:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue []int\n    var visited = make(map[int]bool)\n\n    queue = append(queue, 0)\n\n    for len(result) < k && len(queue) > 0 {\n        var idx = queue[0]\n        queue = queue[1:]\n\n        var i = idx / len(nums2)\n        var j = idx % len(nums2)\n\n        result = append(result, []int{nums1[i], nums2[j]})\n\n        if i + 1 < len(nums1) && !visited[(i + 1) * len(nums2) + j] {\n            queue = append(queue, (i + 1) * len(nums2) + j)\n            visited[(i + 1) * len(nums2) + j] = true\n        }\n\n        if j + 1 < len(nums2) && !visited[i * len(nums2) + j + 1] {\n            queue = append(queue, i * len(nums2) + j + 1)\n            visited[i * len(nums2) + j + 1] = true\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpu9dnu_kj_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpu9dnu_kj_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n    //\n    for i := 1; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] > nums2[i] {\n                for l := k - 1; l > j; l-- {\n                    result[l][0] = result[l - 1][0]\n                    result[l][1] = result[l - 1][1]\n                }\n                result[j][0] = nums1[0]\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][0] > nums1[i] {\n                for l := k - 1; l > j; l-- {\n                    result[l][0] = result[l - 1][0]\n                    result[l][1] = result[l - 1][1]\n                }\n                result[j][0] = nums1[i]\n                result[j][1] = nums2[0]\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc00014c000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc00011e300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc00014c000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c640, 0x3, 0x3, 0xc00008c628, 0x3, 0x3, 0x2, 0x5826c3, 0xf, 0x0)\n\t/tmp/tmpd5_q3j0k_test.go:22 +0x4d4\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc00011e300)\n\t/tmp/tmpd5_q3j0k_test.go:62 +0xfb\ntesting.tRunner(0xc00011e300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    if k > len(pairs) {\n        return pairs\n    }\n\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpwou43h81_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpwou43h81_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var ret [][]int\n    var tmp []int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = []int{nums1[i], nums2[j]}\n            ret = append(ret, tmp)\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(ret); j++ {\n            if ret[i][0] + ret[i][1] > ret[j][0] + ret[j][1] {\n                ret[i], ret[j] = ret[j], ret[i]\n            }\n        }\n    }\n\n    return ret[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmphwjycusp_test.go:20 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmphwjycusp_test.go:48 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 2; m >= 0; m-- {\n                    if result[m][0] + result[m][1] > result[m+1][0] + result[m+1][1] {\n                        result[m], result[m+1] = result[m+1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpa4zzhwv3_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpa4zzhwv3_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        min := queue[0]\n        index := 0\n        for j := 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < min[0] + min[1] {\n                min = queue[j]\n                index = j\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:index], queue[index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var x, y int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    x = j\n                    y = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[x], nums2[y]})\n        if y + 1 < len(nums2) {\n            nums2 = append(nums2[:y], nums2[y+1:]...)\n        } else {\n            nums1 = append(nums1[:x], nums1[x+1:]...)\n            nums2 = nums2[:len(nums2)-1]\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x2, 0x3, 0xc00008c658, 0x1, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpy4x_7a6w_test.go:18 +0x59c\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpy4x_7a6w_test.go:49 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var minIndex int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    minIndex = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        minIndex = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[minIndex / len(nums2)], nums2[minIndex % len(nums2)]})\n        nums1 = append(nums1[:minIndex / len(nums2)], nums1[minIndex / len(nums2) + 1:]...)\n        nums2 = append(nums2[:minIndex % len(nums2)], nums2[minIndex % len(nums2) + 1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: integer divide by zero [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523260, 0x617a20)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523260, 0x617a20)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpcw8xp8ss_test.go:35 +0x5cc\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpcw8xp8ss_test.go:52 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[len(nums1) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2[min_index % len(nums2)] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: integer divide by zero [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523260, 0x617a20)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523260, 0x617a20)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmptdv28qr9_test.go:35 +0x345\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmptdv28qr9_test.go:53 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    // \u5148\u6392\u5e8f\n    for i := 0; i < len(nums1); i++ {\n        for j := i + 1; j < len(nums1); j++ {\n            if nums1[i] > nums1[j] {\n                nums1[i], nums1[j] = nums1[j], nums1[i]\n            }\n        }\n    }\n    for i := 0; i < len(nums2); i++ {\n        for j := i + 1; j < len(nums2); j++ {\n            if nums2[i] > nums2[j] {\n                nums2[i], nums2[j] = nums2[j], nums2[i]\n            }\n        }\n    }\n    // \u53d6\u6700\u5c0f\u7684k\u4e2a\n    var result [][]int\n    for i := 0; i < k; i++ {\n        if i < len(nums1) && i < len(nums2) {\n            result = append(result, []int{nums1[i], nums2[i]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpk4_y3tlk_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpk4_y3tlk_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for i := 0; i < k && len(queue) > 0; i++ {\n        tmp := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpx0edlczi_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpx0edlczi_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if i == 0 && j == 0 {\n                res[0][0] = nums1[i]\n                res[0][1] = nums2[j]\n            } else {\n                insert(res, nums1[i] + nums2[j], nums1[i], nums2[j])\n            }\n        }\n    }\n\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7w6in07z_test.go:29:17: undefined: insert\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var index1, index2 int\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[index1], nums2[index2]})\n        if index1 == len(nums1) - 1 {\n            index2++\n        } else if index2 == len(nums2) - 1 {\n            index1++\n        } else if nums1[index1 + 1] + nums2[index2] < nums1[index1] + nums2[index2 + 1] {\n            index1++\n        } else {\n            index2++\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3] with length 3\n\ngoroutine 5 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001200)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c3e70, 0x3, 0x3, 0xc0000c3e58, 0x3, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp7tvfukos_test.go:19 +0x2d5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001200)\n\t/tmp/tmp7tvfukos_test.go:42 +0x2d2\ntesting.tRunner(0xc000001200, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var min int\n    var min_index int\n    var min_index_2 int\n    var min_index_2_count int\n    var min_index_2_count_max int\n    var min_index_2_count_max_index int\n    var min_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122966,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqd77tgp__test.go:34:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop heap\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpelz5p4rp_test.go:22:9: undefined: heapify\n/tmp/tmpelz5p4rp_test.go:36:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var index1, index2 int\n    for i := 0; i < k; i++ {\n        if index1 >= len(nums1) {\n            index1 = len(nums1) - 1\n        }\n        if index2 >= len(nums2) {\n            index2 = len(nums2) - 1\n        }\n        if nums1[index1] + nums2[index2] > nums1[len(nums1) - 1] + nums2[index2] {\n            index1 = len(nums1) - 1\n        }\n        if nums1[index1] + nums2[index2] > nums1[index1] + nums2[len(nums2) - 1] {\n            index2 = len(nums2) - 1\n        }\n        result = append(result, []int{nums1[index1], nums2[index2]})\n        if index1 < len(nums1) - 1 && nums1[index1] + nums2[index2] > nums1[index1 + 1] + nums2[index2] {\n            index1++\n        } else if index2 < len(nums2) - 1 && nums1[index1] + nums2[index2] > nums1[index1] + nums2[index2 + 1] {\n            index2++\n        } else {\n            index1++\n            index2++\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpbqyage3o_test.go:62: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpbqyage3o_test.go:62: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122956,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp = queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpc4njmunm_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpc4njmunm_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_rdyyb39_test.go:24:21: undefined: build_min_heap\n/tmp/tmp_rdyyb39_test.go:29:21: undefined: min_heapify\n/tmp/tmp_rdyyb39_test.go:39:9: undefined: min_heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122967,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_rdyyb39_test.go:24:21: undefined: build_min_heap\n/tmp/tmp_rdyyb39_test.go:29:21: undefined: min_heapify\n/tmp/tmp_rdyyb39_test.go:39:9: undefined: min_heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    buildMinHeap(minHeap)\n    for i := 0; i < k && i < len(minHeap); i++ {\n        result = append(result, minHeap[0])\n        minHeap[0] = minHeap[len(minHeap) - 1]\n        minHeap = minHeap[:len(minHeap) - 1]\n        minHeapify(minHeap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5qlfjsj7_test.go:22:5: undefined: buildMinHeap\n/tmp/tmp5qlfjsj7_test.go:27:9: undefined: minHeapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // pop k times\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        // pop\n        pop := heap[0]\n        heap = heap[1:]\n\n        // push\n        if pop[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[pop[1]] + nums2[pop[2] + 1], pop[1], pop[2] + 1})\n        }\n\n        // add to result\n        result = append(result, []int{nums1[pop[1]], nums2[pop[2]]})\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp_9vte4_3_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp_9vte4_3_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_index int\n    var min_value int\n    var min_index_found bool\n    for i := 0; i < k; i++ {\n        min_index_found = false\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if !min_index_found {\n                    min_index = j\n                    min_value = nums1[j] + nums2[l]\n                    min_index_found = true\n                } else if nums1[j] + nums2[l] < min_value {\n                    min_index = j\n                    min_value = nums1[j] + nums2[l]\n                }\n            }\n        }\n        if min_index_found {\n            result = append(result, []int{nums1[min_index], min_value - nums1[min_index]})\n            nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        } else {\n            break\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpldbb7h5i_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpldbb7h5i_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if k > len(res) {\n        return res\n    } else {\n        return res[:k]\n    }\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n\n    for i := 0; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] == nums2[i] {\n                break\n            }\n            if result[j][1] > nums2[i] {\n                for k := k - 1; k > j; k-- {\n                    result[k][0] = result[k-1][0]\n                    result[k][1] = result[k-1][1]\n                }\n                result[j][0] = nums1[0]\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][0] == nums1[i] {\n                break\n            }\n            if result[j][0] > nums1[i] {\n                for k := k - 1; k > j; k-- {\n                    result[k][0] = result[k-1][0]\n                    result[k][1] = result[k-1][1]\n                }\n                result[j][0] = nums1[i]\n                result[j][1] = nums2[0]\n                break\n            }\n        }\n    }\n\n    return result\n}\n\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092640, 0x3, 0x3, 0xc000092628, 0x3, 0x3, 0x2, 0x5826c3, 0xf, 0x0)\n\t/tmp/tmp_bdr8byp_test.go:25 +0x4d4\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp_bdr8byp_test.go:74 +0xfb\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return res\n    }\n\n    // init heap\n    heap := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap[i * len(nums2) + j] = nums1[i] + nums2[j]\n        }\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if i >= len(heap) {\n            break\n        }\n        res = append(res, []int{heap[0] / nums2[0], heap[0] % nums2[0]})\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heapify(heap, 0, len(heap))\n    }\n\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo3ulz_es_test.go:25:9: undefined: heapify\n/tmp/tmpo3ulz_es_test.go:36:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    var heap_size int\n    var heap_push = func(nums []int) {\n        heap = append(heap, nums)\n        heap_size++\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if nums[0] + nums[1] < heap[parent][0] + heap[parent][1] {\n                heap[i] = heap[parent]\n                heap[parent] = nums\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n    var heap_pop = func() []int {\n        if heap_size == 0 {\n            return nil\n        }\n        var result = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        heap = heap[:heap_size]\n        var i = 0\n        for i < heap_size {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            var min = i\n            if left < heap_size && heap[left][0] + heap[left][1] < heap[min][0] + heap[min][1] {\n                min = left\n            }\n            if right < heap_size && heap[right][0] + heap[right][1] < heap[min][0] + heap[min][1] {\n                min = right\n            }\n            if min != i {\n                heap[i], heap[min] = heap[min], heap[i]\n                i = min\n            } else {\n                break\n            }\n        }\n        return result\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap_push([]int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122968,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa8x84a7v_test.go:67:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n\n    for len(res) < k && len(heap) > 0 {\n        pair := heap[0]\n        heap = heap[1:]\n\n        res = append(res, []int{nums1[pair[1]], nums2[pair[2]]})\n\n        if pair[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2]})\n        }\n\n        if pair[1] == 0 && pair[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1})\n        }\n    }\n\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpffrnrkl0_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpffrnrkl0_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var m = make(map[int]int)\n    var min = nums1[0] + nums2[0]\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            var sum = nums1[i] + nums2[j]\n            if sum < min {\n                min = sum\n            }\n            m[sum]++\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if m[min] > 0 {\n            res = append(res, []int{min, min})\n            m[min]--\n        } else {\n            min++\n            i--\n        }\n    }\n\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp_cx_sd3r_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmp_cx_sd3r_test.go:55: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=3) %!s(int=3)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp_cx_sd3r_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=7) %!s(int=7)] [%!s(int=7) %!s(int=7)] [%!s(int=9) %!s(int=9)] [%!s(int=9) %!s(int=9)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(res) < k {\n                res = append(res, []int{nums1[i], nums2[j]})\n            } else {\n                max := res[0][0] + res[0][1]\n                max_index := 0\n                for index, pair := range res {\n                    if pair[0] + pair[1] > max {\n                        max = pair[0] + pair[1]\n                        max_index = index\n                    }\n                }\n                if nums1[i] + nums2[j] < max {\n                    res[max_index] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpix2zk9gw_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpe3xlvwu4_test.go:26 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpe3xlvwu4_test.go:42 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[len(nums1) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2[min_index % len(nums2)] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x1, 0x3, 0xc000092658, 0x1, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpv4q374nj_test.go:20 +0x34f\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpv4q374nj_test.go:50 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min_sum int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min_sum = nums1[j] + nums2[l]\n                    min_index = j\n                    break\n                }\n                if nums1[j] + nums2[l] < min_sum {\n                    min_sum = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min_sum - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x3, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp6nh03ph9_test.go:33 +0x41f\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp6nh03ph9_test.go:48 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heapify(minHeap)\n\n    for i := 0; i < k && i < len(minHeap); i++ {\n        result = append(result, minHeap[0])\n        minHeap[0] = minHeap[len(minHeap) - 1]\n        minHeap = minHeap[:len(minHeap) - 1]\n        heapify(minHeap)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppw3fr0cp_test.go:22:5: undefined: heapify\n/tmp/tmppw3fr0cp_test.go:28:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        if len(nums1) == 0 || len(nums2) == 0 {\n            break\n        }\n\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        if min_i == 0 {\n            nums1 = nums1[1:]\n        } else {\n            nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        }\n\n        if min_j == 0 {\n            nums2 = nums2[1:]\n        } else {\n            nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmptnefajli_test.go:69: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmptnefajli_test.go:69: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if i % len(nums2) == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            } else {\n                if nums1[j] + nums2[i % len(nums2)] < min {\n                    min = nums1[j] + nums2[i % len(nums2)]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[i % len(nums2)]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x3, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpvmod7qjr_test.go:31 +0x44d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpvmod7qjr_test.go:46 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var x, y int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    x, y = j, l\n                }\n            }\n        }\n        result = append(result, []int{nums1[x], nums2[y]})\n        nums1 = append(nums1[:x], nums1[x+1:]...)\n        nums2 = append(nums2[:y], nums2[y+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpzd5txodm_test.go:18 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpzd5txodm_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // get k smallest pairs\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n\n        sum, i, j := heap[0][0], heap[0][1], heap[0][2]\n        result = append(result, []int{nums1[i], nums2[j]})\n\n        if j + 1 < len(nums2) {\n            heap[0] = []int{nums1[i] + nums2[j + 1], i, j + 1}\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heapify(heap)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122969,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzoicnkdu_test.go:19:5: undefined: heapify\n/tmp/tmpzoicnkdu_test.go:37:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if i == 0 && j == 0 {\n                result[0][0] = nums1[i]\n                result[0][1] = nums2[j]\n            } else {\n                for m := 0; m < k; m++ {\n                    if nums1[i] + nums2[j] < result[m][0] + result[m][1] {\n                        for n := k - 1; n > m; n-- {\n                            result[n][0] = result[n - 1][0]\n                            result[n][1] = result[n - 1][1]\n                        }\n                        result[m][0] = nums1[i]\n                        result[m][1] = nums2[j]\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp_wjgemy9_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp_wjgemy9_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122959,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpwou43h81_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpwou43h81_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue = make([]int, 0)\n    var visited = make(map[int]bool)\n    var add_to_queue = func(i, j int) {\n        if _, ok := visited[i * len(nums2) + j]; !ok {\n            queue = append(queue, i * len(nums2) + j)\n            visited[i * len(nums2) + j] = true\n        }\n    }\n    add_to_queue(0, 0)\n    for len(result) < k {\n        var min_index = 0\n        for i := 1; i < len(queue); i++ {\n            if nums1[queue[i] / len(nums2)] + nums2[queue[i] % len(nums2)] < nums1[queue[min_index] / len(nums2)] + nums2[queue[min_index] % len(nums2)] {\n                min_index = i\n            }\n        }\n        var i = queue[min_index] / len(nums2)\n        var j = queue[min_index] % len(nums2)\n        result = append(result, []int{nums1[i], nums2[j]})\n        if i + 1 < len(nums1) {\n            add_to_queue(i + 1, j)\n        }\n        if j + 1 < len(nums2) {\n            add_to_queue(i, j + 1)\n        }\n        queue = append(queue[:min_index], queue[min_index + 1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp_tdyf2ba_test.go:65: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp_tdyf2ba_test.go:65: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpndu2_wiy_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpndu2_wiy_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpqwwdfnc__test.go:28 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpqwwdfnc__test.go:45 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k <= 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n    var i, j int\n    var sum int\n    var tmp []int\n\n    for i = 0; i < k; i++ {\n        if i < len(nums1) && i < len(nums2) {\n            min_heap = append(min_heap, []int{nums1[i], nums2[i], 0, 0})\n        } else if i < len(nums1) {\n            min_heap = append(min_heap, []int{nums1[i], nums2[0], 0, 0})\n        } else if i < len(nums2) {\n            min_heap = append(min_heap, []int{nums1[0], nums2[i], 0, 0})\n        }\n    }\n\n    heap_size = len(min_heap)\n    build_min_heap(min_heap, heap_size)\n\n    for i = 0; i < k; i++ {\n        tmp = min_heap[0]\n        result = append(result, []int{tmp[0], tmp[1]})\n\n        if tmp[2] == len(nums1) - 1 && tmp[3] == len(nums2) - 1 {\n            break\n        }\n\n        if tmp[3] < len(nums2) - 1 {\n            tmp[1] = nums2[tmp[3] + 1]\n            tmp[3]++\n        } else {\n            tmp[0] = nums1[tmp[2] + 1]\n            tmp[1] = nums2[0]\n            tmp[2]++\n            tmp[3] = 0\n        }\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp68shamsc_test.go:59:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var tmp []int\n    for i := 0; i < k; i++ {\n        tmp = []int{nums1[i/len(nums2)], nums2[i%len(nums2)]}\n        result = append(result, tmp)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpu43i5arg_test.go:43: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    heap := make([]int, 0, k)\n    heap_index := make([]int, 0, k)\n    heap_index_map := make(map[int]int)\n    for i := 0; i < k; i++ {\n        if i < len(nums1) {\n            heap = append(heap, nums1[i] + nums2[0])\n            heap_index = append(heap_index, i)\n            heap_index_map[i] = 0\n        }\n    }\n    build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[heap_index[0]], nums2[heap_index_map[heap_index[0]]]})\n        if heap_index_map[heap_index[0]] < len(nums2) - 1 {\n            heap_index_map[heap_index[0]]++\n            heap[0] = nums1[heap_index[0]] + nums2[heap_index_map[heap_index[0]]]\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap_index[0] = heap_index[len(heap_index) - 1]\n            heap_index_map[heap_index[0]] = heap_index_map[heap_index[len(heap_index) - 1]]\n            heap = heap[:len(heap) - 1]\n            heap_index = heap_index[:len(heap_index) - 1]\n        }\n        heapify(heap, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzmc26b3j_test.go:27:5: undefined: build_heap\n/tmp/tmpzmc26b3j_test.go:40:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    var visited = make(map[int]bool)\n\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    visited[0] = true\n\n    for len(result) < k && len(queue) > 0 {\n        var pair = queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) && !visited[pair[0] + 1] {\n            visited[pair[0] + 1] = true\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n\n        if pair[1] + 1 < len(nums2) && !visited[pair[1] + 1] {\n            visited[pair[1] + 1] = true\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp1ur1984o_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp1ur1984o_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122958,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpge_pspjs_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        result[i][0] = nums1[0]\n        result[i][1] = nums2[0]\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1][0] = nums1[i]\n                result[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m][0], result[m-1][0] = result[m-1][0], result[m][0]\n                        result[m][1], result[m-1][1] = result[m-1][1], result[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp1z9eqnmq_test.go:61: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp1z9eqnmq_test.go:61: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpl2ewkklz_test.go:41: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(heap) < k {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                if len(heap) == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < len(heap); i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ujwirug_test.go:21:21: undefined: build_heap\n/tmp/tmp9ujwirug_test.go:26:21: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    result := make([][]int, 0)\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    // init heap\n    heap := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap[i * len(nums2) + j] = nums1[i] + nums2[j]\n        }\n    }\n    build_heap(heap)\n\n    // pop k elements\n    for i := 0; i < k; i++ {\n        if i >= len(heap) {\n            break\n        }\n        pop_heap(heap)\n        result = append(result, []int{heap[len(heap) - 1] - nums2[len(nums2) - 1], nums2[len(nums2) - 1]})\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpai21gnym_test.go:22:5: undefined: build_heap\n/tmp/tmpai21gnym_test.go:29:9: undefined: pop_heap\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0b48yxg9_test.go:23:5: undefined: heap_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(res) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                    continue\n                }\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122970,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpa70nqqui_test.go:38 +0x5c5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpa70nqqui_test.go:54 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}