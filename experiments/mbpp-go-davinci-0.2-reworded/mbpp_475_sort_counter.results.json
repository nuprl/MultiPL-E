{
  "name": "mbpp_475_sort_counter",
  "language": "go_test.go",
  "prompt": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py",
  "prompt_terminology": "reworded",
  "tests": "func TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgl0qnxgr_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys []string\n    for i := 0; i < len(keys); i++ {\n        var max_key string\n        var max_value int\n        for _, k := range keys {\n            if dict1[k] > max_value {\n                max_key = k\n                max_value = dict1[k]\n            }\n        }\n        sorted_keys = append(sorted_keys, max_key)\n        keys = remove_from_slice(keys, max_key)\n    }\n    var result [][]interface{}\n    for _, k := range sorted_keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4k6akhfc_test.go:25:16: undefined: remove_from_slice\n/tmp/tmp4k6akhfc_test.go:41:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4k6akhfc_test.go:42:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4k6akhfc_test.go:43:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgl0qnxgr_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    var result [][]interface{}\n    for i := 0; i < len(keys); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4akma2sk_test.go:38:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4akma2sk_test.go:39:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4akma2sk_test.go:40:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted [][]interface{}\n    for _, k := range keys {\n        sorted = append(sorted, []interface{}{k, dict1[k]})\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfcbvn8p5_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfcbvn8p5_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfcbvn8p5_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list1 [][]interface{}\n    for k, v := range dict1 {\n        list1 = append(list1, []interface{}{k, v})\n    }\n    for i := 0; i < len(list1); i++ {\n        for j := i + 1; j < len(list1); j++ {\n            if list1[i][1].(int) < list1[j][1].(int) {\n                list1[i], list1[j] = list1[j], list1[i]\n            }\n        }\n    }\n    return list1\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp082yuyxq_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp082yuyxq_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp082yuyxq_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    var result [][]interface{}\n\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    var result [][]interface{}\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys []string\n    for _, v := range keys {\n        if dict1[v] == 1 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 2 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 3 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 4 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 5 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 6 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 7 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 8 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 9 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 10 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict1[v] == 11 {\n            sorted_keys = append(sorted_keys, v)\n        }\n    }\n    for _, v := range keys {\n        if dict\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples to store the key-value pairs.\n    var tuples [][]interface{}\n\n    // Iterate over the map.\n    for key, value := range dict1 {\n        // Append the key-value pair to the slice.\n        tuples = append(tuples, []interface{}{key, value})\n    }\n\n    // Sort the slice by the second element in each tuple.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                temp := tuples[i]\n                tuples[i] = tuples[j]\n                tuples[j] = temp\n            }\n        }\n    }\n\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgl0qnxgr_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    for i := 0; i < len(sorted_keys); i++ {\n        for j := i + 1; j < len(sorted_keys); j++ {\n            if sorted_keys[i][1].(int) < sorted_keys[j][1].(int) {\n                sorted_keys[i], sorted_keys[j] = sorted_keys[j], sorted_keys[i]\n            }\n        }\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := 0; j < len(sorted_dict)-1-i; j++ {\n            if sorted_dict[j][1].(int) > sorted_dict[j+1][1].(int) {\n                sorted_dict[j], sorted_dict[j+1] = sorted_dict[j+1], sorted_dict[j]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    var result [][]interface{}\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    var result [][]interface{}\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list [][]interface{}\n    for k, v := range dict1 {\n        list = append(list, []interface{}{k, v})\n    }\n    for i := 0; i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n            if list[i][1].(int) < list[j][1].(int) {\n                list[i], list[j] = list[j], list[i]\n            }\n        }\n    }\n    return list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of pairs.\n    pairs := make([][]interface{}, len(dict1))\n    i := 0\n    for k, v := range dict1 {\n        pairs[i] = []interface{}{k, v}\n        i++\n    }\n    // Sort the pairs by value.\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][1].(int) < pairs[j][1].(int) {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_list [][]interface{}\n    for _, k := range keys {\n        sorted_list = append(sorted_list, []interface{}{k, dict1[k]})\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    var result [][]interface{}\n\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    var sorted_dict [][]interface{}\n\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n\n    for i := 0; i < len(values); i++ {\n        sorted_dict = append(sorted_dict, []interface{}{keys[i], values[i]})\n    }\n\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    // Iterate over the map.\n    for key, value := range dict1 {\n        // Append the tuple to the slice.\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of key-value pairs.\n    var kv_pairs [][]interface{}\n    for k, v := range dict1 {\n        kv_pairs = append(kv_pairs, []interface{}{k, v})\n    }\n    // Sort the slice by the second element of each pair.\n    for i := 0; i < len(kv_pairs) - 1; i++ {\n        for j := i + 1; j < len(kv_pairs); j++ {\n            if kv_pairs[i][1].(int) < kv_pairs[j][1].(int) {\n                kv_pairs[i], kv_pairs[j] = kv_pairs[j], kv_pairs[i]\n            }\n        }\n    }\n    return kv_pairs\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of slices.\n    var sorted_dict [][]interface{}\n    // Iterate over the map.\n    for key, value := range dict1 {\n        // Append the key and value to the slice of slices.\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    // Sort the slice of slices.\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    // Return the sorted slice of slices.\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted [][]interface{}\n    for _, k := range keys {\n        sorted = append(sorted, []interface{}{k, dict1[k]})\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfcbvn8p5_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfcbvn8p5_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfcbvn8p5_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list [][]interface{}\n    for key, value := range dict1 {\n        list = append(list, []interface{}{key, value})\n    }\n    for i := 0; i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n            if list[i][1].(int) < list[j][1].(int) {\n                list[i], list[j] = list[j], list[i]\n            }\n        }\n    }\n    return list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice to store the keys.\n    var keys []string\n    for key := range dict1 {\n        keys = append(keys, key)\n    }\n\n    // Create a slice to store the values.\n    var values []int\n    for _, value := range dict1 {\n        values = append(values, value)\n    }\n\n    // Create a slice to store the sorted values.\n    var sorted_values []int\n    for i := 0; i < len(values); i++ {\n        for j := 0; j < len(values); j++ {\n            if values[i] > values[j] {\n                sorted_values = append(sorted_values, values[i])\n            }\n        }\n    }\n\n    // Create a slice to store the sorted keys.\n    var sorted_keys []string\n    for i := 0; i < len(keys); i++ {\n        for j := 0; j < len(keys); j++ {\n            if dict1[keys[i]] == sorted_values[j] {\n                sorted_keys = append(sorted_keys, keys[i])\n            }\n        }\n    }\n\n    // Create a slice to store the sorted keys and values.\n    var sorted_keys_values [][]interface{}\n    for i := 0; i < len(sorted_keys); i++ {\n        sorted_keys_values = append(sorted_keys_values, []interface{}{sorted_keys[i], sorted_values[i]})\n    }\n\n    return sorted_keys_values\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of key-value pairs.\n    var kv_pairs [][]interface{}\n    for k, v := range dict1 {\n        kv_pairs = append(kv_pairs, []interface{}{k, v})\n    }\n    // Sort the slice of key-value pairs.\n    for i := 0; i < len(kv_pairs); i++ {\n        for j := i + 1; j < len(kv_pairs); j++ {\n            if kv_pairs[i][1].(int) < kv_pairs[j][1].(int) {\n                kv_pairs[i], kv_pairs[j] = kv_pairs[j], kv_pairs[i]\n            }\n        }\n    }\n    return kv_pairs\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var dict2 [][]interface{}\n    for key, value := range dict1 {\n        dict2 = append(dict2, []interface{}{key, value})\n    }\n    for i := 0; i < len(dict2) - 1; i++ {\n        for j := i + 1; j < len(dict2); j++ {\n            if dict2[i][1].(int) < dict2[j][1].(int) {\n                dict2[i], dict2[j] = dict2[j], dict2[i]\n            }\n        }\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    var sorted_list [][]interface{}\n\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n\n    for i := 0; i < len(keys); i++ {\n        sorted_list = append(sorted_list, []interface{}{keys[i], values[i]})\n    }\n\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted [][]interface{}\n    for _, k := range keys {\n        sorted = append(sorted, []interface{}{k, dict1[k]})\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of key-value pairs.\n    var kv_pairs [][]interface{}\n    for k, v := range dict1 {\n        kv_pairs = append(kv_pairs, []interface{}{k, v})\n    }\n    // Sort the slice of key-value pairs.\n    for i := 0; i < len(kv_pairs); i++ {\n        for j := i + 1; j < len(kv_pairs); j++ {\n            if kv_pairs[i][1].(int) < kv_pairs[j][1].(int) {\n                kv_pairs[i], kv_pairs[j] = kv_pairs[j], kv_pairs[i]\n            }\n        }\n    }\n    return kv_pairs\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice to hold the sorted keys.\n    var keys []string\n    // Iterate over the map and append the keys to the slice.\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    // Sort the slice.\n    sort.Strings(keys)\n    // Create a slice to hold the sorted values.\n    var values [][]interface{}\n    // Iterate over the sorted slice and append the values to the slice.\n    for _, k := range keys {\n        values = append(values, []interface{}{k, dict1[k]})\n    }\n    // Return the slice.\n    return values\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples to store the sorted map.\n    var sorted_dict [][]interface{}\n    // Iterate through the map and append the key and value to the slice.\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    // Sort the slice by the second element in the tuple.\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_list [][]interface{}\n    for _, k := range keys {\n        sorted_list = append(sorted_list, []interface{}{k, dict1[k]})\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of slices.\n    var sorted_dict [][]interface{}\n    // Create a slice of keys.\n    var keys []string\n    // Iterate over the map and append the keys to the slice.\n    for key := range dict1 {\n        keys = append(keys, key)\n    }\n    // Sort the slice of keys.\n    for i := 0; i < len(keys); i++ {\n        for j := i + 1; j < len(keys); j++ {\n            if dict1[keys[i]] < dict1[keys[j]] {\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    // Iterate over the sorted slice of keys and append the key and value to the slice of slices.\n    for _, key := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{key, dict1[key]})\n    }\n    // Return the slice of slices.\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    for i := 0; i < len(sorted_keys); i++ {\n        for j := i + 1; j < len(sorted_keys); j++ {\n            if sorted_keys[i][1].(int) < sorted_keys[j][1].(int) {\n                sorted_keys[i], sorted_keys[j] = sorted_keys[j], sorted_keys[i]\n            }\n        }\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgl0qnxgr_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var dict2 [][]interface{}\n    for k, v := range dict1 {\n        dict2 = append(dict2, []interface{}{k, v})\n    }\n    for i := 0; i < len(dict2); i++ {\n        for j := i + 1; j < len(dict2); j++ {\n            if dict2[i][1].(int) < dict2[j][1].(int) {\n                dict2[i], dict2[j] = dict2[j], dict2[i]\n            }\n        }\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    for i := 0; i < len(sorted_keys); i++ {\n        for j := i + 1; j < len(sorted_keys); j++ {\n            if sorted_keys[i][1].(int) < sorted_keys[j][1].(int) {\n                sorted_keys[i], sorted_keys[j] = sorted_keys[j], sorted_keys[i]\n            }\n        }\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgl0qnxgr_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgl0qnxgr_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys []string\n    for _, k := range keys {\n        if dict1[k] > 0 {\n            sorted_keys = append(sorted_keys, k)\n        }\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range sorted_keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list [][]interface{}\n    for key, value := range dict1 {\n        list = append(list, []interface{}{key, value})\n    }\n    for i := 0; i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n            if list[i][1].(int) < list[j][1].(int) {\n                list[i], list[j] = list[j], list[i]\n            }\n        }\n    }\n    return list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4059bdz_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps4059bdz_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for key := range dict1 {\n        keys = append(keys, key)\n    }\n    var sorted [][]interface{}\n    for _, key := range keys {\n        sorted = append(sorted, []interface{}{key, dict1[key]})\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    // sort the keys\n    sort.Strings(keys)\n    // create a slice of slices\n    var sorted_dict [][]interface{}\n    // loop through the sorted keys and append the key and value\n    // to the sorted slice of slices\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_469qem_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_469qem_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp34essew8_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp34essew8_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_keys [][]interface{}\n    for _, k := range keys {\n        sorted_keys = append(sorted_keys, []interface{}{k, dict1[k]})\n    }\n    return sorted_keys\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa73ad2nm_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa73ad2nm_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_m2fpcez_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_m2fpcez_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for key, value := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsq4pp920_test.go:14:5: undefined: sort\n/tmp/tmpsq4pp920_test.go:29:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:30:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsq4pp920_test.go:31:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509986,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvsto5wnb_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvsto5wnb_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122437,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of key-value pairs.\n    var kv_pairs [][]interface{}\n    for k, v := range dict1 {\n        kv_pairs = append(kv_pairs, []interface{}{k, v})\n    }\n    // Sort the slice by value.\n    for i := 0; i < len(kv_pairs) - 1; i++ {\n        for j := i + 1; j < len(kv_pairs); j++ {\n            if kv_pairs[i][1].(int) < kv_pairs[j][1].(int) {\n                kv_pairs[i], kv_pairs[j] = kv_pairs[j], kv_pairs[i]\n            }\n        }\n    }\n    return kv_pairs\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a map by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    // sort.Strings(keys)\n    // fmt.Println(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}