{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "go_test.go",
  "prompt": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "func TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var tmp []int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = []int{nums1[i], nums2[j]}\n            result = append(result, tmp)\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                tmp = result[i]\n                result[i] = result[j]\n                result[j] = tmp\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1[min_i] = nums1[len(nums1) - 1]\n        nums2[min_j] = nums2[len(nums2) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap = make([]int, k)\n    var heap_size = 0\n    var heap_push = func(v int) {\n        heap[heap_size] = v\n        heap_size++\n        var i = heap_size - 1\n        var parent = (i - 1) / 2\n        for i > 0 && heap[parent] > heap[i] {\n            heap[parent], heap[i] = heap[i], heap[parent]\n            i = parent\n            parent = (i - 1) / 2\n        }\n    }\n    var heap_pop = func() int {\n        var result = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        var i = 0\n        for {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n            var min = i\n            if heap[left] < heap[min] {\n                min = left\n            }\n            if right < heap_size && heap[right] < heap[min] {\n                min = right\n            }\n            if min == i {\n                break\n            }\n            heap[i], heap[min] = heap[min], heap[i]\n            i = min\n        }\n        return result\n    }\n\n    var push = func(i int, j int) {\n        if i < len(nums1) && j < len(nums2) {\n            heap_push(nums1[i] + nums2[j])\n        }\n    }\n\n    push(0, 0)\n    for heap_size > 0 && k > 0 {\n        var sum = heap_pop()\n        var i = 0\n        var j = 0\n        for i < len(nums1) && nums1[i] <= sum {\n            i++\n        }\n        for j < len(nums2) && nums2[j] <= sum {\n            j++\n        }",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for len(result) < k && len(queue) > 0 {\n        min := queue[0]\n        minIndex := 0\n        for i := 1; i < len(queue); i++ {\n            if queue[i][0] + queue[i][1] < min[0] + min[1] {\n                min = queue[i]\n                minIndex = i\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:minIndex], queue[minIndex+1:]...)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_index []int\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    min_index = []int{j, m}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums2[min_index[1]] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop heap\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] == len(nums2) - 1 {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        } else {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        }\n        heapify(heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        res[i][0] = nums1[0]\n        res[i][1] = nums2[0]\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < res[k-1][0] + res[k-1][1] {\n                res[k-1][0] = nums1[i]\n                res[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if res[m][0] + res[m][1] < res[m-1][0] + res[m-1][1] {\n                        res[m][0], res[m][1], res[m-1][0], res[m-1][1] = res[m-1][0], res[m-1][1], res[m][0], res[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var min int\n    var min_i int\n    var min_j int\n    var i int\n    var j int\n    var tmp int\n    var tmp_i int\n    var tmp_j int\n    var tmp_res [][]int\n\n    for i = 0; i < k; i++ {\n        min = nums1[0] + nums2[0]\n        min_i = 0\n        min_j = 0\n\n        for j = 0; j < len(nums1); j++ {\n            tmp = nums1[j] + nums2[0]\n            if tmp < min {\n                min = tmp\n                min_i = j\n                min_j = 0\n            }\n        }\n\n        for j = 0; j < len(nums2); j++ {\n            tmp = nums1[0] + nums2[j]\n            if tmp < min {\n                min = tmp\n                min_i = 0\n                min_j = j\n            }\n        }\n\n        for j = 1; j < len(nums1); j++ {\n            for tmp_j = 1; tmp_j < len(nums2); tmp_j++ {\n                tmp = nums1[j] + nums2[tmp_j]\n                if tmp < min {\n                    min = tmp\n                    min_i = j\n                    min_j = tmp_j\n                }\n            }\n        }\n\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        if len(nums1) == 1 {\n            nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n        } else if len(nums2) == 1 {\n            nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        } else {\n            tmp_i = min_i\n            tmp_j = min_j\n            tmp",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    // build heap\n    for i := len(heap)/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            heap[0], heap[len(heap)-1] = heap[len(heap)-1], heap[0]\n            heap = heap[:len(heap)-1]\n            heapify(heap, 0)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < heap[0] {\n                heap[0] = nums1[i] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[0], nums2[0]}\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for m := 0; m < k; m++ {\n                    for n := m + 1; n < k; n++ {\n                        if result[m][0] + result[m][1] > result[n][0] + result[n][1] {\n                            result[m], result[n] = result[n], result[m]\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n"
  ]
}