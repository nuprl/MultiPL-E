{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "go_test.go",
  "prompt": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "func TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var tmp []int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = []int{nums1[i], nums2[j]}\n            result = append(result, tmp)\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                tmp = result[i]\n                result[i] = result[j]\n                result[j] = tmp\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1[min_i] = nums1[len(nums1) - 1]\n        nums2[min_j] = nums2[len(nums2) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap = make([]int, k)\n    var heap_size = 0\n    var heap_push = func(v int) {\n        heap[heap_size] = v\n        heap_size++\n        var i = heap_size - 1\n        var parent = (i - 1) / 2\n        for i > 0 && heap[parent] > heap[i] {\n            heap[parent], heap[i] = heap[i], heap[parent]\n            i = parent\n            parent = (i - 1) / 2\n        }\n    }\n    var heap_pop = func() int {\n        var result = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        var i = 0\n        for {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n            var min = i\n            if heap[left] < heap[min] {\n                min = left\n            }\n            if right < heap_size && heap[right] < heap[min] {\n                min = right\n            }\n            if min == i {\n                break\n            }\n            heap[i], heap[min] = heap[min], heap[i]\n            i = min\n        }\n        return result\n    }\n\n    var push = func(i int, j int) {\n        if i < len(nums1) && j < len(nums2) {\n            heap_push(nums1[i] + nums2[j])\n        }\n    }\n\n    push(0, 0)\n    for heap_size > 0 && k > 0 {\n        var sum = heap_pop()\n        var i = 0\n        var j = 0\n        for i < len(nums1) && nums1[i] <= sum {\n            i++\n        }\n        for j < len(nums2) && nums2[j] <= sum {\n            j++\n        }",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for len(result) < k && len(queue) > 0 {\n        min := queue[0]\n        minIndex := 0\n        for i := 1; i < len(queue); i++ {\n            if queue[i][0] + queue[i][1] < min[0] + min[1] {\n                min = queue[i]\n                minIndex = i\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:minIndex], queue[minIndex+1:]...)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_index []int\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    min_index = []int{j, m}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums2[min_index[1]] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop heap\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] == len(nums2) - 1 {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        } else {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        }\n        heapify(heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        res[i][0] = nums1[0]\n        res[i][1] = nums2[0]\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < res[k-1][0] + res[k-1][1] {\n                res[k-1][0] = nums1[i]\n                res[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if res[m][0] + res[m][1] < res[m-1][0] + res[m-1][1] {\n                        res[m][0], res[m][1], res[m-1][0], res[m-1][1] = res[m-1][0], res[m-1][1], res[m][0], res[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var min int\n    var min_i int\n    var min_j int\n    var i int\n    var j int\n    var tmp int\n    var tmp_i int\n    var tmp_j int\n    var tmp_res [][]int\n\n    for i = 0; i < k; i++ {\n        min = nums1[0] + nums2[0]\n        min_i = 0\n        min_j = 0\n\n        for j = 0; j < len(nums1); j++ {\n            tmp = nums1[j] + nums2[0]\n            if tmp < min {\n                min = tmp\n                min_i = j\n                min_j = 0\n            }\n        }\n\n        for j = 0; j < len(nums2); j++ {\n            tmp = nums1[0] + nums2[j]\n            if tmp < min {\n                min = tmp\n                min_i = 0\n                min_j = j\n            }\n        }\n\n        for j = 1; j < len(nums1); j++ {\n            for tmp_j = 1; tmp_j < len(nums2); tmp_j++ {\n                tmp = nums1[j] + nums2[tmp_j]\n                if tmp < min {\n                    min = tmp\n                    min_i = j\n                    min_j = tmp_j\n                }\n            }\n        }\n\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        if len(nums1) == 1 {\n            nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n        } else if len(nums2) == 1 {\n            nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        } else {\n            tmp_i = min_i\n            tmp_j = min_j\n            tmp",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    // build heap\n    for i := len(heap)/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            heap[0], heap[len(heap)-1] = heap[len(heap)-1], heap[0]\n            heap = heap[:len(heap)-1]\n            heapify(heap, 0)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < heap[0] {\n                heap[0] = nums1[i] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[0], nums2[0]}\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for m := 0; m < k; m++ {\n                    for n := m + 1; n < k; n++ {\n                        if result[m][0] + result[m][1] > result[n][0] + result[n][1] {\n                            result[m], result[n] = result[n], result[m]\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if j == 0 && k == 0 {\n                    min = nums1[j] + nums2[k]\n                    min_index = j\n                } else if nums1[j] + nums2[k] < min {\n                    min = nums1[j] + nums2[k]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if i == 0 && j == 0 {\n                result[0][0] = nums1[i]\n                result[0][1] = nums2[j]\n            } else {\n                insert(result, nums1[i], nums2[j])\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[min_index / len(nums2)] + nums2[min_index % len(nums2)] + 1\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init heap\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n    // build heap\n    for i := k / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, k)\n    }\n    // adjust heap\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heap_adjust(heap, 0, k)\n        }\n    }\n    // get result\n    for i := 0; i < k; i++ {\n        for j := 0; j < len(nums1) * len(nums2); j++ {\n            if nums1[j / len(nums2)] + nums2[j % len(nums2)] == heap[i] {\n                result[i][0] = nums1[j / len(nums2)]\n                result[i][1] = nums2[j % len(nums2)]\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res[i][0] = nums1[min_i]\n        res[i][1] = nums2[min_j]\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < k; i++ {\n        heap = append(heap, []int{nums1[i/len(nums2)], nums2[i%len(nums2)], i/len(nums2), i%len(nums2)})\n    }\n    for i := k/2 - 1; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i/len(nums2)] + nums2[i%len(nums2)] < heap[0][0] + heap[0][1] {\n            heap[0] = []int{nums1[i/len(nums2)], nums2[i%len(nums2)], i/len(nums2), i%len(nums2)}\n            heap = heapify(heap, 0)\n        }\n    }\n    for i := 0; i < k; i++ {\n        result = append(result, []int{heap[0][0], heap[0][1]})\n        if heap[0][3] < len(nums2) - 1 {\n            heap[0] = []int{heap[0][0], nums2[heap[0][3] + 1], heap[0][2], heap[0][3] + 1}\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n    for i := 1; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] > nums2[i] {\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1][0] = nums1[i]\n                result[k-1][1] = nums2[j]\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l][0], result[l][1], result[l-1][0], result[l-1][1] = result[l-1][0], result[l-1][1], result[l][0], result[l][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    var min_sum int\n    var min_index int\n    for i := 0; i < k; i++ {\n        min_sum = nums1[0] + nums2[0]\n        min_index = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min_sum {\n                    min_sum = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_i = 0\n        var min_j = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        ret = append(ret, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return ret\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    if k > len(pairs) {\n        k = len(pairs)\n    }\n\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[len(min_heap) - 1]\n        min_heap = min_heap[:len(min_heap) - 1]\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1[min_index] = nums1[min_index] + nums2[min_index] + 1\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) > k {\n        result = result[:k]\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := int(^uint(0) >> 1)\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if k > len(result) {\n        k = len(result)\n    }\n\n    return result[:k]\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(minHeap) < k {\n                minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n                if len(minHeap) == k {\n                    buildMinHeap(minHeap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                    minHeapify(minHeap, 0)\n                }\n            }\n        }\n    }\n    return minHeap\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    heap_size := 0\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                heap[heap_size] = nums1[i] + nums2[j]\n                heap_size++\n                if heap_size == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0] {\n                    heap[0] = nums1[i] + nums2[j]\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n    ret := make([][]int, k)\n    for i := 0; i < k; i++ {\n        ret[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        ret[i][0] = heap[0]\n        ret[i][1] = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        heapify(heap, 0)\n    }\n    return ret\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        min := i\n        for j := i + 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        queue[i], queue[min] = queue[min], queue[i]\n        result = append(result, queue[i])\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i % len(nums2)]\n    }\n    for i := k / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 0; i < len(nums1) - 1; i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i + 1] + nums2[j] < heap[0] {\n                heap[0] = nums1[i + 1] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n        result[i][0] = heap[i] - nums2[i % len(nums2)]\n        result[i][1] = nums2[i % len(nums2)]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    var heapSize int\n    var heapCapacity int\n\n    heapCapacity = k\n    heapSize = 0\n    minHeap = make([][]int, heapCapacity)\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heapSize < k {\n                minHeap[heapSize] = []int{nums1[i], nums2[j]}\n                heapSize++\n                heapifyUp(minHeap, heapSize - 1)\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                    heapifyDown(minHeap, 0, heapSize)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < heapSize; i++ {\n        result = append(result, minHeap[i])\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    var heapSize int\n    var heapCapacity int = k\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heapSize < heapCapacity {\n                minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n                heapSize++\n                if heapSize == heapCapacity {\n                    buildMinHeap(minHeap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                    minHeapify(minHeap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < heapSize; i++ {\n        result = append(result, minHeap[i])\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var index [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n            index = append(index, []int{i, j})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n                index[i], index[j] = index[j], index[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m-1], result[m] = result[m], result[m-1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k < 1 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := 0; i < k; i++ {\n        heap[0], heap[len(heap) - 1] = heap[len(heap) - 1], heap[0]\n        heap = heap[:len(heap) - 1]\n        heapify(heap, 0)\n    }\n    return heap\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for m := 1; m < k; m++ {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) && k > 0 {\n        if nums1[i] <= nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n        k--\n    }\n\n    for i < len(nums1) && k > 0 {\n        result = append(result, []int{nums1[i], nums2[j-1]})\n        i++\n        k--\n    }\n\n    for j < len(nums2) && k > 0 {\n        result = append(result, []int{nums1[i-1], nums2[j]})\n        j++\n        k--\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if len(res) < k {\n        return res\n    } else {\n        return res[:k]\n    }\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) && k > 0 {\n        if nums1[i] < nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n        k--\n    }\n\n    for i < len(nums1) && k > 0 {\n        result = append(result, []int{nums1[i], nums2[j-1]})\n        i++\n        k--\n    }\n\n    for j < len(nums2) && k > 0 {\n        result = append(result, []int{nums1[i-1], nums2[j]})\n        j++\n        k--\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if len(result) == k {\n            break\n        }\n        if nums1[i] < nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // build a heap\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    // heapify\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n\n    // pop k elements\n    var result [][]int\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            result = append(result, heap[0])\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n            heapify(heap, 0, len(heap))\n        }\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap = build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_index int\n    var min_value int\n    var min_value_index int\n    var min_value_index_in_nums1 int\n    var min_value_index_in_nums2 int\n    var min_value_index_in_result int\n\n    for i := 0; i < k; i++ {\n        min_value = -1\n        min_value_index = -1\n        min_value_index_in_nums1 = -1\n        min_value_index_in_nums2 = -1\n        min_value_index_in_result = -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min_value || min_value == -1 {\n                    min_value = nums1[j] + nums2[l]\n                    min_value_index = j * len(nums2) + l\n                    min_value_index_in_nums1 = j\n                    min_value_index_in_nums2 = l\n                }\n            }\n        }\n        for j := 0; j < len(result); j++ {\n            if result[j][0] + result[j][1] < min_value || min_value == -1 {\n                min_value = result[j][0] + result[j][1]\n                min_value_index = j\n                min_value_index_in_result = j\n            }\n        }\n        if min_value_index_in_result != -1 {\n            result = append(result[:min_value_index_in_result], result[min_value_index_in_result+1:]...)\n        } else {\n            nums1 = append(nums1[:min_value_index_in_nums1], nums1[min_value_index_in_",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k && i < len(queue); i++ {\n        min := i\n        for j := i + 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        queue[i], queue[min] = queue[min], queue[i]\n        result = append(result, queue[i])\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heapify(heap, 0)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // pop k times\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        sift_down(heap, 0)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    if len(pairs) < k {\n        return pairs\n    } else {\n        return pairs[:k]\n    }\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    // init heap\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n    build_heap(heap)\n\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0)\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result[i][0] = heap[0] - nums2[i % len(nums2)]\n        result[i][1] = nums2[i % len(nums2)]\n        heap[0] = heap[k - 1 - i]\n        heapify(heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_i = 0\n        var min_j = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1[min_i] = nums1[min_i] + nums2[len(nums2) - 1] + 1\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var tmp []int\n    var tmp_sum int\n    var tmp_index int\n    var tmp_index_2 int\n    for i := 0; i < k; i++ {\n        tmp = []int{}\n        tmp_sum = 0\n        tmp_index = 0\n        tmp_index_2 = 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] + nums2[k] > tmp_sum {\n                    continue\n                }\n                if nums1[j] + nums2[k] < tmp_sum {\n                    tmp_sum = nums1[j] + nums2[k]\n                    tmp_index = j\n                    tmp_index_2 = k\n                    continue\n                }\n                if nums1[j] < nums1[tmp_index] {\n                    tmp_sum = nums1[j] + nums2[k]\n                    tmp_index = j\n                    tmp_index_2 = k\n                    continue\n                }\n                if nums1[j] == nums1[tmp_index] {\n                    if nums2[k] < nums2[tmp_index_2] {\n                        tmp_sum = nums1[j] + nums2[k]\n                        tmp_index = j\n                        tmp_index_2 = k\n                        continue\n                    }\n                }\n            }\n        }\n        tmp = append(tmp, nums1[tmp_index])\n        tmp = append(tmp, nums2[tmp_index_2])\n        result = append(result, tmp)\n        nums1 = append(nums1[:tmp_index], nums1",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[heap_size-1]\n        heap_size--\n        heapify(heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n",
    "    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n    build_heap(heap)\n\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0)\n        }\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n        result[i][0] = heap[0] - nums2[i % len(nums2)]\n        result[i][1] = nums2[i % len(nums2)]\n        heap[0] = heap[k - 1 - i]\n        heapify(heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    for i := 0; i < k && len(heap) > 0; i++ {\n        tmp := heap[0]\n        res = append(res, []int{nums1[tmp[1]], nums2[tmp[2]]})\n        if tmp[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[tmp[1] + 1] + nums2[tmp[2]], tmp[1] + 1, tmp[2]})\n        }\n        if tmp[1] == 0 && tmp[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[tmp[1]] + nums2[tmp[2] + 1], tmp[1], tmp[2] + 1})\n        }\n        heap = heap[1:]\n        for i := 0; i < len(heap) / 2; i++ {\n            if heap[i][0] > heap[i * 2 + 1][0] {\n                heap[i], heap[i * 2 + 1] = heap[i * 2 + 1], heap[i]\n            }\n            if i * 2 + 2 < len(heap) && heap[i][0] > heap[i * 2 + 2][0] {\n                heap[i], heap[i * 2 + 2] = heap[i * 2 + 2], heap[i]\n            }\n        }\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var tmp [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = append(tmp, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := tmp[0]\n        min_index := 0\n        for j := 1; j < len(tmp); j++ {\n            if tmp[j][0] + tmp[j][1] < min[0] + min[1] {\n                min = tmp[j]\n                min_index = j\n            }\n        }\n        ret = append(ret, min)\n        tmp = append(tmp[:min_index], tmp[min_index+1:]...)\n    }\n\n    return ret\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k <= 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for k > 0 && len(queue) > 0 {\n        k--\n        var pair []int\n        pair, queue = queue[0], queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if len(min_heap) == 0 {\n            break\n        }\n\n        min_index := 0\n        for j := 1; j < len(min_heap); j++ {\n            if min_heap[j][0] + min_heap[j][1] < min_heap[min_index][0] + min_heap[min_index][1] {\n                min_index = j\n            }\n        }\n\n        result = append(result, min_heap[min_index])\n        min_heap = append(min_heap[:min_index], min_heap[min_index+1:]...)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var min_heap = make([]int, 0)\n    var heap_size = 0\n\n    var push_heap = func(val int) {\n        heap_size++\n        min_heap = append(min_heap, val)\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if min_heap[parent] > min_heap[i] {\n                min_heap[parent], min_heap[i] = min_heap[i], min_heap[parent]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    var pop_heap = func() int {\n        if heap_size == 0 {\n            return 0\n        }\n\n        var ret = min_heap[0]\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heap = min_heap[:heap_size]\n\n        var i = 0\n        for i < heap_size {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n\n            var min_child = left\n            if right < heap_size && min_heap[right] < min_heap[left] {\n                min_child = right\n            }\n\n            if min_heap[i] > min_heap[min_child] {\n                min_heap[i], min_heap[min_child] = min_heap[min_child], min_heap[i]\n                i = min_child\n            } else {\n                break\n            }\n        }\n\n        return ret\n    }\n\n    var push_pair = func(i, j int) {\n        push_heap(nums1[i] + nums2[j])\n    }\n\n    var pop_pair = func() (",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_index int\n    var min_value int\n    var min_pair []int\n    var pairs [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min_index = 0\n        min_value = pairs[0][0] + pairs[0][1]\n        for j := 0; j < len(pairs); j++ {\n            if pairs[j][0] + pairs[j][1] < min_value {\n                min_index = j\n                min_value = pairs[j][0] + pairs[j][1]\n            }\n        }\n        min_pair = pairs[min_index]\n        pairs = append(pairs[:min_index], pairs[min_index+1:]...)\n        result = append(result, min_pair)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result = append(result, []int{nums1[i], nums2[j]})\n                    result = result[1:]\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{})\n    }\n    heap := make([]int, k)\n    heap[0] = nums1[0] + nums2[0]\n    for i := 1; i < k; i++ {\n        heap[i] = nums1[i/len(nums2)] + nums2[i%len(nums2)]\n    }\n    for i := k/2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[0] - nums2[i%len(nums2)], nums2[i%len(nums2)]}\n        heap[0] = nums1[i/len(nums2)+1] + nums2[i%len(nums2)]\n        heapify(heap, 0, k)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n",
    "    // init\n    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return res\n    }\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i], nums2[0], 0})\n    }\n    // pop heap\n    for i := 0; i < k && len(heap) > 0; i++ {\n        // pop\n        pop := heap[0]\n        heap = heap[1:]\n        // push\n        if pop[2] + 1 < len(nums2) {\n            heap = append(heap, []int{pop[0], nums2[pop[2] + 1], pop[2] + 1})\n        }\n        // sort\n        for j := len(heap) - 1; j > 0; j-- {\n            if heap[j][0] + heap[j][1] < heap[j - 1][0] + heap[j - 1][1] {\n                heap[j], heap[j - 1] = heap[j - 1], heap[j]\n            } else {\n                break\n            }\n        }\n        // append\n        res = append(res, []int{pop[0], pop[1]})\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := queue[0]\n        min_index := 0\n        for j := 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < min[0] + min[1] {\n                min = queue[j]\n                min_index = j\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:min_index], queue[min_index+1:]...)\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_index = []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n    }\n\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0, k)\n        }\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[i % len(nums2)], nums2[i % len(nums2)]}\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    pairs := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := len(heap) / 2; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            result = append(result, heap[0])\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n            heap = heapify(heap, 0)\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var index1, index2 int\n    var sum int\n    for i := 0; i < k; i++ {\n        if index1 == len(nums1) || index2 == len(nums2) {\n            break\n        }\n\n        if nums1[index1] + nums2[index2] < nums1[index1] + nums2[index2 + 1] {\n            sum = nums1[index1] + nums2[index2]\n            index2++\n        } else {\n            sum = nums1[index1] + nums2[index2 + 1]\n            index1++\n        }\n\n        result = append(result, []int{nums1[index1], nums2[index2]})\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1]})\n        }\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1})\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var index int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if index < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n                index++\n            } else {\n                break\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := -1\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min || min == -1 {\n                    min = nums1[j] + nums2[m]\n                }\n            }\n        }\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] == min {\n                    result = append(result, []int{nums1[j], nums2[m]})\n                    nums1 = append(nums1[:j], nums1[j+1:]...)\n                    nums2 = append(nums2[:m], nums2[m+1:]...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                    result = append(result, []int{nums1[i], nums2[j]})\n                    result = result[1:]\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var heap [][]int\n    var heap_size = 0\n    var push = func(nums []int) {\n        heap_size++\n        heap[heap_size] = nums\n        var i = heap_size\n        for i > 1 && heap[i][0] + heap[i][1] < heap[i/2][0] + heap[i/2][1] {\n            heap[i], heap[i/2] = heap[i/2], heap[i]\n            i /= 2\n        }\n    }\n    var pop = func() []int {\n        var result = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size--\n        var i = 1\n        for i * 2 <= heap_size {\n            var j = i * 2\n            if j + 1 <= heap_size && heap[j][0] + heap[j][1] > heap[j+1][0] + heap[j+1][1] {\n                j++\n            }\n            if heap[i][0] + heap[i][1] <= heap[j][0] + heap[j][1] {\n                break\n            }\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        }\n        return result\n    }\n    heap = make([][]int, len(nums1) * len(nums2) + 1)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            push([]int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k && heap_size > 0; i++ {\n        result = append(result, pop())\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    for i := 0; i < k && len(heap) > 0; i++ {\n        var tmp = heap[0]\n        res = append(res, []int{nums1[tmp[1]], nums2[tmp[2]]})\n        if tmp[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[tmp[1] + 1] + nums2[tmp[2]], tmp[1] + 1, tmp[2]})\n        }\n        if tmp[2] + 1 < len(nums2) && tmp[1] == 0 {\n            heap = append(heap, []int{nums1[tmp[1]] + nums2[tmp[2] + 1], tmp[1], tmp[2] + 1})\n        }\n        heap = heap[1:]\n        for i := 0; i < len(heap) / 2; i++ {\n            if heap[i][0] > heap[i * 2 + 1][0] {\n                heap[i], heap[i * 2 + 1] = heap[i * 2 + 1], heap[i]\n            }\n            if i * 2 + 2 < len(heap) && heap[i][0] > heap[i * 2 + 2][0] {\n                heap[i], heap[i * 2 + 2] = heap[i * 2 + 2], heap[i]\n            }\n        }\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_pair []int\n        for _, v1 := range nums1 {\n            for _, v2 := range nums2 {\n                if v1 + v2 < min {\n                    min = v1 + v2\n                    min_pair = []int{v1, v2}\n                }\n            }\n        }\n        ret = append(ret, min_pair)\n        for i, v := range nums1 {\n            if v == min_pair[0] {\n                nums1 = append(nums1[:i], nums1[i+1:]...)\n                break\n            }\n        }\n        for i, v := range nums2 {\n            if v == min_pair[1] {\n                nums2 = append(nums2[:i], nums2[i+1:]...)\n                break\n            }\n        }\n    }\n    return ret\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var min = func(a, b int) int {\n        if a < b {\n            return a\n        }\n        return b\n    }\n\n    var max = func(a, b int) int {\n        if a > b {\n            return a\n        }\n        return b\n    }\n\n    var minHeap = func(nums []int) {\n        for i := len(nums)/2 - 1; i >= 0; i-- {\n            minHeapify(nums, i)\n        }\n    }\n\n    var minHeapify = func(nums []int, i int) {\n        left := 2*i + 1\n        right := 2*i + 2\n        smallest := i\n\n        if left < len(nums) && nums[left] < nums[smallest] {\n            smallest = left\n        }\n        if right < len(nums) && nums[right] < nums[smallest] {\n            smallest = right\n        }\n\n        if smallest != i {\n            nums[i], nums[smallest] = nums[smallest], nums[i]\n            minHeapify(nums, smallest)\n        }\n    }\n\n    var pop = func(nums []int) int {\n        if len(nums) == 0 {\n            return 0\n        }\n        result := nums[0]\n        nums[0] = nums[len(nums)-1]\n        nums = nums[:len(nums)-1]\n        minHeapify(nums, 0)\n        return result\n    }\n\n    var push = func(nums []int, num int) {\n        nums = append(nums, num)\n        minHeap(nums)\n    }\n\n    var top = func(nums []int) int {\n        if len(nums) == 0 {\n            return 0\n        }\n        return nums[0]\n    }\n\n    var heap = make([]int, 0)\n    var heapSize = 0",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    var heap_size int\n    var push_heap func([]int)\n    var pop_heap func() []int\n\n    push_heap = func(pair []int) {\n        heap_size++\n        heap[heap_size] = pair\n        var i = heap_size\n        for i > 1 && heap[i][0]+heap[i][1] < heap[i/2][0]+heap[i/2][1] {\n            heap[i], heap[i/2] = heap[i/2], heap[i]\n            i /= 2\n        }\n    }\n\n    pop_heap = func() []int {\n        var pair = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size--\n        var i = 1\n        for i*2 <= heap_size {\n            var j = i * 2\n            if j+1 <= heap_size && heap[j+1][0]+heap[j+1][1] < heap[j][0]+heap[j][1] {\n                j++\n            }\n            if heap[i][0]+heap[i][1] <= heap[j][0]+heap[j][1] {\n                break\n            }\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        }\n        return pair\n    }\n\n    heap = make([][]int, len(nums1)*len(nums2)+1)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            push_heap([]int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k && heap_size > 0; i++ {\n        result = append(result, pop_heap())\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    } else {\n        return result[:k]\n    }\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0})\n\n    for len(ret) < k && len(queue) > 0 {\n        var cur []int\n        cur, queue = queue[0], queue[1:]\n        ret = append(ret, []int{nums1[cur[0]], nums2[cur[1]]})\n\n        if cur[0] + 1 < len(nums1) {\n            queue = append(queue, []int{cur[0] + 1, cur[1]})\n        }\n\n        if cur[0] == 0 && cur[1] + 1 < len(nums2) {\n            queue = append(queue, []int{cur[0], cur[1] + 1})\n        }\n    }\n\n    return ret\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    var min_heap = make([]int, k)\n    var heap_size = 0\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap[heap_size] = nums1[i] + nums2[j]\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap, heap_size)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0] {\n                    min_heap[0] = nums1[i] + nums2[j]\n                    min_heapify(min_heap, 0, heap_size)\n                }\n            }\n        }\n    }\n    for i := 0; i < heap_size; i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] == min_heap[0] {\n                result = append(result, []int{nums1[i], nums2[j]})\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap = build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k && i < len(heap); i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n\n    // init\n    var result [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n\n    // loop\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        // pop\n        var tmp []int\n        tmp, heap = heap[0], heap[1:]\n        result = append(result, []int{nums1[tmp[1]], nums2[tmp[2]]})\n\n        // push\n        if tmp[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[tmp[1] + 1] + nums2[tmp[2]], tmp[1] + 1, tmp[2]})\n        }\n        if tmp[2] + 1 < len(nums2) && tmp[1] == 0 {\n            heap = append(heap, []int{nums1[tmp[1]] + nums2[tmp[2] + 1], tmp[1], tmp[2] + 1})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // pop k elements\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][2]++\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2]]\n            heapify(heap)\n        } else {\n            heap = heap[1:]\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n    for i := k / 2; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < heap[0] {\n                heap[0] = nums1[i] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[i], nums2[i]}\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        ret = append(ret, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return ret\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                max := result[0][0] + result[0][1]\n                maxIndex := 0\n                for index, pair := range result {\n                    if pair[0] + pair[1] > max {\n                        max = pair[0] + pair[1]\n                        maxIndex = index\n                    }\n                }\n                if nums1[i] + nums2[j] < max {\n                    result[maxIndex] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] > min {\n                        continue\n                    } else {\n                        if nums1[j] + nums2[l] < min {\n                            min = nums1[j] + nums2[l]\n                            min_index = j * len(nums2) + l\n                        } else {\n                            if j * len(nums2) + l > min_index {\n                                min = nums1[j] + nums2[l]\n                                min_index = j * len(nums2) + l\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = -1\n        nums2[min_index % len(nums2)] = -1\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result[k-1]) == 0 || nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                for l := k - 1; l > 0; l-- {\n                    if len(result[l-1]) == 0 || nums1[i] + nums2[j] > result[l-1][0] + result[l-1][1] {\n                        result[l] = []int{nums1[i], nums2[j]}\n                        break\n                    } else {\n                        result[l] = result[l-1]\n                    }\n                }\n                if len(result[0]) == 0 || nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    // init heap\n    heap := make([]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, nums1[i] + nums2[j])\n        }\n    }\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        pop(heap)\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var heap = make([]int, k)\n    var heap_index = make([]int, k)\n    var heap_size = 0\n\n    var push = func(value int, index int) {\n        heap[heap_size] = value\n        heap_index[heap_size] = index\n        heap_size++\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if heap[parent] > heap[i] {\n                heap[parent], heap[i] = heap[i], heap[parent]\n                heap_index[parent], heap_index[i] = heap_index[i], heap_index[parent]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    var pop = func() (int, int) {\n        var value = heap[0]\n        var index = heap_index[0]\n        heap_size--\n        heap[0] = heap[heap_size]\n        heap_index[0] = heap_index[heap_size]\n        heap[heap_size] = 0\n        heap_index[heap_size] = 0\n        var i = 0\n        for i < heap_size {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            if left >= heap_size {\n                break\n            }\n            var min = left\n            if right < heap_size && heap[right] < heap[left] {\n                min = right\n            }\n            if heap[i] > heap[min] {\n                heap[i], heap[min] = heap[min], heap[i]\n                heap_index[i], heap_index[min] = heap_index[min], heap_index[i]\n                i = min\n            } else {\n               ",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap []int\n    var heap_size int\n    var heap_capacity int = k\n    var heap_index []int\n    var heap_index_size int\n    var heap_index_capacity int = len(nums1)\n    var heap_index_map map[int]int = make(map[int]int)\n\n    heap = make([]int, heap_capacity)\n    heap_index = make([]int, heap_index_capacity)\n\n    for i := 0; i < len(nums1); i++ {\n        heap_index[i] = i\n        heap_index_map[i] = i\n        heap[i] = nums1[i] + nums2[0]\n    }\n\n    heap_size = len(nums1)\n    heap_index_size = len(nums1)\n\n    heap_build(heap, heap_size)\n\n    for i := 0; i < k && i < len(nums1) * len(nums2); i++ {\n        var index int = heap_index[0]\n        var num1 int = nums1[index]\n        var num2 int = nums2[i / len(nums1)]\n        result = append(result, []int{num1, num2})\n\n        if i / len(nums1) + 1 < len(nums2) {\n            heap_index_map[index] = i + len(nums1)\n            heap_index[0] = i + len(nums1)\n            heap[0] = nums1[index] + nums2[i / len(nums1) + 1]\n            heap_adjust(heap, heap_size, 0)\n        } else {\n            heap_index_map[index] = -1\n            heap_index[0] = heap_index[heap_index_size - 1]\n            heap_index_map[heap_index[0]] = 0\n            heap_index_size--\n           ",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue []int\n    var visited = make(map[int]bool)\n\n    queue = append(queue, 0)\n\n    for len(result) < k && len(queue) > 0 {\n        var idx = queue[0]\n        queue = queue[1:]\n\n        var i = idx / len(nums2)\n        var j = idx % len(nums2)\n\n        result = append(result, []int{nums1[i], nums2[j]})\n\n        if i + 1 < len(nums1) && !visited[(i + 1) * len(nums2) + j] {\n            queue = append(queue, (i + 1) * len(nums2) + j)\n            visited[(i + 1) * len(nums2) + j] = true\n        }\n\n        if j + 1 < len(nums2) && !visited[i * len(nums2) + j + 1] {\n            queue = append(queue, i * len(nums2) + j + 1)\n            visited[i * len(nums2) + j + 1] = true\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n    //\n    for i := 1; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] > nums2[i] {\n                for l := k - 1; l > j; l-- {\n                    result[l][0] = result[l - 1][0]\n                    result[l][1] = result[l - 1][1]\n                }\n                result[j][0] = nums1[0]\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][0] > nums1[i] {\n                for l := k - 1; l > j; l-- {\n                    result[l][0] = result[l - 1][0]\n                    result[l][1] = result[l - 1][1]\n                }\n                result[j][0] = nums1[i]\n                result[j][1] = nums2[0]\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(pairs); i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    if k > len(pairs) {\n        return pairs\n    }\n\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var ret [][]int\n    var tmp []int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = []int{nums1[i], nums2[j]}\n            ret = append(ret, tmp)\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(ret); j++ {\n            if ret[i][0] + ret[i][1] > ret[j][0] + ret[j][1] {\n                ret[i], ret[j] = ret[j], ret[i]\n            }\n        }\n    }\n\n    return ret[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 2; m >= 0; m-- {\n                    if result[m][0] + result[m][1] > result[m+1][0] + result[m+1][1] {\n                        result[m], result[m+1] = result[m+1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        min := queue[0]\n        index := 0\n        for j := 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < min[0] + min[1] {\n                min = queue[j]\n                index = j\n            }\n        }\n        result = append(result, min)\n        queue = append(queue[:index], queue[index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var x, y int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    x = j\n                    y = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[x], nums2[y]})\n        if y + 1 < len(nums2) {\n            nums2 = append(nums2[:y], nums2[y+1:]...)\n        } else {\n            nums1 = append(nums1[:x], nums1[x+1:]...)\n            nums2 = nums2[:len(nums2)-1]\n        }\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var minIndex int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    minIndex = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        minIndex = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[minIndex / len(nums2)], nums2[minIndex % len(nums2)]})\n        nums1 = append(nums1[:minIndex / len(nums2)], nums1[minIndex / len(nums2) + 1:]...)\n        nums2 = append(nums2[:minIndex % len(nums2)], nums2[minIndex % len(nums2) + 1:]...)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[len(nums1) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2[min_index % len(nums2)] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n    return result\n}\n",
    "    // \u5148\u6392\u5e8f\n    for i := 0; i < len(nums1); i++ {\n        for j := i + 1; j < len(nums1); j++ {\n            if nums1[i] > nums1[j] {\n                nums1[i], nums1[j] = nums1[j], nums1[i]\n            }\n        }\n    }\n    for i := 0; i < len(nums2); i++ {\n        for j := i + 1; j < len(nums2); j++ {\n            if nums2[i] > nums2[j] {\n                nums2[i], nums2[j] = nums2[j], nums2[i]\n            }\n        }\n    }\n    // \u53d6\u6700\u5c0f\u7684k\u4e2a\n    var result [][]int\n    for i := 0; i < k; i++ {\n        if i < len(nums1) && i < len(nums2) {\n            result = append(result, []int{nums1[i], nums2[i]})\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for i := 0; i < k && len(queue) > 0; i++ {\n        tmp := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if i == 0 && j == 0 {\n                res[0][0] = nums1[i]\n                res[0][1] = nums2[j]\n            } else {\n                insert(res, nums1[i] + nums2[j], nums1[i], nums2[j])\n            }\n        }\n    }\n\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var index1, index2 int\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[index1], nums2[index2]})\n        if index1 == len(nums1) - 1 {\n            index2++\n        } else if index2 == len(nums2) - 1 {\n            index1++\n        } else if nums1[index1 + 1] + nums2[index2] < nums1[index1] + nums2[index2 + 1] {\n            index1++\n        } else {\n            index2++\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var ret [][]int\n    var min int\n    var min_index int\n    var min_index_2 int\n    var min_index_2_count int\n    var min_index_2_count_max int\n    var min_index_2_count_max_index int\n    var min_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // pop heap\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heapify(heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var index1, index2 int\n    for i := 0; i < k; i++ {\n        if index1 >= len(nums1) {\n            index1 = len(nums1) - 1\n        }\n        if index2 >= len(nums2) {\n            index2 = len(nums2) - 1\n        }\n        if nums1[index1] + nums2[index2] > nums1[len(nums1) - 1] + nums2[index2] {\n            index1 = len(nums1) - 1\n        }\n        if nums1[index1] + nums2[index2] > nums1[index1] + nums2[len(nums2) - 1] {\n            index2 = len(nums2) - 1\n        }\n        result = append(result, []int{nums1[index1], nums2[index2]})\n        if index1 < len(nums1) - 1 && nums1[index1] + nums2[index2] > nums1[index1 + 1] + nums2[index2] {\n            index1++\n        } else if index2 < len(nums2) - 1 && nums1[index1] + nums2[index2] > nums1[index1] + nums2[index2 + 1] {\n            index2++\n        } else {\n            index1++\n            index2++\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp = queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    buildMinHeap(minHeap)\n    for i := 0; i < k && i < len(minHeap); i++ {\n        result = append(result, minHeap[0])\n        minHeap[0] = minHeap[len(minHeap) - 1]\n        minHeap = minHeap[:len(minHeap) - 1]\n        minHeapify(minHeap, 0)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    // pop k times\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        // pop\n        pop := heap[0]\n        heap = heap[1:]\n\n        // push\n        if pop[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[pop[1]] + nums2[pop[2] + 1], pop[1], pop[2] + 1})\n        }\n\n        // add to result\n        result = append(result, []int{nums1[pop[1]], nums2[pop[2]]})\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_index int\n    var min_value int\n    var min_index_found bool\n    for i := 0; i < k; i++ {\n        min_index_found = false\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if !min_index_found {\n                    min_index = j\n                    min_value = nums1[j] + nums2[l]\n                    min_index_found = true\n                } else if nums1[j] + nums2[l] < min_value {\n                    min_index = j\n                    min_value = nums1[j] + nums2[l]\n                }\n            }\n        }\n        if min_index_found {\n            result = append(result, []int{nums1[min_index], min_value - nums1[min_index]})\n            nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        } else {\n            break\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if k > len(res) {\n        return res\n    } else {\n        return res[:k]\n    }\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n\n    for i := 0; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] == nums2[i] {\n                break\n            }\n            if result[j][1] > nums2[i] {\n                for k := k - 1; k > j; k-- {\n                    result[k][0] = result[k-1][0]\n                    result[k][1] = result[k-1][1]\n                }\n                result[j][0] = nums1[0]\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][0] == nums1[i] {\n                break\n            }\n            if result[j][0] > nums1[i] {\n                for k := k - 1; k > j; k-- {\n                    result[k][0] = result[k-1][0]\n                    result[k][1] = result[k-1][1]\n                }\n                result[j][0] = nums1[i]\n                result[j][1] = nums2[0]\n                break\n            }\n        }\n    }\n\n    return result\n}\n\n",
    "    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return res\n    }\n\n    // init heap\n    heap := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap[i * len(nums2) + j] = nums1[i] + nums2[j]\n        }\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if i >= len(heap) {\n            break\n        }\n        res = append(res, []int{heap[0] / nums2[0], heap[0] % nums2[0]})\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heapify(heap, 0, len(heap))\n    }\n\n    return res\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    var heap_size int\n    var heap_push = func(nums []int) {\n        heap = append(heap, nums)\n        heap_size++\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if nums[0] + nums[1] < heap[parent][0] + heap[parent][1] {\n                heap[i] = heap[parent]\n                heap[parent] = nums\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n    var heap_pop = func() []int {\n        if heap_size == 0 {\n            return nil\n        }\n        var result = heap[0]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        heap = heap[:heap_size]\n        var i = 0\n        for i < heap_size {\n            var left = i * 2 + 1\n            var right = i * 2 + 2\n            var min = i\n            if left < heap_size && heap[left][0] + heap[left][1] < heap[min][0] + heap[min][1] {\n                min = left\n            }\n            if right < heap_size && heap[right][0] + heap[right][1] < heap[min][0] + heap[min][1] {\n                min = right\n            }\n            if min != i {\n                heap[i], heap[min] = heap[min], heap[i]\n                i = min\n            } else {\n                break\n            }\n        }\n        return result\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap_push([]int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n\n    for len(res) < k && len(heap) > 0 {\n        pair := heap[0]\n        heap = heap[1:]\n\n        res = append(res, []int{nums1[pair[1]], nums2[pair[2]]})\n\n        if pair[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2]})\n        }\n\n        if pair[1] == 0 && pair[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1})\n        }\n    }\n\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var m = make(map[int]int)\n    var min = nums1[0] + nums2[0]\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            var sum = nums1[i] + nums2[j]\n            if sum < min {\n                min = sum\n            }\n            m[sum]++\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if m[min] > 0 {\n            res = append(res, []int{min, min})\n            m[min]--\n        } else {\n            min++\n            i--\n        }\n    }\n\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(res) < k {\n                res = append(res, []int{nums1[i], nums2[j]})\n            } else {\n                max := res[0][0] + res[0][1]\n                max_index := 0\n                for index, pair := range res {\n                    if pair[0] + pair[1] > max {\n                        max = pair[0] + pair[1]\n                        max_index = index\n                    }\n                }\n                if nums1[i] + nums2[j] < max {\n                    res[max_index] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[len(nums1) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2[min_index % len(nums2)] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min_sum int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min_sum = nums1[j] + nums2[l]\n                    min_index = j\n                    break\n                }\n                if nums1[j] + nums2[l] < min_sum {\n                    min_sum = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min_sum - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heapify(minHeap)\n\n    for i := 0; i < k && i < len(minHeap); i++ {\n        result = append(result, minHeap[0])\n        minHeap[0] = minHeap[len(minHeap) - 1]\n        minHeap = minHeap[:len(minHeap) - 1]\n        heapify(minHeap)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        if len(nums1) == 0 || len(nums2) == 0 {\n            break\n        }\n\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        if min_i == 0 {\n            nums1 = nums1[1:]\n        } else {\n            nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        }\n\n        if min_j == 0 {\n            nums2 = nums2[1:]\n        } else {\n            nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if i % len(nums2) == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            } else {\n                if nums1[j] + nums2[i % len(nums2)] < min {\n                    min = nums1[j] + nums2[i % len(nums2)]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[i % len(nums2)]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var x, y int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    x, y = j, l\n                }\n            }\n        }\n        result = append(result, []int{nums1[x], nums2[y]})\n        nums1 = append(nums1[:x], nums1[x+1:]...)\n        nums2 = append(nums2[:y], nums2[y+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // get k smallest pairs\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n\n        sum, i, j := heap[0][0], heap[0][1], heap[0][2]\n        result = append(result, []int{nums1[i], nums2[j]})\n\n        if j + 1 < len(nums2) {\n            heap[0] = []int{nums1[i] + nums2[j + 1], i, j + 1}\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heapify(heap)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if i == 0 && j == 0 {\n                result[0][0] = nums1[i]\n                result[0][1] = nums2[j]\n            } else {\n                for m := 0; m < k; m++ {\n                    if nums1[i] + nums2[j] < result[m][0] + result[m][1] {\n                        for n := k - 1; n > m; n-- {\n                            result[n][0] = result[n - 1][0]\n                            result[n][1] = result[n - 1][1]\n                        }\n                        result[m][0] = nums1[i]\n                        result[m][1] = nums2[j]\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var pairs [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue = make([]int, 0)\n    var visited = make(map[int]bool)\n    var add_to_queue = func(i, j int) {\n        if _, ok := visited[i * len(nums2) + j]; !ok {\n            queue = append(queue, i * len(nums2) + j)\n            visited[i * len(nums2) + j] = true\n        }\n    }\n    add_to_queue(0, 0)\n    for len(result) < k {\n        var min_index = 0\n        for i := 1; i < len(queue); i++ {\n            if nums1[queue[i] / len(nums2)] + nums2[queue[i] % len(nums2)] < nums1[queue[min_index] / len(nums2)] + nums2[queue[min_index] % len(nums2)] {\n                min_index = i\n            }\n        }\n        var i = queue[min_index] / len(nums2)\n        var j = queue[min_index] % len(nums2)\n        result = append(result, []int{nums1[i], nums2[j]})\n        if i + 1 < len(nums1) {\n            add_to_queue(i + 1, j)\n        }\n        if j + 1 < len(nums2) {\n            add_to_queue(i, j + 1)\n        }\n        queue = append(queue[:min_index], queue[min_index + 1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k <= 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n    var i, j int\n    var sum int\n    var tmp []int\n\n    for i = 0; i < k; i++ {\n        if i < len(nums1) && i < len(nums2) {\n            min_heap = append(min_heap, []int{nums1[i], nums2[i], 0, 0})\n        } else if i < len(nums1) {\n            min_heap = append(min_heap, []int{nums1[i], nums2[0], 0, 0})\n        } else if i < len(nums2) {\n            min_heap = append(min_heap, []int{nums1[0], nums2[i], 0, 0})\n        }\n    }\n\n    heap_size = len(min_heap)\n    build_min_heap(min_heap, heap_size)\n\n    for i = 0; i < k; i++ {\n        tmp = min_heap[0]\n        result = append(result, []int{tmp[0], tmp[1]})\n\n        if tmp[2] == len(nums1) - 1 && tmp[3] == len(nums2) - 1 {\n            break\n        }\n\n        if tmp[3] < len(nums2) - 1 {\n            tmp[1] = nums2[tmp[3] + 1]\n            tmp[3]++\n        } else {\n            tmp[0] = nums1[tmp[2] + 1]\n            tmp[1] = nums2[0]\n            tmp[2]++\n            tmp[3] = 0\n        }",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var tmp []int\n    for i := 0; i < k; i++ {\n        tmp = []int{nums1[i/len(nums2)], nums2[i%len(nums2)]}\n        result = append(result, tmp)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    heap := make([]int, 0, k)\n    heap_index := make([]int, 0, k)\n    heap_index_map := make(map[int]int)\n    for i := 0; i < k; i++ {\n        if i < len(nums1) {\n            heap = append(heap, nums1[i] + nums2[0])\n            heap_index = append(heap_index, i)\n            heap_index_map[i] = 0\n        }\n    }\n    build_heap(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[heap_index[0]], nums2[heap_index_map[heap_index[0]]]})\n        if heap_index_map[heap_index[0]] < len(nums2) - 1 {\n            heap_index_map[heap_index[0]]++\n            heap[0] = nums1[heap_index[0]] + nums2[heap_index_map[heap_index[0]]]\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap_index[0] = heap_index[len(heap_index) - 1]\n            heap_index_map[heap_index[0]] = heap_index_map[heap_index[len(heap_index) - 1]]\n            heap = heap[:len(heap) - 1]\n            heap_index = heap_index[:len(heap_index) - 1]\n        }\n        heapify(heap, 0)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    var visited = make(map[int]bool)\n\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    visited[0] = true\n\n    for len(result) < k && len(queue) > 0 {\n        var pair = queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) && !visited[pair[0] + 1] {\n            visited[pair[0] + 1] = true\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n\n        if pair[1] + 1 < len(nums2) && !visited[pair[1] + 1] {\n            visited[pair[1] + 1] = true\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        result[i][0] = nums1[0]\n        result[i][1] = nums2[0]\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1][0] = nums1[i]\n                result[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m][0], result[m-1][0] = result[m-1][0], result[m][0]\n                        result[m][1], result[m-1][1] = result[m-1][1], result[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(heap) < k {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                if len(heap) == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < len(heap); i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n",
    "    result := make([][]int, 0)\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    // init heap\n    heap := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap[i * len(nums2) + j] = nums1[i] + nums2[j]\n        }\n    }\n    build_heap(heap)\n\n    // pop k elements\n    for i := 0; i < k; i++ {\n        if i >= len(heap) {\n            break\n        }\n        pop_heap(heap)\n        result = append(result, []int{heap[len(heap) - 1] - nums2[len(nums2) - 1], nums2[len(nums2) - 1]})\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k; i++ {\n        result = append(result, heap[i])\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(res) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                    continue\n                }\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n"
  ]
}