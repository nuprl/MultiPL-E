{
  "name": "mbpp_409_min_product_tuple",
  "language": "go_test.go",
  "prompt": "package min_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the minimum product from the pairs of lists within a given list.\nfunc min_product_tuple(list1 [][]interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMin_Product_Tuple(t *testing.T) {\n  candidate := min_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 8 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 30 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var min int\n    for _, list := range list1 {\n        for i, val := range list {\n            if i == 0 {\n                min = val.(int)\n            } else if val.(int) < min {\n                min = val.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, list := range list1 {\n        for i, num := range list {\n            if i == 0 {\n                min = num.(int)\n            } else {\n                if num.(int) < min {\n                    min = num.(int)\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            if i == 0 && j == 0 {\n                min = list1[i][j].(int)\n            } else {\n                if list1[i][j].(int) < min {\n                    min = list1[i][j].(int)\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if min == 0 {\n                min = list3.(int)\n            } else if list3.(int) < min {\n                min = list3.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    min := 0\n    for _, list := range list1 {\n        for _, tuple := range list {\n            if min == 0 {\n                min = tuple.(int)\n            } else if min > tuple.(int) {\n                min = tuple.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    min := 0\n    for _, tuple := range list1 {\n        if min == 0 {\n            min = tuple[0].(int) * tuple[1].(int)\n        } else if min > tuple[0].(int) * tuple[1].(int) {\n            min = tuple[0].(int) * tuple[1].(int)\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, v := range list1 {\n        if len(v) == 2 {\n            if v[0].(int) * v[1].(int) < min {\n                min = v[0].(int) * v[1].(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, list := range list1 {\n        for _, num := range list {\n            if num.(int) < min {\n                min = num.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, list := range list1 {\n        for _, num := range list {\n            switch num.(type) {\n            case int:\n                if min == 0 {\n                    min = num.(int)\n                } else if num.(int) < min {\n                    min = num.(int)\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    min := 0\n    for _, list := range list1 {\n        for _, i := range list {\n            if i.(int) < min {\n                min = i.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    min := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 == l2 {\n                continue\n            }\n            product := l1[0].(int) * l2[1].(int)\n            if min == 0 || product < min {\n                min = product\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, list := range list1 {\n        for i, num := range list {\n            if i == 0 {\n                min = num.(int)\n            } else {\n                if num.(int) < min {\n                    min = num.(int)\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int = 0\n    for _, list := range list1 {\n        for i, val := range list {\n            if i == 0 {\n                min = val.(int)\n            } else {\n                if val.(int) < min {\n                    min = val.(int)\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1[i]); k++ {\n                if j != k {\n                    if min == 0 {\n                        min = list1[i][j].(int) * list1[i][k].(int)\n                    } else {\n                        if list1[i][j].(int) * list1[i][k].(int) < min {\n                            min = list1[i][j].(int) * list1[i][k].(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int\n    for _, list := range list1 {\n        for i, num := range list {\n            if i == 0 {\n                min = num.(int)\n            } else if num.(int) < min {\n                min = num.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    min_product := 0\n    for _, list := range list1 {\n        for _, tuple := range list {\n            if tuple.([]int)[0] * tuple.([]int)[1] < min_product {\n                min_product = tuple.([]int)[0] * tuple.([]int)[1]\n            }\n        }\n    }\n    return min_product\n}\n",
    "    var min int\n    for _, list := range list1 {\n        for _, val := range list {\n            if val.(int) < min {\n                min = val.(int)\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int = 0\n    var product int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            if list1[i][j] != nil {\n                if min == 0 {\n                    min = list1[i][j].(int)\n                } else {\n                    if min > list1[i][j].(int) {\n                        min = list1[i][j].(int)\n                    }\n                }\n            }\n        }\n        product += min\n        min = 0\n    }\n    return product\n}\n",
    "    var min int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1[i][j].([]int)); k++ {\n                if min == 0 {\n                    min = list1[i][j].([]int)[k]\n                } else if min > list1[i][j].([]int)[k] {\n                    min = list1[i][j].([]int)[k]\n                }\n            }\n        }\n    }\n    return min\n}\n",
    "    var min int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            if i == 0 && j == 0 {\n                min = list1[i][j].(int) * list1[i][j+1].(int)\n            } else if list1[i][j].(int) * list1[i][j+1].(int) < min {\n                min = list1[i][j].(int) * list1[i][j+1].(int)\n            }\n        }\n    }\n    return min\n}\n"
  ]
}