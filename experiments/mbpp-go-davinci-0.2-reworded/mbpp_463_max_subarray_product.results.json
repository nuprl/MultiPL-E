{
  "name": "mbpp_463_max_subarray_product",
  "language": "go_test.go",
  "prompt": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcdybrak_test.go:16:31: undefined: min\n/tmp/tmptcdybrak_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcdybrak_test.go:16:31: undefined: min\n/tmp/tmptcdybrak_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max = max * arr[i]\n            min = min * arr[i]\n        } else {\n            max = min * arr[i]\n            min = max * arr[i]\n        }\n        if max > max_so_far {\n            max_so_far = max\n        }\n        if min > max_so_far {\n            max_so_far = min\n        }\n        if max < min {\n            max = min\n        }\n        if min > max {\n            min = max\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "--- FAIL: TestMax_Subarray_Product (0.00s)\n    --- FAIL: TestMax_Subarray_Product/test_num__0 (0.00s)\n        tmperehsv58_test.go:52: expected '%!s(int=112)', got '%!s(int=36)'\n    --- FAIL: TestMax_Subarray_Product/test_num__1 (0.00s)\n        tmperehsv58_test.go:52: expected '%!s(int=180)', got '%!s(int=5400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp49rf1y88_test.go:23:27: undefined: max\n/tmp/tmp49rf1y88_test.go:24:22: undefined: min\n/tmp/tmp49rf1y88_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp81vfiezy_test.go:23:27: undefined: max\n/tmp/tmp81vfiezy_test.go:24:27: undefined: min\n/tmp/tmp81vfiezy_test.go:27:27: undefined: max\n/tmp/tmp81vfiezy_test.go:28:27: undefined: min\n/tmp/tmp81vfiezy_test.go:30:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld6awvcb_test.go:21:31: undefined: min\n/tmp/tmpld6awvcb_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max_product * arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = tmp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgb2d4icd_test.go:16:27: undefined: min\n/tmp/tmpgb2d4icd_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product *= arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = temp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjyzdi2g8_test.go:16:27: undefined: min\n/tmp/tmpjyzdi2g8_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl3pjxq9d_test.go:23:27: undefined: max\n/tmp/tmpl3pjxq9d_test.go:24:27: undefined: min\n/tmp/tmpl3pjxq9d_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_so_far := 1\n    min_so_far := 1\n    max_ending_here := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_so_far = min(min_so_far * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_so_far * v, 1)\n            min_so_far = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvko_ft1u_test.go:16:26: undefined: min\n/tmp/tmpvko_ft1u_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    // max product ending at current position\n    max_ending_here := 1\n    // min product ending at current position\n    min_ending_here := 1\n    // max product so far\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppgld2nsb_test.go:24:31: undefined: min\n/tmp/tmppgld2nsb_test.go:30:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_product = max_product * v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfgeagzy3_test.go:21:27: undefined: min\n/tmp/tmpfgeagzy3_test.go:27:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) < 1 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(max_ending_here * arr[i], arr[i])\n        min_ending_here = min(min_ending_here * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqog5sofm_test.go:20:27: undefined: max\n/tmp/tmpqog5sofm_test.go:21:27: undefined: min\n/tmp/tmpqog5sofm_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipkrcm7n_test.go:20:27: undefined: max\n/tmp/tmpipkrcm7n_test.go:21:27: undefined: min\n/tmp/tmpipkrcm7n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9cunoi8j_test.go:17:23: undefined: max\n/tmp/tmp9cunoi8j_test.go:18:23: undefined: min\n/tmp/tmp9cunoi8j_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_dtnxl6i_test.go:16:27: undefined: min\n/tmp/tmp_dtnxl6i_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        max_product, min_product = max(arr[i], arr[i] * max_product, arr[i] * min_product), min(arr[i], arr[i] * max_product, arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ihrb2u__test.go:17:36: undefined: max\n/tmp/tmp4ihrb2u__test.go:17:93: undefined: min\n/tmp/tmp4ihrb2u__test.go:18:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product, min_product, max_so_far := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fumkvph_test.go:18:23: undefined: max\n/tmp/tmp0fumkvph_test.go:19:23: undefined: min\n/tmp/tmp0fumkvph_test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzhp2p9nc_test.go:23:23: undefined: max\n/tmp/tmpzhp2p9nc_test.go:24:23: undefined: min\n/tmp/tmpzhp2p9nc_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            temp := max_product\n            max_product = min_product\n            min_product = temp\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1nc9zezb_test.go:22:23: undefined: max\n/tmp/tmp1nc9zezb_test.go:23:23: undefined: min\n/tmp/tmp1nc9zezb_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            temp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = temp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_xjymzmw_test.go:21:31: undefined: min\n/tmp/tmp_xjymzmw_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        result = max2(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjnqyy625_test.go:20:15: undefined: max2\n/tmp/tmpjnqyy625_test.go:21:15: undefined: min2\n/tmp/tmpjnqyy625_test.go:22:18: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(temp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeuaysyn__test.go:23:27: undefined: max\n/tmp/tmpeuaysyn__test.go:24:27: undefined: min\n/tmp/tmpeuaysyn__test.go:27:27: undefined: max\n/tmp/tmpeuaysyn__test.go:28:27: undefined: min\n/tmp/tmpeuaysyn__test.go:30:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq5y0o9uq_test.go:19:31: undefined: min\n/tmp/tmpq5y0o9uq_test.go:25:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4e3_4ae_test.go:23:23: undefined: max\n/tmp/tmpk4e3_4ae_test.go:24:23: undefined: min\n/tmp/tmpk4e3_4ae_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp49rf1y88_test.go:23:27: undefined: max\n/tmp/tmp49rf1y88_test.go:24:22: undefined: min\n/tmp/tmp49rf1y88_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        res = max_int(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu59yj6bs_test.go:23:15: undefined: max_int\n/tmp/tmpu59yj6bs_test.go:24:15: undefined: min_int\n/tmp/tmpu59yj6bs_test.go:25:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max_product * arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = temp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbmxdzxu6_test.go:16:27: undefined: min\n/tmp/tmpbmxdzxu6_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcdybrak_test.go:16:31: undefined: min\n/tmp/tmptcdybrak_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu2_0gqf0_test.go:20:27: undefined: max\n/tmp/tmpu2_0gqf0_test.go:21:27: undefined: min\n/tmp/tmpu2_0gqf0_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph3q4k7xu_test.go:27:23: undefined: max\n/tmp/tmph3q4k7xu_test.go:28:23: undefined: min\n/tmp/tmph3q4k7xu_test.go:30:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            temp := max_product\n            max_product = min_product\n            min_product = temp\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4zi4t1s_test.go:25:23: undefined: max\n/tmp/tmpl4zi4t1s_test.go:26:23: undefined: min\n/tmp/tmpl4zi4t1s_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl3pjxq9d_test.go:23:27: undefined: max\n/tmp/tmpl3pjxq9d_test.go:24:27: undefined: min\n/tmp/tmpl3pjxq9d_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = tmp * arr[i]\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5m669yy5_test.go:21:31: undefined: min\n/tmp/tmp5m669yy5_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            min_product, max_product = max_product, min_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1e6_8onm_test.go:23:23: undefined: max\n/tmp/tmp1e6_8onm_test.go:24:23: undefined: min\n/tmp/tmp1e6_8onm_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max, min, res := 1, 1, 1\n    for _, v := range arr {\n        if v > 0 {\n            max *= v\n            min = min * v\n            if min < 1 {\n                min = 1\n            }\n        } else if v < 0 {\n            tmp := max\n            max = min * v\n            min = tmp * v\n            if max < 1 {\n                max = 1\n            }\n        } else {\n            max = 1\n            min = 1\n        }\n        if max > res {\n            res = max\n        }\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123138,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        max_ending_here = max(max(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i])\n        min_ending_here = min(min(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp95u4bkld_test.go:21:27: undefined: max\n/tmp/tmp95u4bkld_test.go:22:27: undefined: min\n/tmp/tmp95u4bkld_test.go:23:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptyjm815h_test.go:22:23: undefined: max\n/tmp/tmptyjm815h_test.go:23:23: undefined: min\n/tmp/tmptyjm815h_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcdybrak_test.go:16:31: undefined: min\n/tmp/tmptcdybrak_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product *= arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = temp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjyzdi2g8_test.go:16:27: undefined: min\n/tmp/tmpjyzdi2g8_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_dtnxl6i_test.go:16:27: undefined: min\n/tmp/tmp_dtnxl6i_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        max_product = max2(max_product, max)\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb9wgokpw_test.go:17:15: undefined: max2\n/tmp/tmpb9wgokpw_test.go:18:15: undefined: min2\n/tmp/tmpb9wgokpw_test.go:19:23: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max, min, res := 1, 1, 1\n    for _, v := range arr {\n        if v > 0 {\n            max *= v\n            min = min * v\n        } else if v < 0 {\n            max, min = min * v, max * v\n        } else {\n            max, min = 1, 1\n        }\n        if max > res {\n            res = max\n        }\n        if min == 0 {\n            min = 1\n        }\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        result = max2(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmq5w9syy_test.go:17:15: undefined: max2\n/tmp/tmpmq5w9syy_test.go:18:15: undefined: min2\n/tmp/tmpmq5w9syy_test.go:19:18: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbtkjwhmg_test.go:21:23: undefined: max\n/tmp/tmpbtkjwhmg_test.go:22:23: undefined: min\n/tmp/tmpbtkjwhmg_test.go:23:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n\n        result = max_int(result, max)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfy0_1s2g_test.go:23:15: undefined: max_int\n/tmp/tmpfy0_1s2g_test.go:24:15: undefined: min_int\n/tmp/tmpfy0_1s2g_test.go:26:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld6awvcb_test.go:21:31: undefined: min\n/tmp/tmpld6awvcb_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_dtnxl6i_test.go:16:27: undefined: min\n/tmp/tmp_dtnxl6i_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg5jhksnq_test.go:25:23: undefined: max\n/tmp/tmpg5jhksnq_test.go:26:23: undefined: min\n/tmp/tmpg5jhksnq_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here *= v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzhcyradw_test.go:21:31: undefined: min\n/tmp/tmpzhcyradw_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4e3_4ae_test.go:23:23: undefined: max\n/tmp/tmpk4e3_4ae_test.go:24:23: undefined: min\n/tmp/tmpk4e3_4ae_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpab54y333_test.go:20:31: undefined: max\n/tmp/tmpab54y333_test.go:21:31: undefined: min\n/tmp/tmpab54y333_test.go:23:31: undefined: max\n/tmp/tmpab54y333_test.go:24:31: undefined: min\n/tmp/tmpab54y333_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here *= v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzhcyradw_test.go:21:31: undefined: min\n/tmp/tmpzhcyradw_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_product = max_product * v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7qsnjf7j_test.go:17:27: undefined: min\n/tmp/tmp7qsnjf7j_test.go:23:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    var max_product, min_product, max_so_far int\n    max_product = 1\n    min_product = 1\n    max_so_far = 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = temp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_w7_4aq9_test.go:17:27: undefined: min\n/tmp/tmp_w7_4aq9_test.go:23:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = tmp * arr[i]\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5m669yy5_test.go:21:31: undefined: min\n/tmp/tmp5m669yy5_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    var max, min, result int\n    max = 1\n    min = 1\n    result = 1\n    for _, v := range arr {\n        if v > 0 {\n            max *= v\n            min = min * v\n            if min > max {\n                min, max = max, min\n            }\n        } else if v < 0 {\n            max, min = min * v, max * v\n            if min > max {\n                min, max = max, min\n            }\n        } else {\n            max = 1\n            min = 1\n        }\n        if max > result {\n            result = max\n        }\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld6awvcb_test.go:21:31: undefined: min\n/tmp/tmpld6awvcb_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], arr[i] * max_product)\n        min_product = min(arr[i], arr[i] * min_product)\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbcq2bneh_test.go:23:23: undefined: max\n/tmp/tmpbcq2bneh_test.go:24:23: undefined: min\n/tmp/tmpbcq2bneh_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product, min_product, max_so_far := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fumkvph_test.go:18:23: undefined: max\n/tmp/tmp0fumkvph_test.go:19:23: undefined: min\n/tmp/tmp0fumkvph_test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3v5yxclp_test.go:18:31: undefined: max\n/tmp/tmp3v5yxclp_test.go:19:31: undefined: min\n/tmp/tmp3v5yxclp_test.go:21:31: undefined: max\n/tmp/tmp3v5yxclp_test.go:22:31: undefined: min\n/tmp/tmp3v5yxclp_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        max_product = max2(max_product, max)\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb9wgokpw_test.go:17:15: undefined: max2\n/tmp/tmpb9wgokpw_test.go:18:15: undefined: min2\n/tmp/tmpb9wgokpw_test.go:19:23: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product = max_product * v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n        if max_product > max_so_far {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9es39wlq_test.go:16:27: undefined: min\n/tmp/tmp9es39wlq_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        result = max_int(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqbhwo11i_test.go:17:15: undefined: max_int\n/tmp/tmpqbhwo11i_test.go:18:15: undefined: min_int\n/tmp/tmpqbhwo11i_test.go:19:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcdybrak_test.go:16:31: undefined: min\n/tmp/tmptcdybrak_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipkrcm7n_test.go:20:27: undefined: max\n/tmp/tmpipkrcm7n_test.go:21:27: undefined: min\n/tmp/tmpipkrcm7n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4e3_4ae_test.go:23:23: undefined: max\n/tmp/tmpk4e3_4ae_test.go:24:23: undefined: min\n/tmp/tmpk4e3_4ae_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_so_far := 1\n    min_so_far := 1\n    max_ending_here := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = tmp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgs0gkbwu_test.go:16:26: undefined: min\n/tmp/tmpgs0gkbwu_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        res = max2(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3eh6tz3__test.go:17:15: undefined: max2\n/tmp/tmp3eh6tz3__test.go:18:15: undefined: min2\n/tmp/tmp3eh6tz3__test.go:19:15: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product = max_product * v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = temp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsozk8qil_test.go:16:27: undefined: min\n/tmp/tmpsozk8qil_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        max_product = max2(max_product, max)\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb9wgokpw_test.go:17:15: undefined: max2\n/tmp/tmpb9wgokpw_test.go:18:15: undefined: min2\n/tmp/tmpb9wgokpw_test.go:19:23: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n\n        result = max_int(result, max)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt51pcb9k_test.go:25:15: undefined: max_int\n/tmp/tmpt51pcb9k_test.go:26:15: undefined: min_int\n/tmp/tmpt51pcb9k_test.go:28:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := 0\n    for i := 0; i < len(arr); i++ {\n        for j := i; j < len(arr); j++ {\n            product := 1\n            for k := i; k <= j; k++ {\n                product *= arr[k]\n            }\n            if product > max {\n                max = product\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1povojp5_test.go:20:27: undefined: max\n/tmp/tmp1povojp5_test.go:21:27: undefined: min\n/tmp/tmp1povojp5_test.go:24:27: undefined: max\n/tmp/tmp1povojp5_test.go:25:27: undefined: min\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 0\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqj_6zz6m_test.go:21:31: undefined: min\n/tmp/tmpqj_6zz6m_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for _, v := range arr[1:] {\n        if v < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(v, max_product * v)\n        min_product = min(v, min_product * v)\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk63nq493_test.go:17:23: undefined: max\n/tmp/tmpk63nq493_test.go:18:23: undefined: min\n/tmp/tmpk63nq493_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    var max, min, result int = arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        result = max_int(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdv2zuffr_test.go:18:15: undefined: max_int\n/tmp/tmpdv2zuffr_test.go:19:15: undefined: min_int\n/tmp/tmpdv2zuffr_test.go:20:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcdybrak_test.go:16:31: undefined: min\n/tmp/tmptcdybrak_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_so_far := 1\n    min_so_far := 1\n    max_ending_here := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_so_far = min(min_so_far * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_so_far * v, 1)\n            min_so_far = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvko_ft1u_test.go:16:26: undefined: min\n/tmp/tmpvko_ft1u_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptu039046_test.go:17:27: undefined: min\n/tmp/tmptu039046_test.go:23:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbmd6k4lw_test.go:18:27: undefined: max\n/tmp/tmpbmd6k4lw_test.go:19:27: undefined: min\n/tmp/tmpbmd6k4lw_test.go:22:27: undefined: max\n/tmp/tmpbmd6k4lw_test.go:23:27: undefined: min\n/tmp/tmpbmd6k4lw_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = temp * v\n        }\n\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp811f6yq__test.go:16:27: undefined: min\n/tmp/tmp811f6yq__test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    var max, min, result int = arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max = max * arr[i]\n            min = min * arr[i]\n        } else {\n            max, min = min * arr[i], max * arr[i]\n        }\n        if max < min {\n            max, min = min, max\n        }\n        if max > result {\n            result = max\n        }\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "--- FAIL: TestMax_Subarray_Product (0.00s)\n    --- FAIL: TestMax_Subarray_Product/test_num__0 (0.00s)\n        tmpp4_pcyfo_test.go:49: expected '%!s(int=112)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn21b46wd_test.go:25:27: undefined: max\n/tmp/tmpn21b46wd_test.go:26:27: undefined: min\n/tmp/tmpn21b46wd_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvdtfy7ya_test.go:18:31: undefined: max\n/tmp/tmpvdtfy7ya_test.go:19:31: undefined: min\n/tmp/tmpvdtfy7ya_test.go:21:31: undefined: max\n/tmp/tmpvdtfy7ya_test.go:22:31: undefined: min\n/tmp/tmpvdtfy7ya_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        max_product_so_far := max_product\n        max_product = max(max(max_product * arr[i], min_product * arr[i]), arr[i])\n        min_product = min(min(max_product_so_far * arr[i], min_product * arr[i]), arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcyqwm9n5_test.go:21:23: undefined: max\n/tmp/tmpcyqwm9n5_test.go:22:23: undefined: min\n/tmp/tmpcyqwm9n5_test.go:23:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    var max_ending_here, min_ending_here, max_so_far int\n    max_ending_here = 1\n    min_ending_here = 1\n    max_so_far = 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = tmp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9wmvh31j_test.go:17:31: undefined: min\n/tmp/tmp9wmvh31j_test.go:23:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld6awvcb_test.go:21:31: undefined: min\n/tmp/tmpld6awvcb_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        a := arr[i] * max_product\n        b := arr[i] * min_product\n        max_product = max(a, b, arr[i])\n        min_product = min(a, b, arr[i])\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw2_7psdk_test.go:21:23: undefined: max\n/tmp/tmpw2_7psdk_test.go:22:23: undefined: min\n/tmp/tmpw2_7psdk_test.go:23:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld6awvcb_test.go:21:31: undefined: min\n/tmp/tmpld6awvcb_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max, min, res := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        res = max_int(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8kz0yrur_test.go:18:15: undefined: max_int\n/tmp/tmp8kz0yrur_test.go:19:15: undefined: min_int\n/tmp/tmp8kz0yrur_test.go:20:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_product := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_so_far = max(max_so_far * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        } else {\n            tmp := max_so_far\n            max_so_far = max(min_so_far * arr[i], arr[i])\n            min_so_far = min(tmp * arr[i], arr[i])\n        }\n\n        max_product = max(max_product, max_so_far)\n    }\n\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptwby8l36_test.go:20:26: undefined: max\n/tmp/tmptwby8l36_test.go:21:26: undefined: min\n/tmp/tmptwby8l36_test.go:24:26: undefined: max\n/tmp/tmptwby8l36_test.go:25:26: undefined: min\n/tmp/tmptwby8l36_test.go:28:23: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n\n        res = max2(res, max)\n    }\n\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfuu0z5x5_test.go:26:15: undefined: max2\n/tmp/tmpfuu0z5x5_test.go:27:15: undefined: min2\n/tmp/tmpfuu0z5x5_test.go:29:15: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjcd_4jju_test.go:25:23: undefined: max\n/tmp/tmpjcd_4jju_test.go:26:23: undefined: min\n/tmp/tmpjcd_4jju_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp49rf1y88_test.go:23:27: undefined: max\n/tmp/tmp49rf1y88_test.go:24:22: undefined: min\n/tmp/tmp49rf1y88_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 0\n    for i := 0; i < len(arr); i++ {\n        product := 1\n        for j := i; j < len(arr); j++ {\n            product *= arr[j]\n            if product > max_product {\n                max_product = product\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzhp2p9nc_test.go:23:23: undefined: max\n/tmp/tmpzhp2p9nc_test.go:24:23: undefined: min\n/tmp/tmpzhp2p9nc_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmputo3t9x8_test.go:22:23: undefined: max\n/tmp/tmputo3t9x8_test.go:23:23: undefined: min\n/tmp/tmputo3t9x8_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph3q4k7xu_test.go:27:23: undefined: max\n/tmp/tmph3q4k7xu_test.go:28:23: undefined: min\n/tmp/tmph3q4k7xu_test.go:30:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn21b46wd_test.go:25:27: undefined: max\n/tmp/tmpn21b46wd_test.go:26:27: undefined: min\n/tmp/tmpn21b46wd_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld6awvcb_test.go:21:31: undefined: min\n/tmp/tmpld6awvcb_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max, min, res := 1, 1, 1\n    for _, v := range arr {\n        if v > 0 {\n            max *= v\n            min = min * v\n        } else if v < 0 {\n            max, min = min * v, max * v\n        } else {\n            max, min = 1, 1\n        }\n        if max > res {\n            res = max\n        }\n        if min > res {\n            res = min\n        }\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max := 1\n    min := 1\n    max_product := 1\n    for _, v := range arr {\n        if v > 0 {\n            max *= v\n            min *= v\n        } else if v < 0 {\n            tmp := max\n            max = min * v\n            min = tmp * v\n        } else {\n            max = 1\n            min = 1\n        }\n        if max > max_product {\n            max_product = max\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u288kiz_test.go:25:23: undefined: max\n/tmp/tmp9u288kiz_test.go:26:23: undefined: min\n/tmp/tmp9u288kiz_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjcd_4jju_test.go:25:23: undefined: max\n/tmp/tmpjcd_4jju_test.go:26:23: undefined: min\n/tmp/tmpjcd_4jju_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph_h8onom_test.go:26:23: undefined: max\n/tmp/tmph_h8onom_test.go:27:23: undefined: min\n/tmp/tmph_h8onom_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdst3bh65_test.go:23:23: undefined: max\n/tmp/tmpdst3bh65_test.go:24:23: undefined: min\n/tmp/tmpdst3bh65_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_product := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n\n        max_product = max(max_product, max_so_far)\n    }\n\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprqzz3ikf_test.go:23:22: undefined: max\n/tmp/tmprqzz3ikf_test.go:24:22: undefined: min\n/tmp/tmprqzz3ikf_test.go:26:23: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph_h8onom_test.go:26:23: undefined: max\n/tmp/tmph_h8onom_test.go:27:23: undefined: min\n/tmp/tmph_h8onom_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product *= arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = temp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjyzdi2g8_test.go:16:27: undefined: min\n/tmp/tmpjyzdi2g8_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = tmp * arr[i]\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5m669yy5_test.go:21:31: undefined: min\n/tmp/tmp5m669yy5_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjlouk4w7_test.go:20:23: undefined: max\n/tmp/tmpjlouk4w7_test.go:21:23: undefined: min\n/tmp/tmpjlouk4w7_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdslv_u2_test.go:23:23: undefined: max\n/tmp/tmpfdslv_u2_test.go:24:23: undefined: min\n/tmp/tmpfdslv_u2_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dkg91sy_test.go:20:23: undefined: max\n/tmp/tmp5dkg91sy_test.go:21:23: undefined: min\n/tmp/tmp5dkg91sy_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl3pjxq9d_test.go:23:27: undefined: max\n/tmp/tmpl3pjxq9d_test.go:24:27: undefined: min\n/tmp/tmpl3pjxq9d_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510246,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpboji4htd_test.go:23:23: undefined: max\n/tmp/tmpboji4htd_test.go:24:23: undefined: min\n/tmp/tmpboji4htd_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123137,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4e3_4ae_test.go:23:23: undefined: max\n/tmp/tmpk4e3_4ae_test.go:24:23: undefined: min\n/tmp/tmpk4e3_4ae_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_product := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_so_far = max(max_so_far * arr[i], arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n\n        max_product = max(max_product, max_so_far)\n    }\n\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123142,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66n8gn6c_test.go:23:22: undefined: max\n/tmp/tmp66n8gn6c_test.go:24:22: undefined: min\n/tmp/tmp66n8gn6c_test.go:26:23: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}