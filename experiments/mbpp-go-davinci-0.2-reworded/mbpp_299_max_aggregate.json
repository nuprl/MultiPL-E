{
  "name": "mbpp_299_max_aggregate",
  "language": "go_test.go",
  "prompt": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of lists.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var max []interface{}\n    for _, row := range stdata {\n        if len(max) == 0 {\n            max = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max[i].(int) {\n                    max[i] = v\n                }\n            }\n        }\n    }\n    return max\n}\n",
    "    // TODO: Implement this function\n    return nil\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, cell := range row {\n                if max_agg[i] == nil {\n                    max_agg[i] = cell\n                } else {\n                    switch cell.(type) {\n                    case int:\n                        if cell.(int) > max_agg[i].(int) {\n                            max_agg[i] = cell\n                        }\n                    case float64:\n                        if cell.(float64) > max_agg[i].(float64) {\n                            max_agg[i] = cell\n                        }\n                    case string:\n                        if cell.(string) > max_agg[i].(string) {\n                            max_agg[i] = cell\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    if len(stdata[0]) == 0 {\n        return nil\n    }\n    if len(stdata[0]) == 1 {\n        return stdata[0]\n    }\n    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if max == nil {\n                max = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max.(int) {\n                    max = stdata[j][i]\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n            continue\n        }\n        for i, v := range row {\n            switch v.(type) {\n            case int:\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            case float64:\n                if v.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = v\n                }\n            case string:\n                if v.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max := stdata[0][i]\n        for j := 1; j < len(stdata); j++ {\n            if stdata[j][i].(int) > max.(int) {\n                max = stdata[j][i]\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, row := range stdata {\n        for _, col := range row {\n            result = append(result, col)\n        }\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, data := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = data\n        } else {\n            for i, v := range data {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_agg[i].(int) {\n                    max_agg[i] = val\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, sublist := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = sublist\n        } else {\n            for i, val := range sublist {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    // TODO: Implement this function\n    return []interface{}{}\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for _, v := range stdata {\n            if max == nil {\n                max = v[i]\n            } else {\n                switch v[i].(type) {\n                case int:\n                    if v[i].(int) > max.(int) {\n                        max = v[i]\n                    }\n                case float64:\n                    if v[i].(float64) > max.(float64) {\n                        max = v[i]\n                    }\n                case string:\n                    if v[i].(string) > max.(string) {\n                        max = v[i]\n                    }\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for _, v := range stdata {\n            if v[i].(float64) > max {\n                max = v[i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    max_agg := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg[i] = stdata[0][i]\n    }\n    for _, row := range stdata {\n        for i, val := range row {\n            if val.(int) > max_agg[i].(int) {\n                max_agg[i] = val\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: implement this function\n    return nil\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var aggregate_value float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate_value += float64(value.(int))\n            case float64:\n                aggregate_value += value.(float64)\n            default:\n                fmt.Println(\"Unsupported type\")\n            }\n        }\n        if aggregate_value > max_aggregate_value {\n            max_aggregate_value = aggregate_value\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        agg_val := 0.0\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_agg[i].(int) {\n                        max_agg[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = val\n                    }\n                case string:\n                    if val.(string) > max_agg[i].(string) {\n                        max_agg[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    // TODO: Implement me!\n    return []interface{}{}\n}\n",
    "    // TODO: Implement me\n    return []interface{}{}\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var aggregate float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate += float64(value.(int))\n            case float64:\n                aggregate += value.(float64)\n            }\n        }\n        if aggregate > max_aggregate_value {\n            max_aggregate_value = aggregate\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 || max_agg[0].(int) < row[0].(int) {\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    var max int\n    for i := 0; i < len(stdata); i++ {\n        var sum int\n        for j := 0; j < len(stdata[i]); j++ {\n            sum += stdata[i][j].(int)\n        }\n        if i == 0 {\n            max = sum\n            result = stdata[i]\n        } else {\n            if sum > max {\n                max = sum\n                result = stdata[i]\n            }\n        }\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, v := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = v\n        } else {\n            for i, vv := range v {\n                if vv.(int) > max_agg[i].(int) {\n                    max_agg[i] = vv\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    max_aggregate := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_aggregate[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if stdata[i][j].(int) > max_aggregate[j].(int) {\n                max_aggregate[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, _ := range row {\n                if row[i].(int) > max_agg[i].(int) {\n                    max_agg[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        for _, col := range row {\n            max_aggregate = append(max_aggregate, col)\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_sum float64\n    for _, row := range stdata {\n        var row_sum float64\n        for _, val := range row {\n            row_sum += val.(float64)\n        }\n        if row_sum > max_agg_sum {\n            max_agg_sum = row_sum\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_agg[j].(int) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max.(int) {\n                    max = stdata[j][i]\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    var max_aggregate_index int\n    for i, row := range stdata {\n        var aggregate float64\n        for _, value := range row {\n            aggregate += value.(float64)\n        }\n        if i == 0 {\n            max_aggregate = row\n            max_aggregate_value = aggregate\n            max_aggregate_index = i\n        } else if aggregate > max_aggregate_value {\n            max_aggregate = row\n            max_aggregate_value = aggregate\n            max_aggregate_index = i\n        }\n    }\n    fmt.Printf(\"Max aggregate is %v at index %d\\n\", max_aggregate, max_aggregate_index)\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max_value interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max_value = stdata[j][i]\n            } else {\n                if max_value.(int) < stdata[j][i].(int) {\n                    max_value = stdata[j][i]\n                }\n            }\n        }\n        result = append(result, max_value)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    var max_agg_sum float64\n    for _, row := range stdata {\n        var row_sum float64\n        for _, val := range row {\n            switch val.(type) {\n            case int:\n                row_sum += float64(val.(int))\n            case float64:\n                row_sum += val.(float64)\n            }\n        }\n        if row_sum > max_agg_sum {\n            max_agg_sum = row_sum\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var row_aggregate float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                row_aggregate += float64(value.(int))\n            case float64:\n                row_aggregate += value.(float64)\n            }\n        }\n        if row_aggregate > max_aggregate_value {\n            max_aggregate_value = row_aggregate\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i]\n            } else {\n                switch stdata[j][i].(type) {\n                case int:\n                    if stdata[j][i].(int) > max.(int) {\n                        max = stdata[j][i]\n                    }\n                case float64:\n                    if stdata[j][i].(float64) > max.(float64) {\n                        max = stdata[j][i]\n                    }\n                case string:\n                    if stdata[j][i].(string) > max.(string) {\n                        max = stdata[j][i]\n                    }\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    var max_aggregate_index int\n    for i, v := range stdata {\n        var aggregate float64\n        for _, v2 := range v {\n            aggregate += v2.(float64)\n        }\n        if i == 0 {\n            max_aggregate_value = aggregate\n            max_aggregate_index = i\n        } else {\n            if aggregate > max_aggregate_value {\n                max_aggregate_value = aggregate\n                max_aggregate_index = i\n            }\n        }\n    }\n    max_aggregate = stdata[max_aggregate_index]\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: implement\n    return []interface{}{}\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j] > max_agg[j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    max_aggregate := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, cell := range row {\n            switch cell.(type) {\n            case int:\n                if cell.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = cell\n                }\n            case float64:\n                if cell.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = cell\n                }\n            case string:\n                if cell.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = cell\n                }\n            case bool:\n                if cell.(bool) {\n                    max_aggregate[i] = cell\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, _ := range row {\n                if row[i].(int) > max_agg[i].(int) {\n                    max_agg[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_value float64\n    for _, row := range stdata {\n        var agg_value float64\n        for _, value := range row {\n            agg_value += value.(float64)\n        }\n        if agg_value > max_agg_value {\n            max_agg_value = agg_value\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    var max_aggregate_index int\n\n    for i, v := range stdata {\n        var aggregate float64\n        for _, v2 := range v {\n            aggregate += v2.(float64)\n        }\n        if i == 0 {\n            max_aggregate_value = aggregate\n            max_aggregate_index = i\n        } else {\n            if aggregate > max_aggregate_value {\n                max_aggregate_value = aggregate\n                max_aggregate_index = i\n            }\n        }\n    }\n    max_aggregate = stdata[max_aggregate_index]\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var aggregate float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate += float64(value.(int))\n            case float64:\n                aggregate += value.(float64)\n            }\n        }\n        if aggregate > max_aggregate_value {\n            max_aggregate_value = aggregate\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    // TODO\n    return nil\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max []interface{}\n    for _, row := range stdata {\n        if len(max) == 0 {\n            max = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max[i].(int) {\n                    max[i] = v\n                }\n            }\n        }\n    }\n    return max\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, cell := range row {\n                switch cell.(type) {\n                case int:\n                    if cell.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = cell\n                    }\n                case float64:\n                    if cell.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = cell\n                    }\n                case string:\n                    if cell.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = cell\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n\n    max_aggregate := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, cell := range row {\n            if i == 0 {\n                max_aggregate[i] = cell\n            } else {\n                switch cell.(type) {\n                case int:\n                    if cell.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = cell\n                    }\n                case float64:\n                    if cell.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = cell\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64 = 0\n    for _, row := range stdata {\n        var agg_val float64 = 0\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        var agg_val float64\n        for _, col := range row {\n            switch col.(type) {\n            case float64:\n                agg_val += col.(float64)\n            }\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    max_aggregate := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_aggregate[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if stdata[i][j].(int) > max_aggregate[j].(int) {\n                max_aggregate[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    // Implement this function.\n    return nil\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_len int\n    for _, row := range stdata {\n        if len(row) > max_agg_len {\n            max_agg = row\n            max_agg_len = len(row)\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, cell := range row {\n                if cell.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = cell\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_aggregate[j] < stdata[i][j] {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    // TODO: Implement this function.\n    return nil\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n            continue\n        }\n        for i, v := range row {\n            switch v.(type) {\n            case int:\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            case float64:\n                if v.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = v\n                }\n            case string:\n                if v.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: Implement me!\n    return nil\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        agg_val := 0.0\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var aggregate float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate += float64(value.(int))\n            case float64:\n                aggregate += value.(float64)\n            }\n        }\n        if aggregate > max_aggregate_value {\n            max_aggregate_value = aggregate\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max_value interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max_value = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max_value.(int) {\n                    max_value = stdata[j][i]\n                }\n            }\n        }\n        result = append(result, max_value)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i := 0; i < len(row); i++ {\n                if row[i].(int) > max_agg[i].(int) {\n                    max_agg[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        var agg_val float64\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    if len(stdata[0]) == 0 {\n        return nil\n    }\n    if len(stdata[0]) == 1 {\n        return stdata[0]\n    }\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max_aggregate = append(max_aggregate, stdata[0][i])\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if max_aggregate[j].(int) < stdata[i][j].(int) {\n                max_aggregate[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var aggregate float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate += float64(value.(int))\n            case float64:\n                aggregate += value.(float64)\n            }\n        }\n        if aggregate > max_aggregate_value {\n            max_aggregate_value = aggregate\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n",
    "    if len(stdata) == 0 {\n        return nil\n    }\n\n    max_aggregate := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, v := range row {\n            switch v.(type) {\n            case int:\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            case float64:\n                if v.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = v\n                }\n            case string:\n                if v.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                default:\n                    fmt.Println(\"Unknown type\")\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: Implement this function.\n    return nil\n}\n",
    "    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        agg := row[len(row)-1]\n        agg_val := agg.(float64)\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_agg[i].(int) {\n                    max_agg[i] = val\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n            continue\n        }\n        for i, col := range row {\n            if col.(int) > max_agg[i].(int) {\n                max_agg[i] = col\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    var max_agg []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg = append(max_agg, stdata[0][i])\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if max_agg[j].(int) < stdata[i][j].(int) {\n                max_agg[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_value float64 = 0.0\n    for _, row := range stdata {\n        var agg_value float64 = 0.0\n        for _, cell := range row {\n            switch cell.(type) {\n            case float64:\n                agg_value += cell.(float64)\n            }\n        }\n        if agg_value > max_agg_value {\n            max_agg_value = agg_value\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        var agg_val float64\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    // TODO: Implement\n    return nil\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, value := range row {\n                if max_aggregate[i] < value {\n                    max_aggregate[i] = value\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, cell := range row {\n                if cell.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = cell\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if len(max_aggregate) == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_aggregate[j] < stdata[i][j] {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    max_aggregate := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, v := range row {\n            if v.(int) > max_aggregate[i].(int) {\n                max_aggregate[i] = v\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_agg[i].(int) {\n                        max_agg[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_agg[j].(int) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate_list []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max_aggregate_value interface{}\n        for j := 0; j < len(stdata); j++ {\n            if max_aggregate_value == nil {\n                max_aggregate_value = stdata[j][i]\n            } else {\n                switch max_aggregate_value.(type) {\n                case int:\n                    if max_aggregate_value.(int) < stdata[j][i].(int) {\n                        max_aggregate_value = stdata[j][i]\n                    }\n                case float64:\n                    if max_aggregate_value.(float64) < stdata[j][i].(float64) {\n                        max_aggregate_value = stdata[j][i]\n                    }\n                case string:\n                    if max_aggregate_value.(string) < stdata[j][i].(string) {\n                        max_aggregate_value = stdata[j][i]\n                    }\n                }\n            }\n        }\n        max_aggregate_list = append(max_aggregate_list, max_aggregate_value)\n    }\n    return max_aggregate_list\n}\n",
    "    // TODO: Implement me!\n    return []interface{}{}\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        agg_val := 0.0\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64 = 0\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    var max_sum int64 = 0\n    for _, data := range stdata {\n        var sum int64 = 0\n        for _, value := range data {\n            sum += value.(int64)\n        }\n        if sum > max_sum {\n            max_sum = sum\n            max_aggregate = data\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: Implement me\n    return nil\n}\n",
    "    // TODO: Write your code here\n    return nil\n}\n",
    "    var max_agg []interface{}\n    var max_agg_value float64\n    for _, row := range stdata {\n        agg_value := 0.0\n        for _, col := range row {\n            switch col.(type) {\n            case int:\n                agg_value += float64(col.(int))\n            case float64:\n                agg_value += col.(float64)\n            }\n        }\n        if agg_value > max_agg_value {\n            max_agg_value = agg_value\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, cell := range row {\n                if cell.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = cell\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max.(int) {\n                    max = stdata[j][i]\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max []interface{}\n    for _, row := range stdata {\n        if len(max) == 0 {\n            max = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max[i].(int) {\n                    max[i] = v\n                }\n            }\n        }\n    }\n    return max\n}\n",
    "    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    max := stdata[0]\n    for _, row := range stdata[1:] {\n        for i, v := range row {\n            if v.(int) > max[i].(int) {\n                max[i] = v\n            }\n        }\n    }\n    return max\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max.(int) {\n                    max = stdata[j][i]\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_aggregate[j] < stdata[i][j] {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, data := range stdata {\n        var aggregate_value float64\n        for _, value := range data {\n            aggregate_value += value.(float64)\n        }\n        if aggregate_value > max_aggregate_value {\n            max_aggregate_value = aggregate_value\n            max_aggregate = data\n        }\n    }\n    return max_aggregate\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i]\n            } else {\n                switch max.(type) {\n                case int:\n                    if stdata[j][i].(int) > max.(int) {\n                        max = stdata[j][i]\n                    }\n                case float64:\n                    if stdata[j][i].(float64) > max.(float64) {\n                        max = stdata[j][i]\n                    }\n                case string:\n                    if stdata[j][i].(string) > max.(string) {\n                        max = stdata[j][i]\n                    }\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i].(float64)\n            } else {\n                if stdata[j][i].(float64) > max {\n                    max = stdata[j][i].(float64)\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_agg[j] < stdata[i][j] {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    // TODO: Implement this function.\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                if max_agg[i] == nil {\n                    max_agg[i] = v\n                } else if v != nil {\n                    switch v.(type) {\n                    case int:\n                        if v.(int) > max_agg[i].(int) {\n                            max_agg[i] = v\n                        }\n                    case float64:\n                        if v.(float64) > max_agg[i].(float64) {\n                            max_agg[i] = v\n                        }\n                    case string:\n                        if v.(string) > max_agg[i].(string) {\n                            max_agg[i] = v\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_agg[i].(int) {\n                    max_agg[i] = val\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 || max_agg[1].(int) < row[1].(int) {\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        for _, value := range row {\n            max_aggregate = append(max_aggregate, value)\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_agg[i].(int) {\n                    max_agg[i] = val\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if j == 0 {\n                    continue\n                } else {\n                    if max_agg[j].(int) < stdata[i][j].(int) {\n                        max_agg[j] = stdata[i][j]\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_agg[j].(int) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i := 0; i < len(row); i++ {\n                if max_agg[i].(int) < row[i].(int) {\n                    max_agg[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    max := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if stdata[i][j].(int) > max[j].(int) {\n                max[j] = stdata[i][j]\n            }\n        }\n    }\n    return max\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, value := range row {\n                if value.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = value\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    var max_agg_val float64\n    for _, row := range stdata {\n        agg_val := 0.0\n        for _, val := range row {\n            agg_val += val.(float64)\n        }\n        if agg_val > max_agg_val {\n            max_agg_val = agg_val\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    max := 0\n    var max_agg []interface{}\n    for _, data := range stdata {\n        agg := 0\n        for _, v := range data {\n            agg += v.(int)\n        }\n        if agg > max {\n            max = agg\n            max_agg = data\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_agg[i].(int) {\n                        max_agg[i] = val.(int)\n                    }\n                case float64:\n                    if val.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = val.(float64)\n                    }\n                case string:\n                    if val.(string) > max_agg[i].(string) {\n                        max_agg[i] = val.(string)\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    // TODO\n    return nil\n}\n",
    "    result := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, v := range row {\n            switch v.(type) {\n            case int:\n                if v.(int) > result[i].(int) {\n                    result[i] = v\n                }\n            case float64:\n                if v.(float64) > result[i].(float64) {\n                    result[i] = v\n                }\n            case string:\n                if v.(string) > result[i].(string) {\n                    result[i] = v\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n",
    "    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    if len(stdata[0]) == 0 {\n        return nil\n    }\n    if len(stdata[0]) == 1 {\n        return stdata[0]\n    }\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max_aggregate = append(max_aggregate, stdata[0][i])\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            case float64:\n                if stdata[i][j].(float64) > max_aggregate[j].(float64) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            case string:\n                if stdata[i][j].(string) > max_aggregate[j].(string) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            default:\n                fmt.Println(\"Unknown type\")\n            }\n        }\n    }\n    return max_aggregate\n}\n",
    "    max := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if stdata[i][j].(int) > max[j].(int) {\n                max[j] = stdata[i][j]\n            }\n        }\n    }\n    return max\n}\n",
    "    var max_agg []interface{}\n    var max_agg_sum int\n    for _, row := range stdata {\n        var agg_sum int\n        for _, v := range row {\n            agg_sum += v.(int)\n        }\n        if agg_sum > max_agg_sum {\n            max_agg_sum = agg_sum\n            max_agg = row\n        }\n    }\n    return max_agg\n}\n"
  ]
}