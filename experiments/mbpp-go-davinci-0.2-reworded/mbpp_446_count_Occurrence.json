{
  "name": "mbpp_446_count_Occurrence",
  "language": "go_test.go",
  "prompt": "package count_Occurrence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to count the occurence of all elements of list in a list.\nfunc count_Occurrence(tup interface{}, lst interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py",
  "prompt_terminology": "reworded",
  "tests": "func TestCount_Occurrence(t *testing.T) {\n  candidate := count_Occurrence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"a\", \"a\", \"c\", \"b\", \"d\"}, []string{\"a\", \"b\"}), expected: 3 },\n     { actual: candidate([]interface{}{1, 2, 3, 1, 4, 6, 7, 1, 4}, []int{1, 4, 7}), expected: 6 },\n     { actual: candidate([]interface{}{1, 2, 3, 4, 5, 6}, []int{1, 2}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch tup.(type) {\n    case string:\n        switch lst.(type) {\n        case []string:\n            count := 0\n            for _, v := range lst.([]string) {\n                if v == tup.(string) {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case int:\n        switch lst.(type) {\n        case []int:\n            count := 0\n            for _, v := range lst.([]int) {\n                if v == tup.(int) {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    switch tup.(type) {\n    case int:\n        switch lst.(type) {\n        case []int:\n            count := 0\n            for _, v := range lst.([]int) {\n                if v == tup.(int) {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case string:\n        switch lst.(type) {\n        case []string:\n            count := 0\n            for _, v := range lst.([]string) {\n                if v == tup.(string) {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var count int\n        for _, v := range lst.([]int) {\n            if v == tup.(int) {\n                count++\n            }\n        }\n        return count\n    case []string:\n        var count int\n        for _, v := range lst.([]string) {\n            if v == tup.(string) {\n                count++\n            }\n        }\n        return count\n    default:\n        return 0\n    }\n}\n",
    "    switch tup.(type) {\n    case int:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_int(tup.(int), lst.([]int))\n        case []string:\n            return count_Occurrence_int_string(tup.(int), lst.([]string))\n        }\n    case string:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_string_int(tup.(string), lst.([]int))\n        case []string:\n            return count_Occurrence_string(tup.(string), lst.([]string))\n        }\n    }\n    return 0\n}\n",
    "    switch lst.(type) {\n    case []int:\n        switch tup.(type) {\n        case int:\n            var count int\n            for _, v := range lst.([]int) {\n                if v == tup.(int) {\n                    count++\n                }\n            }\n            return count\n        case []int:\n            var count int\n            for _, v := range lst.([]int) {\n                for _, v2 := range tup.([]int) {\n                    if v == v2 {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            return -1\n        }\n    case []string:\n        switch tup.(type) {\n        case string:\n            var count int\n            for _, v := range lst.([]string) {\n                if v == tup.(string) {\n                    count++\n                }\n            }\n            return count\n        case []string:\n            var count int\n            for _, v := range lst.([]string) {\n                for _, v2 := range tup.([]string) {\n                    if v == v2 {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            return -1\n        }\n    default:\n        return -1\n    }\n}\n",
    "    switch tup.(type) {\n    case int:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_int_int_slice(tup.(int), lst.([]int))\n        case []string:\n            return count_Occurrence_int_string_slice(tup.(int), lst.([]string))\n        case []float64:\n            return count_Occurrence_int_float64_slice(tup.(int), lst.([]float64))\n        default:\n            panic(\"Unsupported type\")\n        }\n    case string:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_string_int_slice(tup.(string), lst.([]int))\n        case []string:\n            return count_Occurrence_string_string_slice(tup.(string), lst.([]string))\n        case []float64:\n            return count_Occurrence_string_float64_slice(tup.(string), lst.([]float64))\n        default:\n            panic(\"Unsupported type\")\n        }\n    case float64:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_float64_int_slice(tup.(float64), lst.([]int))\n        case []string:\n            return count_Occurrence_float64_string_slice(tup.(float64), lst.([]string))\n        case []float64:\n            return count_Occurrence_float64_float64_slice(tup.(float64), lst.([]float64))\n        default:\n            panic(\"Unsupported type\")\n        }\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n",
    "    switch tup.(type) {\n    case []int:\n        switch lst.(type) {\n        case []int:\n            count := 0\n            for _, v := range tup.([]int) {\n                for _, v2 := range lst.([]int) {\n                    if v == v2 {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            fmt.Println(\"Error: lst is not a list\")\n            return 0\n        }\n    default:\n        fmt.Println(\"Error: tup is not a list\")\n        return 0\n    }\n}\n",
    "    // convert the list to a slice\n    s := lst.([]interface{})\n    // initialize the counter\n    count := 0\n    // loop over the slice\n    for _, v := range s {\n        // if the element is equal to the tuple, increment the counter\n        if v == tup {\n            count += 1\n        }\n    }\n    // return the counter\n    return count\n}\n",
    "    switch tup.(type) {\n    case []int:\n        switch lst.(type) {\n        case []int:\n            tup_lst := tup.([]int)\n            lst_lst := lst.([]int)\n            count := 0\n            for _, tup_val := range tup_lst {\n                for _, lst_val := range lst_lst {\n                    if tup_val == lst_val {\n                        count += 1\n                    }\n                }\n            }\n            return count\n        default:\n            fmt.Println(\"lst is not a list\")\n            return 0\n        }\n    default:\n        fmt.Println(\"tup is not a list\")\n        return 0\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        switch tup.(type) {\n        case int:\n            return count_Occurrence_int_int(tup.(int), lst.([]int))\n        case string:\n            return count_Occurrence_string_int(tup.(string), lst.([]int))\n        }\n    case []string:\n        switch tup.(type) {\n        case int:\n            return count_Occurrence_int_string(tup.(int), lst.([]string))\n        case string:\n            return count_Occurrence_string_string(tup.(string), lst.([]string))\n        }\n    }\n    return 0\n}\n",
    "    switch tup.(type) {\n    case []int:\n        switch lst.(type) {\n        case []int:\n            tup_lst := tup.([]int)\n            lst_lst := lst.([]int)\n            count := 0\n            for _, v := range tup_lst {\n                for _, v2 := range lst_lst {\n                    if v == v2 {\n                        count += 1\n                    }\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case []string:\n        switch lst.(type) {\n        case []string:\n            tup_lst := tup.([]string)\n            lst_lst := lst.([]string)\n            count := 0\n            for _, v := range tup_lst {\n                for _, v2 := range lst_lst {\n                    if v == v2 {\n                        count += 1\n                    }\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_int {\n                if v == tup_int {\n                    count++\n                }\n            }\n            return count\n        case []int:\n            tup_int := tup.([]int)\n            count := 0\n            for _, v := range lst_int {\n                for _, v2 := range tup_int {\n                    if v == v2 {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case []string:\n        lst_str := lst.([]string)\n        switch tup.(type) {\n        case string:\n            tup_str := tup.(string)\n            count := 0\n            for _, v := range lst_str {\n                if v == tup_str {\n                    count++\n                }\n            }\n            return count\n        case []string:\n            tup_str := tup.([]string)\n            count := 0\n            for _, v := range lst_str {\n                for _, v2 := range tup_str {\n                    if v == v2 {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    var count int = 0\n    switch lst.(type) {\n    case []int:\n        for _, v := range lst.([]int) {\n            if v == tup.(int) {\n                count++\n            }\n        }\n    case []string:\n        for _, v := range lst.([]string) {\n            if v == tup.(string) {\n                count++\n            }\n        }\n    case []float64:\n        for _, v := range lst.([]float64) {\n            if v == tup.(float64) {\n                count++\n            }\n        }\n    case []bool:\n        for _, v := range lst.([]bool) {\n            if v == tup.(bool) {\n                count++\n            }\n        }\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            if v == tup {\n                count++\n            }\n        }\n    default:\n        fmt.Println(\"Unsupported type\")\n    }\n    return count\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_int {\n                if v == tup_int {\n                    count++\n                }\n            }\n            return count\n        case string:\n            tup_string := tup.(string)\n            count := 0\n            for _, v := range lst_int {\n                if fmt.Sprintf(\"%d\", v) == tup_string {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case []string:\n        lst_string := lst.([]string)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_string {\n                if fmt.Sprintf(\"%d\", tup_int) == v {\n                    count++\n                }\n            }\n            return count\n        case string:\n            tup_string := tup.(string)\n            count := 0\n            for _, v := range lst_string {\n                if v == tup_string {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_int {\n                if v == tup_int {\n                    count += 1\n                }\n            }\n            return count\n        case string:\n            tup_str := tup.(string)\n            count := 0\n            for _, v := range lst_int {\n                if fmt.Sprintf(\"%d\", v) == tup_str {\n                    count += 1\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case []string:\n        lst_str := lst.([]string)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_str {\n                if fmt.Sprintf(\"%d\", tup_int) == v {\n                    count += 1\n                }\n            }\n            return count\n        case string:\n            tup_str := tup.(string)\n            count := 0\n            for _, v := range lst_str {\n                if v == tup_str {\n                    count += 1\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    var count int\n    switch lst.(type) {\n    case []int:\n        for _, v := range lst.([]int) {\n            if v == tup.(int) {\n                count++\n            }\n        }\n    case []string:\n        for _, v := range lst.([]string) {\n            if v == tup.(string) {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_int {\n                if v == tup_int {\n                    count++\n                }\n            }\n            return count\n        case string:\n            tup_str := tup.(string)\n            count := 0\n            for _, v := range lst_int {\n                if fmt.Sprintf(\"%d\", v) == tup_str {\n                    count++\n                }\n            }\n            return count\n        }\n    case []string:\n        lst_str := lst.([]string)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, v := range lst_str {\n                if fmt.Sprintf(\"%d\", tup_int) == v {\n                    count++\n                }\n            }\n            return count\n        case string:\n            tup_str := tup.(string)\n            count := 0\n            for _, v := range lst_str {\n                if v == tup_str {\n                    count++\n                }\n            }\n            return count\n        }\n    }\n    return 0\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        switch tup.(type) {\n        case int:\n            tup_int := tup.(int)\n            count := 0\n            for _, i := range lst_int {\n                if i == tup_int {\n                    count++\n                }\n            }\n            return count\n        case []int:\n            tup_int := tup.([]int)\n            count := 0\n            for _, i := range lst_int {\n                for _, j := range tup_int {\n                    if i == j {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case []string:\n        lst_str := lst.([]string)\n        switch tup.(type) {\n        case string:\n            tup_str := tup.(string)\n            count := 0\n            for _, i := range lst_str {\n                if i == tup_str {\n                    count++\n                }\n            }\n            return count\n        case []string:\n            tup_str := tup.([]string)\n            count := 0\n            for _, i := range lst_str {\n                for _, j := range tup_str {\n                    if i == j {\n                        count++\n                    }\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    switch tup.(type) {\n    case []int:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_int(tup.([]int), lst.([]int))\n        case []string:\n            return count_Occurrence_int_string(tup.([]int), lst.([]string))\n        default:\n            return 0\n        }\n    case []string:\n        switch lst.(type) {\n        case []int:\n            return count_Occurrence_string_int(tup.([]string), lst.([]int))\n        case []string:\n            return count_Occurrence_string(tup.([]string), lst.([]string))\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n",
    "    switch tup.(type) {\n    case int:\n        switch lst.(type) {\n        case []int:\n            var count int\n            for _, v := range lst.([]int) {\n                if v == tup.(int) {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    case string:\n        switch lst.(type) {\n        case []string:\n            var count int\n            for _, v := range lst.([]string) {\n                if v == tup.(string) {\n                    count++\n                }\n            }\n            return count\n        default:\n            return 0\n        }\n    default:\n        return 0\n    }\n}\n"
  ]
}