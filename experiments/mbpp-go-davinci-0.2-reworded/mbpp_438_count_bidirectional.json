{
  "name": "mbpp_438_count_bidirectional",
  "language": "go_test.go",
  "prompt": "package count_bidirectional_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to count bidirectional list pairs.\nfunc count_bidirectional(test_list [][]interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py",
  "prompt_terminology": "reworded",
  "tests": "func TestCount_Bidirectional(t *testing.T) {\n  candidate := count_bidirectional\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 2}, []interface{}{6, 5}, []interface{}{9, 1}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 3 },\n     { actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 3}, []interface{}{6, 5}, []interface{}{9, 1}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 2 },\n     { actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 2}, []interface{}{6, 5}, []interface{}{9, 2}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 4 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var count int = 0\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for _, test := range test_list {\n        if len(test) == 2 {\n            if test[0] == test[1] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    count := 0\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    // TODO: Implement\n    return 0\n}\n",
    "    var count int\n    for _, test := range test_list {\n        if test[0] == test[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    // We will use a map to keep track of the number of times we have seen each element.\n    // This will allow us to determine if we have seen an element before.\n    seen := make(map[interface{}]int)\n    // We will use a counter to keep track of the number of pairs we have found.\n    count := 0\n    // We will use a pointer to keep track of the current element we are looking at.\n    current := &test_list[0]\n    // We will use a pointer to keep track of the previous element we were looking at.\n    previous := &test_list[0]\n    // We will use a pointer to keep track of the next element we will be looking at.\n    next := &test_list[0]\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before := false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep track of whether or not we have seen the current element before.\n    seen_before = false\n    // We will use a boolean to keep",
    "    // TODO: implement\n    return 0\n}\n",
    "    var count int\n    for _, test := range test_list {\n        count += count_bidirectional_pair(test[0].([]int), test[1].([]int))\n    }\n    return count\n}\n",
    "    var count int\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var count int = 0\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if test_list[i][0] == test_list[j][1] && test_list[i][1] == test_list[j][0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var count int = 0\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if i != j && test_list[i][1] == test_list[j][0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    // Create a map to store the list.\n    list_map := make(map[interface{}]interface{})\n    // Create a map to store the count.\n    count_map := make(map[interface{}]int)\n    // Loop through the list.\n    for _, pair := range test_list {\n        // Add the pair to the list map.\n        list_map[pair[0]] = pair[1]\n        list_map[pair[1]] = pair[0]\n        // Add the pair to the count map.\n        count_map[pair[0]] += 1\n        count_map[pair[1]] += 1\n    }\n    // Create a variable to store the count.\n    count := 0\n    // Loop through the list map.\n    for key, value := range list_map {\n        // Check if the value is in the list map.\n        if list_map[value] == key {\n            // Check if the count is greater than 1.\n            if count_map[key] > 1 {\n                // Increment the count.\n                count += 1\n            }\n        }\n    }\n    // Return the count.\n    return count\n}\n",
    "    // Create a map to store the list.\n    list_map := make(map[interface{}]interface{})\n    // Create a map to store the count.\n    count_map := make(map[interface{}]int)\n    // Loop through the list.\n    for _, pair := range test_list {\n        // Store the first element in the list map.\n        list_map[pair[0]] = pair[1]\n        // Store the second element in the list map.\n        list_map[pair[1]] = pair[0]\n        // Increment the count for the first element.\n        count_map[pair[0]]++\n        // Increment the count for the second element.\n        count_map[pair[1]]++\n    }\n    // Create a variable to store the count.\n    count := 0\n    // Loop through the list map.\n    for _, value := range list_map {\n        // Check if the value is in the count map.\n        if _, ok := count_map[value]; ok {\n            // Decrement the count for the value.\n            count_map[value]--\n        }\n    }\n    // Loop through the count map.\n    for _, value := range count_map {\n        // Check if the value is greater than 0.\n        if value > 0 {\n            // Increment the count.\n            count++\n        }\n    }\n    // Return the count.\n    return count\n}\n",
    "    count := 0\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count += 1\n        }\n    }\n    return count\n}\n",
    "    var count int = 0\n    for _, pair := range test_list {\n        if pair[0] == pair[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for _, list := range test_list {\n        if len(list) == 2 {\n            count++\n        }\n    }\n    return count\n}\n",
    "    // Your code here\n    return 0\n}\n",
    "    var count int\n    for _, test := range test_list {\n        if test[0] == test[1] {\n            count++\n        }\n    }\n    return count\n}\n"
  ]
}