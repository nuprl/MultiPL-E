{
  "name": "mbpp_463_max_subarray_product",
  "language": "go_test.go",
  "prompt": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product sublist of the given list.\nfunc max_subarray_product(arr []int) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n",
    "    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n",
    "    max := arr[0]\n    min := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max = max * arr[i]\n            min = min * arr[i]\n        } else {\n            max = min * arr[i]\n            min = max * arr[i]\n        }\n        if max > max_so_far {\n            max_so_far = max\n        }\n        if min > max_so_far {\n            max_so_far = min\n        }\n        if max < min {\n            max = min\n        }\n        if min > max {\n            min = max\n        }\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n",
    "    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max_product * arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = tmp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n",
    "    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product *= arr[i]\n            min_product = min(min_product * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], 1)\n            min_product = temp * arr[i]\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n",
    "    max_so_far := 1\n    min_so_far := 1\n    max_ending_here := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_so_far = min(min_so_far * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_so_far * v, 1)\n            min_so_far = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n",
    "    if len(arr) == 0 {\n        return 0\n    }\n\n    // max product ending at current position\n    max_ending_here := 1\n    // min product ending at current position\n    min_ending_here := 1\n    // max product so far\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n"
  ]
}