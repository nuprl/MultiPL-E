{
  "name": "mbpp_428_shell_sort",
  "language": "go_test.go",
  "prompt": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given list by using shell sort.\nfunc shell_sort(my_list []int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py",
  "prompt_terminology": "reworded",
  "tests": "func TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    length := len(my_list)\n    gap := length / 2\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    len_list := len(my_list)\n    gap := len_list / 2\n    for gap > 0 {\n        for i := gap; i < len_list; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i++ {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Find the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i - gap; j >= 0 && my_list[j] > my_list[j + gap]; j -= gap {\n                my_list[j], my_list[j + gap] = my_list[j + gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    n := len(my_list)\n    gap := n / 2\n\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i++ {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    length := len(my_list)\n    gap := length / 2\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Set the gap value to half of the list length.\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i; j >= gap && my_list[j - gap] > my_list[j]; j -= gap {\n                my_list[j], my_list[j - gap] = my_list[j - gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // calculate the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for ; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    length := len(my_list)\n    gap := length / 2\n\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // TODO - Add your code here\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for ; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // TODO - Add your code here\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for ; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap for the next element\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    n := len(my_list)\n    gap := n/2\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap/2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := 0; i < gap; i++ {\n            for j := i + gap; j < len(my_list); j += gap {\n                if my_list[j] < my_list[j - gap] {\n                    my_list[j], my_list[j - gap] = my_list[j - gap], my_list[j]\n                }\n            }\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Set the gap value to half of the list length.\n    gap := len(my_list) / 2\n    // Loop until the gap value is less than 1.\n    for gap > 0 {\n        // Loop through the list.\n        for i := gap; i < len(my_list); i++ {\n            // Set the current value to the value at the current index.\n            current_value := my_list[i]\n            // Set the current index to the index of the current value.\n            current_index := i\n            // Loop until the current index is less than the gap value.\n            for current_index >= gap && my_list[current_index - gap] > current_value {\n                // Set the value at the current index to the value at the current index minus the gap value.\n                my_list[current_index] = my_list[current_index - gap]\n                // Set the current index to the current index minus the gap value.\n                current_index -= gap\n            }\n            // Set the value at the current index to the current value.\n            my_list[current_index] = current_value\n        }\n        // Set the gap value to half of the gap value.\n        gap /= 2\n    }\n    // Return the list.\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n\n    return my_list\n}\n",
    "    // TODO - Add your code here\n    return my_list\n}\n",
    "    n := len(my_list)\n    gap := n / 2\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Your code here\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // TODO - Add your code here\n    return my_list\n}\n",
    "    // Get the length of the list.\n    length := len(my_list)\n    // Initialize the gap value.\n    gap := length / 2\n    // Loop until the gap value is greater than 0.\n    for gap > 0 {\n        // Loop through the list.\n        for i := gap; i < length; i++ {\n            // Initialize the temp value.\n            temp := my_list[i]\n            // Initialize the j value.\n            j := i\n            // Loop until the j value is greater than the gap value.\n            for j >= gap && my_list[j - gap] > temp {\n                // Swap the values.\n                my_list[j] = my_list[j - gap]\n                // Decrement the j value.\n                j -= gap\n            }\n            // Set the temp value.\n            my_list[j] = temp\n        }\n        // Decrement the gap value.\n        gap /= 2\n    }\n    // Return the list.\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    length := len(my_list)\n    gap := length / 2\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n",
    "    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n"
  ]
}