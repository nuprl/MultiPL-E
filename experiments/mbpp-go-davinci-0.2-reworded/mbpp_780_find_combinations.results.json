{
  "name": "mbpp_780_find_combinations",
  "language": "go_test.go",
  "prompt": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py",
  "prompt_terminology": "reworded",
  "tests": "func TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    combinations := make([][]interface{}, 0)\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    for _, list := range test_list {\n        for _, item := range list {\n            for _, combination := range combinations {\n                if combination[0].(int) + item.(int) == 10 {\n                    combinations = append(combinations, append(combination, item))\n                }\n            }\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptia_u3y0_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptia_u3y0_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptia_u3y0_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptia_u3y0_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptia_u3y0_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptia_u3y0_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptia_u3y0_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptia_u3y0_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptia_u3y0_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) + test_list[j][0].(int) == test_list[i][1].(int) {\n                result = append(result, []interface{}{test_list[i], test_list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdnrvt1gd_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdnrvt1gd_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdnrvt1gd_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdnrvt1gd_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdnrvt1gd_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdnrvt1gd_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdnrvt1gd_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdnrvt1gd_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdnrvt1gd_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var sum int\n        for _, item := range list {\n            sum += item.(int)\n        }\n        if sum == 0 {\n            result = append(result, list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj_l5ss_7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj_l5ss_7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj_l5ss_7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj_l5ss_7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            for k := 0; k < len(test_list[i]); k++ {\n                for l := 0; l < len(test_list[j]); l++ {\n                    if test_list[i][k].(int) + test_list[j][l].(int) == 0 {\n                        result = append(result, []interface{}{test_list[i][k], test_list[j][l]})\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqbneb2vs_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqbneb2vs_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqbneb2vs_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqbneb2vs_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            sum := 0\n            for _, v := range test_list[i] {\n                sum += v.(int)\n            }\n            for _, v := range test_list[j] {\n                sum += v.(int)\n            }\n            if sum == 0 {\n                result = append(result, []interface{}{test_list[i], test_list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzie6vley_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            for k := 0; k < len(test_list[i]); k++ {\n                for l := 0; l < len(test_list[j]); l++ {\n                    if test_list[i][k].(int) + test_list[j][l].(int) == 0 {\n                        result = append(result, []interface{}{test_list[i][k], test_list[j][l]})\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqbneb2vs_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqbneb2vs_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqbneb2vs_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqbneb2vs_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqbneb2vs_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            if len(result) == 0 {\n                result = append(result, []interface{}{item})\n            } else {\n                for _, result_item := range result {\n                    result = append(result, append(result_item, item))\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3getr3io_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3getr3io_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3getr3io_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3getr3io_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3getr3io_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3getr3io_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3getr3io_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3getr3io_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3getr3io_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbh3zy23a_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbh3zy23a_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbh3zy23a_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbh3zy23a_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbh3zy23a_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbh3zy23a_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbh3zy23a_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbh3zy23a_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbh3zy23a_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            var sum_list []interface{}\n            for k := 0; k < len(test_list[i]); k++ {\n                sum_list = append(sum_list, test_list[i][k])\n            }\n            for k := 0; k < len(test_list[j]); k++ {\n                sum_list = append(sum_list, test_list[j][k])\n            }\n            result = append(result, sum_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3pohi4f_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            var combination []interface{}\n            for _, item := range test_list[i] {\n                combination = append(combination, item)\n            }\n            for _, item := range test_list[j] {\n                combination = append(combination, item)\n            }\n            combinations = append(combinations, combination)\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9nia6kka_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9nia6kka_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9nia6kka_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9nia6kka_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9nia6kka_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9nia6kka_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9nia6kka_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9nia6kka_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9nia6kka_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            sum := 0\n            for _, v := range test_list[i] {\n                sum += v.(int)\n            }\n            for _, v := range test_list[j] {\n                sum += v.(int)\n            }\n            if sum == 0 {\n                result = append(result, []interface{}{test_list[i], test_list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzie6vley_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i, list := range test_list {\n        for j, item := range list {\n            if i == j {\n                continue\n            }\n            for _, item2 := range test_list[j] {\n                if item.(int) + item2.(int) == 0 {\n                    result = append(result, []interface{}{item, item2})\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo6asmwqe_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo6asmwqe_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo6asmwqe_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo6asmwqe_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo6asmwqe_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo6asmwqe_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo6asmwqe_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo6asmwqe_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo6asmwqe_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var combination []interface{}\n            combination = append(combination, element)\n            result = append(result, combination)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9atij0gl_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9atij0gl_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9atij0gl_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9atij0gl_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9atij0gl_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9atij0gl_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9atij0gl_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9atij0gl_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9atij0gl_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        if len(list) == 1 {\n            result = append(result, list)\n        } else {\n            for i := 0; i < len(list); i++ {\n                var new_list []interface{}\n                for j := 0; j < len(list); j++ {\n                    if i != j {\n                        new_list = append(new_list, list[j])\n                    }\n                }\n                result = append(result, new_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ytzb929_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ytzb929_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ytzb929_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ytzb929_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ytzb929_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ytzb929_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ytzb929_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ytzb929_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ytzb929_test.go:38:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var temp_result []interface{}\n        for _, item := range list {\n            temp_result = append(temp_result, item)\n        }\n        result = append(result, temp_result)\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl2tymkl__test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl2tymkl__test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl2tymkl__test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl2tymkl__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var sum int\n            switch item.(type) {\n            case int:\n                sum = item.(int)\n            case float64:\n                sum = int(item.(float64))\n            }\n            for _, list2 := range test_list {\n                for _, item2 := range list2 {\n                    var sum2 int\n                    switch item2.(type) {\n                    case int:\n                        sum2 = item2.(int)\n                    case float64:\n                        sum2 = int(item2.(float64))\n                    }\n                    if sum + sum2 == 10 {\n                        result = append(result, []interface{}{sum, sum2})\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt1pt9v04_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt1pt9v04_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt1pt9v04_test.go:46:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt1pt9v04_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt1pt9v04_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt1pt9v04_test.go:47:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt1pt9v04_test.go:48:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt1pt9v04_test.go:48:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt1pt9v04_test.go:48:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            var sum_list []interface{}\n            for k := 0; k < len(test_list[i]); k++ {\n                sum_list = append(sum_list, test_list[i][k])\n            }\n            for k := 0; k < len(test_list[j]); k++ {\n                sum_list = append(sum_list, test_list[j][k])\n            }\n            result = append(result, sum_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3pohi4f_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        result = append(result, list)\n        for _, list2 := range test_list {\n            if list != list2 {\n                var new_list []interface{}\n                for _, item := range list {\n                    new_list = append(new_list, item)\n                }\n                for _, item := range list2 {\n                    new_list = append(new_list, item)\n                }\n                result = append(result, new_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptx1je9oq_test.go:14:21: invalid operation: list != list2 (slice can only be compared to nil)\n/tmp/tmptx1je9oq_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptx1je9oq_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptx1je9oq_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptx1je9oq_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptx1je9oq_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptx1je9oq_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptx1je9oq_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptx1je9oq_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptx1je9oq_test.go:38:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptx1je9oq_test.go:38:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) > len(test_list[j]) {\n                result = append(result, test_list[i])\n            } else {\n                result = append(result, test_list[j])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpra6huev__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpra6huev__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpra6huev__test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpra6huev__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpra6huev__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpra6huev__test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpra6huev__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpra6huev__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpra6huev__test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var temp_result [][]interface{}\n        for _, item := range list {\n            if len(temp_result) == 0 {\n                temp_result = append(temp_result, []interface{}{item})\n            } else {\n                for _, temp_list := range temp_result {\n                    var new_list []interface{}\n                    new_list = append(new_list, temp_list...)\n                    new_list = append(new_list, item)\n                    temp_result = append(temp_result, new_list)\n                }\n            }\n        }\n        if len(result) == 0 {\n            result = temp_result\n        } else {\n            var new_result [][]interface{}\n            for _, result_list := range result {\n                for _, temp_list := range temp_result {\n                    var new_list []interface{}\n                    new_list = append(new_list, result_list...)\n                    new_list = append(new_list, temp_list...)\n                    new_result = append(new_result, new_list)\n                }\n            }\n            result = new_result\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa7cntbmm_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa7cntbmm_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa7cntbmm_test.go:50:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa7cntbmm_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa7cntbmm_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa7cntbmm_test.go:51:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa7cntbmm_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa7cntbmm_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa7cntbmm_test.go:52:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            fmt.Println(item)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4_yr8njg_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4_yr8njg_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4_yr8njg_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4_yr8njg_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4_yr8njg_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4_yr8njg_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4_yr8njg_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4_yr8njg_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4_yr8njg_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            var combination []interface{}\n            combination = append(combination, test_list[i])\n            combination = append(combination, test_list[j])\n            combinations = append(combinations, combination)\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm40oi65z_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm40oi65z_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm40oi65z_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm40oi65z_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm40oi65z_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm40oi65z_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm40oi65z_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm40oi65z_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm40oi65z_test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if i != j {\n                result = append(result, append(test_list[i], test_list[j]...))\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyxcj7rg0_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpyxcj7rg0_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyxcj7rg0_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyxcj7rg0_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpyxcj7rg0_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyxcj7rg0_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyxcj7rg0_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpyxcj7rg0_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyxcj7rg0_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    var sum_list []interface{}\n    var sum_list_index int\n    var sum_list_length int\n    var sum_list_value int\n    var sum_list_value_index int\n    var sum_list_value_length int\n    var sum_list_value_value int\n    var sum_list_value_value_index int\n    var sum_list_value_value_length int\n    var sum_list_value_value_value int\n    var sum_list_value_value_value_index int\n    var sum_list_value_value_value_length int\n    var sum_list_value_value_value_value int\n    var sum_list_value_value_value_value_index int\n    var sum_list_value_value_value_value_length int\n    var sum_list_value_value_value_value_value int\n    var sum_list_value_value_value_value_value_index int\n    var sum_list_value_value_value_value_value_length int\n    var sum_list_value_value_value_value_value_value int\n    var sum_list_value_value_value_value_value_value_index int\n    var sum_list_value_value_value_value_value_value_length int\n    var sum_list_value_value_value_value_value_value_value int\n    var sum_list_value_value_value_value_value_value_value_index int\n    var sum_list_value_value_value_value_value_value_value_length int\n    var sum_list_value_value_value_value_value_value_value_value int\n    var sum_list_value_value_value_value_value_value_value_value_index int\n    var sum_list_value_value_value_value_value_value_value_value_length int\n    var sum_list_value_value_value_value_value_value_value_value_value int\n    var sum_list_value_value_value_value_value_value_value_value_value_index int\n    var sum_list\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123266,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0htdt82r_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp_list []interface{}\n            temp_list = append(temp_list, item)\n            result = append(result, temp_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5jpepubd_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var temp_result []interface{}\n        for _, item := range list {\n            temp_result = append(temp_result, item)\n        }\n        result = append(result, temp_result)\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl2tymkl__test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl2tymkl__test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl2tymkl__test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl2tymkl__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl2tymkl__test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            var sum = 0\n            for k := 0; k < len(test_list[i]); k++ {\n                sum += test_list[i][k].(int)\n            }\n            for k := 0; k < len(test_list[j]); k++ {\n                sum += test_list[j][k].(int)\n            }\n            if sum == 0 {\n                result = append(result, []interface{}{test_list[i], test_list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaseetney_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaseetney_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaseetney_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaseetney_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaseetney_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaseetney_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaseetney_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaseetney_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaseetney_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if sum(test_list[i]) == sum(test_list[j]) {\n                result = append(result, test_list[i], test_list[j])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgriry3ts_test.go:13:16: undefined: sum\n/tmp/tmpgriry3ts_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgriry3ts_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgriry3ts_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgriry3ts_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgriry3ts_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgriry3ts_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgriry3ts_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgriry3ts_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgriry3ts_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgriry3ts_test.go:30:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    // Create a new list to store the results\n    result_list := make([][]interface{}, 0)\n    // Loop through the list\n    for i := 0; i < len(test_list); i++ {\n        // Create a new list to store the current combination\n        current_list := make([]interface{}, 0)\n        // Loop through the current list\n        for j := 0; j < len(test_list[i]); j++ {\n            // Check if the current element is a list\n            if test_list[i][j] != nil {\n                // Check if the current element is a list\n                if test_list[i][j].([]interface{}) != nil {\n                    // Loop through the current list\n                    for k := 0; k < len(test_list[i][j].([]interface{})); k++ {\n                        // Append the current element to the current list\n                        current_list = append(current_list, test_list[i][j].([]interface{})[k])\n                    }\n                } else {\n                    // Append the current element to the current list\n                    current_list = append(current_list, test_list[i][j])\n                }\n            }\n        }\n        // Append the current list to the result list\n        result_list = append(result_list, current_list)\n    }\n    // Return the result list\n    return result_list\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppxg87uco_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppxg87uco_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppxg87uco_test.go:47:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppxg87uco_test.go:48:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppxg87uco_test.go:48:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppxg87uco_test.go:48:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppxg87uco_test.go:49:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppxg87uco_test.go:49:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppxg87uco_test.go:49:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            sum := 0\n            for _, v := range test_list[i] {\n                sum += v.(int)\n            }\n            for _, v := range test_list[j] {\n                sum += v.(int)\n            }\n            if sum == 0 {\n                result = append(result, []interface{}{test_list[i], test_list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzie6vley_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzie6vley_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzie6vley_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var new_list []interface{}\n            new_list = append(new_list, element)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9yi2u2qn_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, item := range list {\n            new_list = append(new_list, item)\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig4xh10k_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpig4xh10k_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig4xh10k_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig4xh10k_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpig4xh10k_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig4xh10k_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig4xh10k_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpig4xh10k_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig4xh10k_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var temp []interface{}\n            temp = append(temp, element)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp852pqtx3_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp852pqtx3_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp852pqtx3_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp852pqtx3_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := [][]interface{}{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7dwpzvfj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            if item.(int) == 0 {\n                result = append(result, list)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsa0g5llv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsa0g5llv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsa0g5llv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsa0g5llv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsa0g5llv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsa0g5llv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsa0g5llv_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsa0g5llv_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsa0g5llv_test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            result = append(result, []interface{}{element})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_6grvy7f_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_6grvy7f_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_6grvy7f_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_6grvy7f_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkkkkxvup_test.go:16:65: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmpkkkkxvup_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if i != j {\n                for _, item1 := range test_list[i] {\n                    for _, item2 := range test_list[j] {\n                        if item1.(int) + item2.(int) == 0 {\n                            result = append(result, []interface{}{item1, item2})\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz6dk_9w6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz6dk_9w6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz6dk_9w6_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz6dk_9w6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz6dk_9w6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz6dk_9w6_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz6dk_9w6_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz6dk_9w6_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz6dk_9w6_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmlxzly2g_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmlxzly2g_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmlxzly2g_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmlxzly2g_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmlxzly2g_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmlxzly2g_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmlxzly2g_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmlxzly2g_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmlxzly2g_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkkkkxvup_test.go:16:65: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmpkkkkxvup_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp_list []interface{}\n            temp_list = append(temp_list, item)\n            result = append(result, temp_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5jpepubd_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc7jomyko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var sum int\n        for _, element := range list {\n            sum += element.(int)\n        }\n        result = append(result, []interface{}{sum, list})\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0wkiqc5x_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0wkiqc5x_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0wkiqc5x_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0wkiqc5x_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0wkiqc5x_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0wkiqc5x_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0wkiqc5x_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0wkiqc5x_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0wkiqc5x_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    var sum_list []int\n    for _, list := range test_list {\n        sum := 0\n        for _, item := range list {\n            sum += item.(int)\n        }\n        sum_list = append(sum_list, sum)\n    }\n    for i := 0; i < len(sum_list); i++ {\n        for j := i + 1; j < len(sum_list); j++ {\n            if sum_list[i] == sum_list[j] {\n                result = append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6i9i7t54_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6i9i7t54_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6i9i7t54_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6i9i7t54_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6i9i7t54_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6i9i7t54_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6i9i7t54_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6i9i7t54_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6i9i7t54_test.go:38:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var temp_result [][]interface{}\n        for _, item := range list {\n            if len(result) == 0 {\n                temp_result = append(temp_result, []interface{}{item})\n            } else {\n                for _, result_item := range result {\n                    temp_result = append(temp_result, append(result_item, item))\n                }\n            }\n        }\n        result = temp_result\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkb59pxdx_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkb59pxdx_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkb59pxdx_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkb59pxdx_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkb59pxdx_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkb59pxdx_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkb59pxdx_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkb59pxdx_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkb59pxdx_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            result = append(result, []interface{}{element})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_6grvy7f_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_6grvy7f_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_6grvy7f_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_6grvy7f_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_6grvy7f_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            var sum_list []interface{}\n            for k := 0; k < len(test_list[i]); k++ {\n                sum_list = append(sum_list, test_list[i][k])\n            }\n            for k := 0; k < len(test_list[j]); k++ {\n                sum_list = append(sum_list, test_list[j][k])\n            }\n            result = append(result, sum_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3pohi4f_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv3pohi4f_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv3pohi4f_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    var temp []interface{}\n    var sum int\n    for _, list := range test_list {\n        sum = 0\n        temp = []interface{}{}\n        for _, item := range list {\n            sum += item.(int)\n            temp = append(temp, item)\n        }\n        if sum == 10 {\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8oz9dx9j_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8oz9dx9j_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8oz9dx9j_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8oz9dx9j_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8oz9dx9j_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8oz9dx9j_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8oz9dx9j_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8oz9dx9j_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8oz9dx9j_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkkkkxvup_test.go:16:65: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmpkkkkxvup_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkkkkxvup_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkkkkxvup_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var sum int\n        for _, item := range list {\n            sum += item.(int)\n        }\n        if sum == 0 {\n            result = append(result, list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj_l5ss_7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj_l5ss_7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj_l5ss_7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj_l5ss_7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj_l5ss_7_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if i == j {\n                continue\n            }\n            for k := 0; k < len(test_list[i]); k++ {\n                for l := 0; l < len(test_list[j]); l++ {\n                    if test_list[i][k].(int) + test_list[j][l].(int) == 0 {\n                        result = append(result, []interface{}{test_list[i][k], test_list[j][l]})\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphf96cssm_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphf96cssm_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphf96cssm_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphf96cssm_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphf96cssm_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphf96cssm_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphf96cssm_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphf96cssm_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphf96cssm_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                for k := 0; k < len(test_list[i]); k++ {\n                    if test_list[i][k] == test_list[j][k] {\n                        result = append(result, test_list[i])\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp78rr686e_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp78rr686e_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp78rr686e_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp78rr686e_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp78rr686e_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp78rr686e_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp78rr686e_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp78rr686e_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp78rr686e_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    var temp []interface{}\n    var sum int\n    var temp_sum int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    for i = 0; i < len(test_list); i++ {\n        for j = 0; j < len(test_list[i]); j++ {\n            for k = 0; k < len(test_list); k++ {\n                for l = 0; l < len(test_list[k]); l++ {\n                    for m = 0; m < len(test_list); m++ {\n                        for n = 0; n < len(test_list[m]); n++ {\n                            for o = 0; o < len(test_list); o++ {\n                                for p = 0; p < len(test_list[o]); p++ {\n                                    for q = 0; q < len(test_list); q++ {\n                                        for r = 0; r < len(test_list[q]); r++ {\n                                            for s = 0; s < len(test_list); s++ {\n                                                for t = 0; t < len(test_list[s]); t++ {\n                                                    for u = 0; u < len(test_list); u++ {\n                                                        for v = 0; v < len(test_list[u]); v++ {\n                                                            for w = 0; w < len(test_list); w++ {\n                                                                for x = 0; x < len(test_list[w]); x++ {\n                                                                    for y = 0; y < len(test_list); y++ {\n                                                                        for z = 0; z < len(test_list[y]); z++ {\n                                                                            sum = test_list[i][j].(int) + test_list[k][\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp30dbtgqn_test.go:52:6: expected '(', found TestFind_Combinations\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, value := range list {\n            combinations = append(combinations, []interface{}{value})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2n741u4z_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2n741u4z_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2n741u4z_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2n741u4z_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2n741u4z_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2n741u4z_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2n741u4z_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2n741u4z_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2n741u4z_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc7jomyko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            combinations = append(combinations, []interface{}{element})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo946ywnx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            combinations = append(combinations, []interface{}{element})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo946ywnx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sub_list := range test_list {\n        for _, item := range sub_list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2ztsrn23_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2ztsrn23_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2ztsrn23_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2ztsrn23_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2ztsrn23_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2ztsrn23_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2ztsrn23_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2ztsrn23_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2ztsrn23_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    var sum_list []interface{}\n    var sum_list_index int\n    var sum_list_length int\n    var sum_list_element interface{}\n    var sum_list_element_index int\n    var sum_list_element_length int\n    var sum_list_element_element interface{}\n    var sum_list_element_element_index int\n    var sum_list_element_element_length int\n    var sum_list_element_element_element interface{}\n    var sum_list_element_element_element_index int\n    var sum_list_element_element_element_length int\n    var sum_list_element_element_element_element interface{}\n    var sum_list_element_element_element_element_index int\n    var sum_list_element_element_element_element_length int\n    var sum_list_element_element_element_element_element interface{}\n    var sum_list_element_element_element_element_element_index int\n    var sum_list_element_element_element_element_element_length int\n    var sum_list_element_element_element_element_element_element interface{}\n    var sum_list_element_element_element_element_element_element_index int\n    var sum_list_element_element_element_element_element_element_length int\n    var sum_list_element_element_element_element_element_element_element interface{}\n    var sum_list_element_element_element_element_element_element_element_index int\n    var sum_list_element_element_element_element_element_element_element_length int\n    var sum_list_element_element_element_element_element_element_element_element interface{}\n    var sum_list_element_element_element_element_element_element_element_element_index int\n    var sum_list_element_element_element_element_element_element_element_element_length int\n    var sum_list_element_element_element_element_element_element_element_element_element interface{}\n    var sum_list_element_element_element_element_\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1881pb2a_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) + test_list[j][0].(int) == test_list[i][1].(int) {\n                combinations = append(combinations, []interface{}{test_list[i], test_list[j]})\n            }\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnfkl49y2_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnfkl49y2_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnfkl49y2_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnfkl49y2_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnfkl49y2_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnfkl49y2_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnfkl49y2_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnfkl49y2_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnfkl49y2_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var temp []interface{}\n            temp = append(temp, element)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp852pqtx3_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp852pqtx3_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp852pqtx3_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp852pqtx3_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp852pqtx3_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    combinations := [][]interface{}{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ngqepin_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4ngqepin_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ngqepin_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ngqepin_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4ngqepin_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ngqepin_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ngqepin_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4ngqepin_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ngqepin_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i, _ := range test_list {\n        for j, _ := range test_list {\n            if i != j {\n                for _, a := range test_list[i] {\n                    for _, b := range test_list[j] {\n                        if a.(int) + b.(int) == 10 {\n                            result = append(result, []interface{}{a, b})\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_lq17lro_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_lq17lro_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_lq17lro_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_lq17lro_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_lq17lro_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_lq17lro_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_lq17lro_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_lq17lro_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_lq17lro_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc7jomyko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc7jomyko_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc7jomyko_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var list_result [][]interface{}\n        for _, item := range list {\n            if len(list_result) == 0 {\n                list_result = append(list_result, []interface{}{item})\n            } else {\n                var new_list_result [][]interface{}\n                for _, list_item := range list_result {\n                    new_list_result = append(new_list_result, append(list_item, item))\n                }\n                list_result = append(list_result, new_list_result...)\n            }\n        }\n        if len(result) == 0 {\n            result = list_result\n        } else {\n            var new_result [][]interface{}\n            for _, list_item := range list_result {\n                for _, result_item := range result {\n                    new_result = append(new_result, append(list_item, result_item...))\n                }\n            }\n            result = new_result\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7nr_bm3c_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7nr_bm3c_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7nr_bm3c_test.go:46:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7nr_bm3c_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7nr_bm3c_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7nr_bm3c_test.go:47:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7nr_bm3c_test.go:48:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7nr_bm3c_test.go:48:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7nr_bm3c_test.go:48:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var temp_list []interface{}\n        for _, item := range list {\n            temp_list = append(temp_list, item)\n        }\n        result = append(result, temp_list)\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp081dsyxz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp081dsyxz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp081dsyxz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp081dsyxz_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp081dsyxz_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp081dsyxz_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp081dsyxz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp081dsyxz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp081dsyxz_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var sum int\n        for _, item := range list {\n            sum += item.(int)\n        }\n        result = append(result, []interface{}{sum, list})\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgv8asbhw_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgv8asbhw_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgv8asbhw_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgv8asbhw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            if item.(int) == 0 {\n                result = append(result, list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123271,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbe6btncv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbe6btncv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbe6btncv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbe6btncv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbe6btncv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbe6btncv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbe6btncv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbe6btncv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbe6btncv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for i, list := range test_list {\n        for j, _ := range list {\n            for k, _ := range test_list[i+1:] {\n                for l, _ := range test_list[i+1:][k] {\n                    if list[j].(int) + test_list[i+1:][k][l].(int) == 0 {\n                        combinations = append(combinations, []interface{}{list[j], test_list[i+1:][k][l]})\n                    }\n                }\n            }\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123271,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppoirrpee_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppoirrpee_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppoirrpee_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppoirrpee_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppoirrpee_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppoirrpee_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppoirrpee_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppoirrpee_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppoirrpee_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i+1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123271,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx_fjj7gl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx_fjj7gl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx_fjj7gl_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx_fjj7gl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx_fjj7gl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx_fjj7gl_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx_fjj7gl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx_fjj7gl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx_fjj7gl_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := [][]interface{}{}\n    for _, list := range test_list {\n        result = append(result, find_combinations_in_list(list)...)\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmdx0d8i3_test.go:12:33: undefined: find_combinations_in_list\n/tmp/tmpmdx0d8i3_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmdx0d8i3_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmdx0d8i3_test.go:24:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmdx0d8i3_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmdx0d8i3_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmdx0d8i3_test.go:25:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmdx0d8i3_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmdx0d8i3_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmdx0d8i3_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmdx0d8i3_test.go:26:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    // Initialize a list to hold the combinations\n    combinations := make([][]interface{}, 0)\n\n    // Iterate through the list of lists\n    for i := 0; i < len(test_list); i++ {\n        // Iterate through the list of lists\n        for j := 0; j < len(test_list); j++ {\n            // If the lists are not the same\n            if i != j {\n                // Initialize a list to hold the combination\n                combination := make([]interface{}, 0)\n\n                // Iterate through the first list\n                for k := 0; k < len(test_list[i]); k++ {\n                    // Append the value to the combination\n                    combination = append(combination, test_list[i][k])\n                }\n\n                // Iterate through the second list\n                for k := 0; k < len(test_list[j]); k++ {\n                    // Append the value to the combination\n                    combination = append(combination, test_list[j][k])\n                }\n\n                // Append the combination to the list of combinations\n                combinations = append(combinations, combination)\n            }\n        }\n    }\n\n    // Return the list of combinations\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp765d_83h_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp765d_83h_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp765d_83h_test.go:51:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp765d_83h_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp765d_83h_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp765d_83h_test.go:52:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp765d_83h_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp765d_83h_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp765d_83h_test.go:53:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if i != j {\n                for _, a := range test_list[i] {\n                    for _, b := range test_list[j] {\n                        if a.(int) + b.(int) == 0 {\n                            result = append(result, []interface{}{a, b})\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd439_3_7_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd439_3_7_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd439_3_7_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd439_3_7_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd439_3_7_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd439_3_7_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd439_3_7_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd439_3_7_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd439_3_7_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            for k := 0; k < len(test_list[i]); k++ {\n                for l := 0; l < len(test_list[j]); l++ {\n                    if test_list[i][k].(int) + test_list[j][l].(int) == 0 {\n                        combinations = append(combinations, []interface{}{test_list[i][k], test_list[j][l]})\n                    }\n                }\n            }\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl1afm3t1_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl1afm3t1_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl1afm3t1_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl1afm3t1_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl1afm3t1_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl1afm3t1_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl1afm3t1_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl1afm3t1_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl1afm3t1_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i+1; j < len(test_list); j++ {\n            if len(test_list[i]) != len(test_list[j]) {\n                continue\n            }\n            var sum_list []interface{}\n            for k := 0; k < len(test_list[i]); k++ {\n                sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n            }\n            result = append(result, sum_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeaklqlzt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeaklqlzt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeaklqlzt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeaklqlzt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeaklqlzt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeaklqlzt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeaklqlzt_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeaklqlzt_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeaklqlzt_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var new_list []interface{}\n            new_list = append(new_list, element)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9yi2u2qn_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            combinations = append(combinations, []interface{}{element})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo946ywnx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var sum int\n        for _, item := range list {\n            sum += item.(int)\n        }\n        result = append(result, []interface{}{sum, list})\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgv8asbhw_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgv8asbhw_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgv8asbhw_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgv8asbhw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgv8asbhw_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := [][]interface{}{}\n    for _, list := range test_list {\n        for i, item := range list {\n            result = append(result, []interface{}{item})\n            for j := i + 1; j < len(list); j++ {\n                result = append(result, []interface{}{item, list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjab1tu73_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjab1tu73_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjab1tu73_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjab1tu73_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjab1tu73_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjab1tu73_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjab1tu73_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjab1tu73_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjab1tu73_test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    // TODO: Implement\n    return nil\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp805x4m0i_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp805x4m0i_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp805x4m0i_test.go:21:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp805x4m0i_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp805x4m0i_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp805x4m0i_test.go:22:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp805x4m0i_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp805x4m0i_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp805x4m0i_test.go:23:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := [][]interface{}{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7dwpzvfj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            combinations = append(combinations, []interface{}{element})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo946ywnx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo946ywnx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo946ywnx_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    // create a map of the sums of the lists\n    sums := make(map[int][]interface{})\n    for _, list := range test_list {\n        sum := 0\n        for _, value := range list {\n            sum += value.(int)\n        }\n        sums[sum] = list\n    }\n\n    // create a map of the sums of the sums\n    sums_of_sums := make(map[int][]interface{})\n    for sum, list := range sums {\n        for sum2, list2 := range sums {\n            if sum == sum2 {\n                continue\n            }\n            sum_of_sums := sum + sum2\n            sums_of_sums[sum_of_sums] = append(sums_of_sums[sum_of_sums], list)\n            sums_of_sums[sum_of_sums] = append(sums_of_sums[sum_of_sums], list2)\n        }\n    }\n\n    // create a map of the sums of the sums of the sums\n    sums_of_sums_of_sums := make(map[int][]interface{})\n    for sum, list := range sums_of_sums {\n        for sum2, list2 := range sums_of_sums {\n            if sum == sum2 {\n                continue\n            }\n            sum_of_sums_of_sums := sum + sum2\n            sums_of_sums_of_sums[sum_of_sums_of_sums] = append(sums_of_sums_of_sums[sum_of_sums_of_sums], list)\n            sums_of_sums_of_sums[sum_of_sums_of_sums] = append(sums_of_sums_of_sums[sum_of_sums_of_sums], list2)\n        }\n    }\n\n    // create a map of the sums of the sums of the sums of the sums\n    sums_of_sums_of_sums_of_sums := make(map[int][]interface{})\n    for sum, list := range sums\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123271,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7ichvfem_test.go:48:32: expected '{', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for _, list := range test_list {\n        for i, item := range list {\n            if i == 0 {\n                continue\n            }\n            if item.(int) == list[i-1].(int) {\n                result = append(result, list)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfl31l76f_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfl31l76f_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfl31l76f_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfl31l76f_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfl31l76f_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfl31l76f_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfl31l76f_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfl31l76f_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfl31l76f_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    var temp_combination []interface{}\n    var temp_list []interface{}\n    var temp_list_index int\n    var temp_list_length int\n    var temp_list_value interface{}\n    var temp_list_value_int int\n    var temp_list_value_float float64\n    var temp_list_value_string string\n    var temp_list_value_bool bool\n    var temp_combination_length int\n    var temp_combination_value interface{}\n    var temp_combination_value_int int\n    var temp_combination_value_float float64\n    var temp_combination_value_string string\n    var temp_combination_value_bool bool\n    var temp_combination_value_sum int\n    var temp_combination_value_sum_float float64\n    var temp_combination_value_sum_string string\n    var temp_combination_value_sum_bool bool\n    var temp_combination_value_sum_int_bool bool\n    var temp_combination_value_sum_float_bool bool\n    var temp_combination_value_sum_string_bool bool\n    var temp_combination_value_sum_bool_bool bool\n    var temp_combination_value_sum_bool_true bool\n    var temp_combination_value_sum_bool_false bool\n    var temp_combination_value_sum_bool_true_bool bool\n    var temp_combination_value_sum_bool_false_bool bool\n    var temp_combination_value_sum_bool_true_true bool\n    var temp_combination_value_sum_bool_true_false bool\n    var temp_combination_value_sum_bool_false_true bool\n    var temp_combination_value_sum_bool_false_false bool\n    var temp_combination_value_sum_bool_true_true_bool bool\n    var temp_combination_value_sum_bool_true_false_bool bool\n    var temp_combination_value_sum_bool_false_true_bool bool\n    var temp_combination_value_sum_bool_false_false\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123271,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpty1w0cbh_test.go:45:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var temp []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    temp = append(temp, test_list[i][k] + test_list[j][k])\n                }\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp035fwpif_test.go:16:57: invalid operation: test_list[i][k] + test_list[j][k] (operator + not defined on interface)\n/tmp/tmp035fwpif_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp035fwpif_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp035fwpif_test.go:34:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        result = append(result, find_combinations_in_list(list))\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp08xdwq3k_test.go:12:33: undefined: find_combinations_in_list\n/tmp/tmp08xdwq3k_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp08xdwq3k_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp08xdwq3k_test.go:24:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp08xdwq3k_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp08xdwq3k_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp08xdwq3k_test.go:25:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp08xdwq3k_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp08xdwq3k_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp08xdwq3k_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp08xdwq3k_test.go:26:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i, list := range test_list {\n        for j, item := range list {\n            if i == 0 {\n                result = append(result, []interface{}{item})\n            } else {\n                for k, _ := range result {\n                    result[k] = append(result[k], item)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzye1k53__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzye1k53__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzye1k53__test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzye1k53__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzye1k53__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzye1k53__test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzye1k53__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzye1k53__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzye1k53__test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    combinations := [][]interface{}{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            for k := 0; k < len(test_list[i]); k++ {\n                for l := 0; l < len(test_list[j]); l++ {\n                    if test_list[i][k].(int) + test_list[j][l].(int) == 0 {\n                        combinations = append(combinations, []interface{}{test_list[i][k], test_list[j][l]})\n                    }\n                }\n            }\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprxhfbrs3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprxhfbrs3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprxhfbrs3_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprxhfbrs3_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprxhfbrs3_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprxhfbrs3_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprxhfbrs3_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprxhfbrs3_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprxhfbrs3_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := [][]interface{}{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7dwpzvfj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7dwpzvfj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7dwpzvfj_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        result = append(result, list)\n        for _, list2 := range test_list {\n            if list != list2 {\n                result = append(result, append(list, list2...))\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdd_npxdr_test.go:14:21: invalid operation: list != list2 (slice can only be compared to nil)\n/tmp/tmpdd_npxdr_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdd_npxdr_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdd_npxdr_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdd_npxdr_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdd_npxdr_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdd_npxdr_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdd_npxdr_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdd_npxdr_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdd_npxdr_test.go:31:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdd_npxdr_test.go:31:152: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := [][]interface{}{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) != len(test_list[j]) {\n                continue\n            }\n            for k := 0; k < len(test_list[i]); k++ {\n                if test_list[i][k] != test_list[j][k] {\n                    continue\n                }\n            }\n            result = append(result, test_list[i])\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy52hhhls_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy52hhhls_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy52hhhls_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy52hhhls_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy52hhhls_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy52hhhls_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy52hhhls_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy52hhhls_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy52hhhls_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var new_list []interface{}\n            new_list = append(new_list, element)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9yi2u2qn_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9yi2u2qn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9yi2u2qn_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            sum := 0\n            for _, v := range test_list[i] {\n                sum += v.(int)\n            }\n            for _, v := range test_list[j] {\n                sum += v.(int)\n            }\n            if sum == 0 {\n                result = append(result, append(test_list[i], test_list[j]...))\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpko1ughu3_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpko1ughu3_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpko1ughu3_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpko1ughu3_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpko1ughu3_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpko1ughu3_test.go:36:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpko1ughu3_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpko1ughu3_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpko1ughu3_test.go:37:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp []interface{}\n            temp = append(temp, item)\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg59usqzv_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpg59usqzv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg59usqzv_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var temp []interface{}\n        for _, item := range list {\n            temp = append(temp, item)\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2zcm1du8_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2zcm1du8_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2zcm1du8_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2zcm1du8_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2zcm1du8_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2zcm1du8_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2zcm1du8_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2zcm1du8_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2zcm1du8_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for i, list := range test_list {\n        for j, num := range list {\n            for k, list2 := range test_list[i+1:] {\n                for l, num2 := range list2 {\n                    if num.(int) + num2.(int) == 0 {\n                        combinations = append(combinations, []interface{}{[]interface{}{i, j}, []interface{}{k+i+1, l}})\n                    }\n                }\n            }\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1ihfhdwc_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1ihfhdwc_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ihfhdwc_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ihfhdwc_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1ihfhdwc_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ihfhdwc_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ihfhdwc_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1ihfhdwc_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ihfhdwc_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var combinations [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            combinations = append(combinations, []interface{}{item})\n        }\n    }\n    return combinations\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapw953jz_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpapw953jz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpapw953jz_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                var sum_list []interface{}\n                for k := 0; k < len(test_list[i]); k++ {\n                    sum_list = append(sum_list, test_list[i][k].(int) + test_list[j][k].(int))\n                }\n                result = append(result, sum_list)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123270,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeflg3lpt_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:32:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeflg3lpt_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeflg3lpt_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    // create a list of lists to hold the combinations\n    combinations := make([][]interface{}, 0)\n    // create a list to hold the current combination\n    current_combination := make([]interface{}, 0)\n    // create a list to hold the current list\n    current_list := make([]interface{}, 0)\n    // create a list to hold the current sum\n    current_sum := 0\n    // create a list to hold the current index\n    current_index := 0\n    // create a list to hold the current list index\n    current_list_index := 0\n    // create a list to hold the current list length\n    current_list_length := 0\n    // create a list to hold the current list sum\n    current_list_sum := 0\n    // create a list to hold the current list sum\n    current_list_sum_index := 0\n    // create a list to hold the current list sum\n    current_list_sum_length := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_index := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_length := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_index := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_length := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_sum := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_sum_index := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_sum_length := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_sum_sum := 0\n    // create a list to hold the current list sum\n    current_list_sum_sum_sum_sum\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123271,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzb3j0wsj_test.go:52:6: expected '(', found TestFind_Combinations\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var temp_list []interface{}\n            temp_list = append(temp_list, item)\n            result = append(result, temp_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123267,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5jpepubd_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5jpepubd_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5jpepubd_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, element := range list {\n            var temp_list []interface{}\n            temp_list = append(temp_list, element)\n            result = append(result, temp_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmjktd9b4_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmjktd9b4_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmjktd9b4_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmjktd9b4_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmjktd9b4_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmjktd9b4_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmjktd9b4_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmjktd9b4_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmjktd9b4_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            var new_list []interface{}\n            new_list = append(new_list, item)\n            result = append(result, new_list)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4ts89ij_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:29:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx4ts89ij_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx4ts89ij_test.go:30:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    result := make([][]interface{}, 0)\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if len(test_list[i]) == len(test_list[j]) {\n                for k := 0; k < len(test_list[i]); k++ {\n                    if test_list[i][k] == test_list[j][k] {\n                        result = append(result, test_list[i])\n                        result = append(result, test_list[j])\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123272,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn9pdqvlb_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn9pdqvlb_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn9pdqvlb_test.go:33:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn9pdqvlb_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn9pdqvlb_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn9pdqvlb_test.go:34:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn9pdqvlb_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn9pdqvlb_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn9pdqvlb_test.go:35:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, []interface{}{item})\n        }\n    }\n    return result\n}\n\nfunc TestFind_Combinations(t *testing.T) {\n  candidate := find_combinations\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },\n     { actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },\n     { actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510140,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpexn6f_2y_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:26:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:27:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpexn6f_2y_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpexn6f_2y_test.go:28:152: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}