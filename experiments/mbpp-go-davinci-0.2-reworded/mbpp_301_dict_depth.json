{
  "name": "mbpp_301_dict_depth",
  "language": "go_test.go",
  "prompt": "package dict_depth_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the depth of a map.\nfunc dict_depth(d interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "reworded",
  "tests": "func TestDict_Depth(t *testing.T) {\n  candidate := dict_depth\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]interface{}{\"a\": 1, \"b\": map[string]UNKNOWN{\"c\": map[string]UNKNOWN{\"d\": map[interface{}]interface{}{}}}}), expected: 4 },\n     { actual: candidate(map[string]interface{}{\"a\": 1, \"b\": map[string]string{\"c\": \"python\"}}), expected: 2 },\n     { actual: candidate(map[int]interface{}{1: \"Sun\", 2: map[int]UNKNOWN{3: map[int]string{4: \"Mon\"}}}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n        case map[string]string:\n            return 1 + dict_depth(d.(map[string]string)[\"a\"])\n        case string:\n            return 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]string)[\"b\"]))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[\"a\"]),\n                       dict_depth(d.(map[string]int)[\"b\"]))\n    case map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]float64)[\"a\"]),\n                       dict_depth(d.(map[string]float64)[\"b\"]))\n    case map[string]bool:\n        return 1 + max(dict_depth(d.(map[string]bool)[\"a\"]),\n                       dict_depth(d.(map[string]bool)[\"b\"]))\n    case map[string]map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]map[string]interface{})[\"b\"]))\n    case map[string]map[string]string:\n        return 1 + max(dict_depth(d.(map[string]map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]string)[\"b\"]))\n    case map[string]map[string]int:\n        return 1 + max(dict_depth(d.(map[string]map[string]int)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]int)[\"b\"]))\n    case map[string]map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]map[string]float64)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]float",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max_depth(d.([]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        var max int\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n"
  ]
}