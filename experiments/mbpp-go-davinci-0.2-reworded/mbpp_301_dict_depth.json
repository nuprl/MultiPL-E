{
  "name": "mbpp_301_dict_depth",
  "language": "go_test.go",
  "prompt": "package dict_depth_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the depth of a map.\nfunc dict_depth(d interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "reworded",
  "tests": "func TestDict_Depth(t *testing.T) {\n  candidate := dict_depth\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]interface{}{\"a\": 1, \"b\": map[string]UNKNOWN{\"c\": map[string]UNKNOWN{\"d\": map[interface{}]interface{}{}}}}), expected: 4 },\n     { actual: candidate(map[string]interface{}{\"a\": 1, \"b\": map[string]string{\"c\": \"python\"}}), expected: 2 },\n     { actual: candidate(map[int]interface{}{1: \"Sun\", 2: map[int]UNKNOWN{3: map[int]string{4: \"Mon\"}}}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n        case map[string]string:\n            return 1 + dict_depth(d.(map[string]string)[\"a\"])\n        case string:\n            return 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]string)[\"b\"]))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[\"a\"]),\n                       dict_depth(d.(map[string]int)[\"b\"]))\n    case map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]float64)[\"a\"]),\n                       dict_depth(d.(map[string]float64)[\"b\"]))\n    case map[string]bool:\n        return 1 + max(dict_depth(d.(map[string]bool)[\"a\"]),\n                       dict_depth(d.(map[string]bool)[\"b\"]))\n    case map[string]map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]map[string]interface{})[\"b\"]))\n    case map[string]map[string]string:\n        return 1 + max(dict_depth(d.(map[string]map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]string)[\"b\"]))\n    case map[string]map[string]int:\n        return 1 + max(dict_depth(d.(map[string]map[string]int)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]int)[\"b\"]))\n    case map[string]map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]map[string]float64)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]float",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max_depth(d.([]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        var max int\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            max = max_int(max, dict_depth(v))\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if t := dict_depth(v); t > max {\n                max = t\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if t := dict_depth(v); t > max {\n                max = t\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(e) for _, e := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    var max int\n    switch d.(type) {\n    case map[string]interface{}:\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        for _, v := range d.([]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case map[string]int:\n        return 1 + dict_depth(d.(map[string]int)[\"a\"])\n    case map[string]float64:\n        return 1 + dict_depth(d.(map[string]float64)[\"a\"])\n    case map[string]bool:\n        return 1 + dict_depth(d.(map[string]bool)[\"a\"])\n    case map[string]map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]map[string]interface{})[\"a\"])\n    case map[string]map[string]string:\n        return 1 + dict_depth(d.(map[string]map[string]string)[\"a\"])\n    case map[string]map[string]int:\n        return 1 + dict_depth(d.(map[string]map[string]int)[\"a\"])\n    case map[string]map[string]float64:\n        return 1 + dict_depth(d.(map[string]map[string]float64)[\"a\"])\n    case map[string]map[string]bool:\n        return 1 + dict_depth(d.(map[string]map[string]bool)[\"a\"])\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, val := range v {\n            depth := dict_depth(val)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(e) for e := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        var max int\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        case []interface{}:\n            max := 0\n            for _, v := range d.([]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max\n        default:\n            return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    if d == nil {\n        return 0\n    }\n\n    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case map[string]int:\n        return 1 + dict_depth(d.(map[string]int)[\"a\"])\n    case map[string]float64:\n        return 1 + dict_depth(d.(map[string]float64)[\"a\"])\n    case map[string]bool:\n        return 1 + dict_depth(d.(map[string]bool)[\"a\"])\n    case map[string]map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]map[string]interface{})[\"a\"])\n    case map[string]map[string]string:\n        return 1 + dict_depth(d.(map[string]map[string]string)[\"a\"])\n    case map[string]map[string]int:\n        return 1 + dict_depth(d.(map[string]map[string]int)[\"a\"])\n    case map[string]map[string]float64:\n        return 1 + dict_depth(d.(map[string]map[string]float64)[\"a\"])\n    case map[string]map[string]bool:\n        return 1 + dict_depth(d.(map[string]map[string]bool)[\"a\"])\n    case map[string]map[string]map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]map[string]map[string]interface{})[\"a\"])\n    case map[string]map[string]map[string]string:\n        return 1 + dict_depth(d.(map[string]map[string]map[string]string)[\"a\"])\n    case map[string]map[string]map[string]int:\n        return 1 + dict_depth(d.(map[string]map[string]map[string]int)[\"a\"])\n    case map[string]map[string]map[string]float",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[k]) for k, _ := range d.(map[string]string))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[k]) for k, _ := range d.(map[string]int))\n    case map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]float64)[k]) for k, _ := range d.(map[string]float64))\n    case map[string]bool:\n        return 1 + max(dict_depth(d.(map[string]bool)[k]) for k, _ := range d.(map[string]bool))\n    case map[int]interface{}:\n        return 1 + max(dict_depth(d.(map[int]interface{})[k]) for k, _ := range d.(map[int]interface{}))\n    case map[int]string:\n        return 1 + max(dict_depth(d.(map[int]string)[k]) for k, _ := range d.(map[int]string))\n    case map[int]int:\n        return 1 + max(dict_depth(d.(map[int]int)[k]) for k, _ := range d.(map[int]int))\n    case map[int]float64:\n        return 1 + max(dict_depth(d.(map[int]float64)[k]) for k, _ := range d.(map[int]float64))\n    case map[int]bool:\n        return 1 + max(dict_depth(d.(map[int]bool)[k]) for k, _ := range d.(map[int]bool))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[\"a\"]), dict_depth(d.(map[string]int)[\"b\"]))\n    case map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]float64)[\"a\"]), dict_depth(d.(map[string]float64)[\"b\"]))\n    case map[string]bool:\n        return 1 + max(dict_depth(d.(map[string]bool)[\"a\"]), dict_depth(d.(map[string]bool)[\"b\"]))\n    case map[string]map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]map[string]interface{})[\"a\"]), dict_depth(d.(map[string]map[string]interface{})[\"b\"]))\n    case map[string]map[string]string:\n        return 1 + max(dict_depth(d.(map[string]map[string]string)[\"a\"]), dict_depth(d.(map[string]map[string]string)[\"b\"]))\n    case map[string]map[string]int:\n        return 1 + max(dict_depth(d.(map[string]map[string]int)[\"a\"]), dict_depth(d.(map[string]map[string]int)[\"b\"]))\n    case map[string]map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]map[string]float64)[\"a\"]), dict_depth(d.(map[string]map[string]float64)[\"b\"]))\n    case map[string]map[string]bool",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(e) for e := range d.([]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[\"a\"]), dict_depth(d.(map[string]int)[\"b\"]))\n    case map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]float64)[\"a\"]), dict_depth(d.(map[string]float64)[\"b\"]))\n    case map[string]bool:\n        return 1 + max(dict_depth(d.(map[string]bool)[\"a\"]), dict_depth(d.(map[string]bool)[\"b\"]))\n    case map[string]map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]map[string]interface{})[\"a\"]), dict_depth(d.(map[string]map[string]interface{})[\"b\"]))\n    case map[string]map[string]string:\n        return 1 + max(dict_depth(d.(map[string]map[string]string)[\"a\"]), dict_depth(d.(map[string]map[string]string)[\"b\"]))\n    case map[string]map[string]int:\n        return 1 + max(dict_depth(d.(map[string]map[string]int)[\"a\"]), dict_depth(d.(map[string]map[string]int)[\"b\"]))\n    case map[string]map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]map[string]float64)[\"a\"]), dict_depth(d.(map[string]map[string]float64)[\"b\"]))\n    case map[string]map[string]bool",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max_depth(d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n        case map[string]string:\n            return 1 + dict_depth(d.(map[string]string)[\"a\"])\n        case map[string]int:\n            return 1 + dict_depth(d.(map[string]int)[\"a\"])\n        case map[string]float64:\n            return 1 + dict_depth(d.(map[string]float64)[\"a\"])\n        case map[string]bool:\n            return 1 + dict_depth(d.(map[string]bool)[\"a\"])\n        case map[string]map[string]interface{}:\n            return 1 + dict_depth(d.(map[string]map[string]interface{})[\"a\"])\n        case map[string]map[string]string:\n            return 1 + dict_depth(d.(map[string]map[string]string)[\"a\"])\n        case map[string]map[string]int:\n            return 1 + dict_depth(d.(map[string]map[string]int)[\"a\"])\n        case map[string]map[string]float64:\n            return 1 + dict_depth(d.(map[string]map[string]float64)[\"a\"])\n        case map[string]map[string]bool:\n            return 1 + dict_depth(d.(map[string]map[string]bool)[\"a\"])\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]string)[\"b\"]))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[\"a\"]),\n                       dict_depth(d.(map[string]int)[\"b\"]))\n    case map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]float64)[\"a\"]),\n                       dict_depth(d.(map[string]float64)[\"b\"]))\n    case map[string]bool:\n        return 1 + max(dict_depth(d.(map[string]bool)[\"a\"]),\n                       dict_depth(d.(map[string]bool)[\"b\"]))\n    case map[string]map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]map[string]interface{})[\"b\"]))\n    case map[string]map[string]string:\n        return 1 + max(dict_depth(d.(map[string]map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]string)[\"b\"]))\n    case map[string]map[string]int:\n        return 1 + max(dict_depth(d.(map[string]map[string]int)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]int)[\"b\"]))\n    case map[string]map[string]float64:\n        return 1 + max(dict_depth(d.(map[string]map[string]float64)[\"a\"]),\n                       dict_depth(d.(map[string]map[string]float",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        case []interface{}:\n            max := 0\n            for _, v := range d.([]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    case map[string]string:\n        return 1 + max_depth(d.(map[string]string))\n    case map[string]int:\n        return 1 + max_depth(d.(map[string]int))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    if d == nil {\n        return 0\n    }\n    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[string]string:\n        max := 0\n        for _, v := range d.(map[string]string) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[string]int:\n        max := 0\n        for _, v := range d.(map[string]int) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[string]float64:\n        max := 0\n        for _, v := range d.(map[string]float64) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[string]bool:\n        max := 0\n        for _, v := range d.(map[string]bool) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[int]interface{}:\n        max := 0\n        for _, v := range d.(map[int]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[int]string:\n        max := 0\n        for _, v := range d.(map[int]string) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case map[int]int:\n        max := 0\n        for _, v := range d.(map[int]int",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        a := d.([]interface{})\n        max := 0\n        for _, v := range a {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case string:\n        return 1\n    case nil:\n        return 0\n    default:\n        panic(fmt.Sprintf(\"unexpected type: %T\", d))\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max_depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max_depth {\n                max_depth = depth\n            }\n        }\n        return max_depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range v {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k in d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i in range(len(d.([]interface{}))))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.([]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case map[string]int:\n        return 1 + dict_depth(d.(map[string]int)[\"a\"])\n    case map[string]float64:\n        return 1 + dict_depth(d.(map[string]float64)[\"a\"])\n    case map[string]bool:\n        return 1 + dict_depth(d.(map[string]bool)[\"a\"])\n    case map[int]interface{}:\n        return 1 + dict_depth(d.(map[int]interface{})[0])\n    case map[int]string:\n        return 1 + dict_depth(d.(map[int]string)[0])\n    case map[int]int:\n        return 1 + dict_depth(d.(map[int]int)[0])\n    case map[int]float64:\n        return 1 + dict_depth(d.(map[int]float64)[0])\n    case map[int]bool:\n        return 1 + dict_depth(d.(map[int]bool)[0])\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]),\n                       dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]),\n                       dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[k]) for k := range d.(map[string]string))\n    case map[string]int:\n        return 1 + max(dict_depth(d.(map[string]int)[k]) for k := range d.(map[string]int))\n    case map[int]interface{}:\n        return 1 + max(dict_depth(d.(map[int]interface{})[k]) for k := range d.(map[int]interface{}))\n    case map[int]string:\n        return 1 + max(dict_depth(d.(map[int]string)[k]) for k := range d.(map[int]string))\n    case map[int]int:\n        return 1 + max(dict_depth(d.(map[int]int)[k]) for k := range d.(map[int]int))\n    default:\n        return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, val := range v {\n            depth := dict_depth(val)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        depth := 0\n        for _, v := range m {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    case []interface{}:\n        a := d.([]interface{})\n        depth := 0\n        for _, v := range a {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                if depth := dict_depth(v); depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k in d)\n    case []interface{}:\n        return 1 + max(dict_depth(v) for v in d)\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]interface{})[\"a\"])\n    case map[string]string:\n        return 1 + dict_depth(d.(map[string]string)[\"a\"])\n    case map[string]int:\n        return 1 + dict_depth(d.(map[string]int)[\"a\"])\n    case map[string]float64:\n        return 1 + dict_depth(d.(map[string]float64)[\"a\"])\n    case map[string]bool:\n        return 1 + dict_depth(d.(map[string]bool)[\"a\"])\n    case map[string]map[string]interface{}:\n        return 1 + dict_depth(d.(map[string]map[string]interface{})[\"a\"])\n    case map[string]map[string]string:\n        return 1 + dict_depth(d.(map[string]map[string]string)[\"a\"])\n    case map[string]map[string]int:\n        return 1 + dict_depth(d.(map[string]map[string]int)[\"a\"])\n    case map[string]map[string]float64:\n        return 1 + dict_depth(d.(map[string]map[string]float64)[\"a\"])\n    case map[string]map[string]bool:\n        return 1 + dict_depth(d.(map[string]map[string]bool)[\"a\"])\n    default:\n        return 0\n    }\n}\n"
  ]
}