{
  "name": "mbpp_120_max_product_tuple",
  "language": "go_test.go",
  "prompt": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, val1 := range list {\n            for j, val2 := range list {\n                if i != j {\n                    product := val1.(int) * val2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfc2s8_uu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfc2s8_uu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfc2s8_uu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfc2s8_uu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfc2s8_uu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfc2s8_uu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpod3uzyty_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc6qh7f3h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for _, list := range list1 {\n        for i, num := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num.(int) * num2.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzp2shph6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzp2shph6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzp2shph6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzp2shph6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzp2shph6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzp2shph6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp398natxz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp398natxz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp398natxz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp398natxz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp398natxz_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp398natxz_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqdlkvurh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, list := range list1 {\n        for i, num := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num.(int) * num2.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvbl7oi6o_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvbl7oi6o_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvbl7oi6o_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvbl7oi6o_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvbl7oi6o_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvbl7oi6o_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for _, num2 := range list[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbdxfd5x1_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbdxfd5x1_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbdxfd5x1_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbdxfd5x1_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbdxfd5x1_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbdxfd5x1_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        if list1[i][j].(int) * list1[k][l].(int) > max {\n                            max = list1[i][j].(int) * list1[k][l].(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq6yypcyk_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq6yypcyk_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq6yypcyk_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq6yypcyk_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq6yypcyk_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq6yypcyk_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqdlkvurh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgz2vtseq_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgz2vtseq_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgz2vtseq_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgz2vtseq_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgz2vtseq_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgz2vtseq_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp82sw7629_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp82sw7629_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp82sw7629_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpod3uzyty_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                for _, i1 := range l1 {\n                    for _, i2 := range l2 {\n                        if i1 != i2 {\n                            if i1.(int) * i2.(int) > max {\n                                max = i1.(int) * i2.(int)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy04n4c70_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmpy04n4c70_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy04n4c70_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy04n4c70_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy04n4c70_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy04n4c70_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy04n4c70_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1[i]); k++ {\n                if j != k {\n                    if list1[i][j].(int) * list1[i][k].(int) > max {\n                        max = list1[i][j].(int) * list1[i][k].(int)\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjg1umlbb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjg1umlbb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjg1umlbb_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjg1umlbb_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjg1umlbb_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjg1umlbb_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product := list[i].(int) * list[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfv36gxsn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfv36gxsn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfv36gxsn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfv36gxsn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfv36gxsn_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfv36gxsn_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppvu_1wwz_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvu_1wwz_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvu_1wwz_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvu_1wwz_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvu_1wwz_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvu_1wwz_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, sublist := range list1 {\n        for i, num1 := range sublist {\n            for _, num2 := range sublist[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdq_vsfgl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdq_vsfgl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdq_vsfgl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdq_vsfgl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdq_vsfgl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdq_vsfgl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max_product {\n                max_product = list3.(int)\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj8deggkr_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj8deggkr_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj8deggkr_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj8deggkr_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj8deggkr_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj8deggkr_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if tuple[0].(int) * tuple[1].(int) > max {\n            max = tuple[0].(int) * tuple[1].(int)\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9fhfjwyq_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9fhfjwyq_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9fhfjwyq_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9fhfjwyq_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9fhfjwyq_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9fhfjwyq_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn3duormo_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn3duormo_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn3duormo_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn3duormo_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn3duormo_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn3duormo_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3o2xz5h_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc6qh7f3h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7jt2uh1r_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jt2uh1r_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jt2uh1r_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5fwpika_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5fwpika_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5fwpika_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product := list[i].(int) * list[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc04r_hoj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc04r_hoj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc04r_hoj_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num := range list {\n            for j, num2 := range list {\n                if i == j {\n                    continue\n                }\n                product := num.(int) * num2.(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ra2ez9j_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ra2ez9j_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ra2ez9j_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ra2ez9j_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ra2ez9j_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ra2ez9j_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, v1 := range list1 {\n        for _, v2 := range list1 {\n            if v1 != v2 {\n                product := v1[0].(int) * v2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbmaehjag_test.go:13:19: invalid operation: v1 != v2 (slice can only be compared to nil)\n/tmp/tmpbmaehjag_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbmaehjag_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbmaehjag_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbmaehjag_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbmaehjag_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbmaehjag_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := tuple1[0].(int) * tuple2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptxtkctvc_test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmptxtkctvc_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptxtkctvc_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptxtkctvc_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptxtkctvc_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptxtkctvc_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptxtkctvc_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                product := l1[0].(int) * l2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqedhq01f_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmpqedhq01f_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqedhq01f_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqedhq01f_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqedhq01f_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqedhq01f_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqedhq01f_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for _, tuple := range list1 {\n        var product int\n        for _, num := range tuple {\n            product += num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptuhn8bbh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptuhn8bbh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptuhn8bbh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptuhn8bbh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptuhn8bbh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptuhn8bbh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i == j {\n                    continue\n                }\n                product := num1.(int) * num2.(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4tjob8g9_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4tjob8g9_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4tjob8g9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4tjob8g9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4tjob8g9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4tjob8g9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        var product int = list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbhd4uvq7_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbhd4uvq7_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbhd4uvq7_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbhd4uvq7_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbhd4uvq7_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbhd4uvq7_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list2 := range list1 {\n        for _, num1 := range list2 {\n            for _, list3 := range list1 {\n                for _, num2 := range list3 {\n                    if num1 != num2 {\n                        product := num1.(int) * num2.(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp52zp7og0_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp52zp7og0_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp52zp7og0_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp52zp7og0_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp52zp7og0_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp52zp7og0_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplna5_gm2_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, sublist := range list1 {\n        for i, value := range sublist {\n            for j, value2 := range sublist {\n                if i != j {\n                    product := value.(int) * value2.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps31oa6k5_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmps31oa6k5_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps31oa6k5_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmps31oa6k5_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps31oa6k5_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmps31oa6k5_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc6qh7f3h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqdlkvurh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, v := range list1 {\n        if len(v) == 2 {\n            if v[0].(int) * v[1].(int) > max {\n                max = v[0].(int) * v[1].(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdoht7qch_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdoht7qch_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdoht7qch_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdoht7qch_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdoht7qch_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdoht7qch_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqdlkvurh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3ix65n4__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3ix65n4__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3ix65n4__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3ix65n4__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3ix65n4__test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3ix65n4__test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp82sw7629_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp82sw7629_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp82sw7629_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, tuple := range list1 {\n        var product int = 1\n        for _, number := range tuple {\n            product *= number.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7bv4ivnh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7bv4ivnh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7bv4ivnh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7bv4ivnh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7bv4ivnh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7bv4ivnh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, t1 := range list1 {\n        for _, t2 := range list1 {\n            if t1 != t2 {\n                product := t1[0].(int) * t1[1].(int) * t2[0].(int) * t2[1].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_fqtvj3_test.go:13:19: invalid operation: t1 != t2 (slice can only be compared to nil)\n/tmp/tmp0_fqtvj3_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0_fqtvj3_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0_fqtvj3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0_fqtvj3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0_fqtvj3_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0_fqtvj3_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num := range list {\n            for j := i + 1; j < len(list); j++ {\n                product := num.(int) * list[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoi8b1q9e_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpoi8b1q9e_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoi8b1q9e_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpoi8b1q9e_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoi8b1q9e_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpoi8b1q9e_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3ix65n4__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3ix65n4__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3ix65n4__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3ix65n4__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3ix65n4__test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3ix65n4__test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                for _, v1 := range l1 {\n                    for _, v2 := range l2 {\n                        if v1 != v2 {\n                            if v1.(int) * v2.(int) > max {\n                                max = v1.(int) * v2.(int)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdv011emd_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmpdv011emd_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdv011emd_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdv011emd_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdv011emd_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdv011emd_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdv011emd_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp398natxz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp398natxz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp398natxz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp398natxz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp398natxz_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp398natxz_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplna5_gm2_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, tuple := range list1 {\n        var product int = 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfk5mct8d_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfk5mct8d_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfk5mct8d_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfk5mct8d_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfk5mct8d_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfk5mct8d_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                product := l1[0].(int) * l2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpponl88it_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmpponl88it_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpponl88it_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpponl88it_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, val := range tuple {\n            product *= val.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5bw5s15i_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5bw5s15i_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5bw5s15i_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5bw5s15i_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5bw5s15i_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5bw5s15i_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := 1\n                for i := 0; i < len(tuple1); i++ {\n                    product *= tuple1[i].(int) * tuple2[i].(int)\n                }\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4b27_0c_test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmpk4b27_0c_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk4b27_0c_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk4b27_0c_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk4b27_0c_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk4b27_0c_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk4b27_0c_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        prod := list1[i][j].(int) * list1[k][l].(int)\n                        if prod > max {\n                            max = prod\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpclb2bsmr_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpclb2bsmr_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpclb2bsmr_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpclb2bsmr_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpclb2bsmr_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpclb2bsmr_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvjn25ohi_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvjn25ohi_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvjn25ohi_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list1 {\n            if list2 != list3 {\n                for _, value1 := range list2 {\n                    for _, value2 := range list3 {\n                        if value1 != value2 {\n                            product := value1.(int) * value2.(int)\n                            if product > max {\n                                max = product\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdy_e00gl_test.go:13:22: invalid operation: list2 != list3 (slice can only be compared to nil)\n/tmp/tmpdy_e00gl_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdy_e00gl_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdy_e00gl_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdy_e00gl_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdy_e00gl_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdy_e00gl_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := 1\n                for _, item := range tuple1 {\n                    product *= item.(int)\n                }\n                for _, item := range tuple2 {\n                    product *= item.(int)\n                }\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwgut2r6g_test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmpwgut2r6g_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwgut2r6g_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwgut2r6g_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwgut2r6g_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwgut2r6g_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwgut2r6g_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := tuple1[0].(int) * tuple2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm0km0213_test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmpm0km0213_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm0km0213_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm0km0213_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm0km0213_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm0km0213_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm0km0213_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        prod := 1\n        for _, num := range tuple {\n            prod *= num.(int)\n        }\n        if prod > max {\n            max = prod\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp06dt01yu_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp06dt01yu_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp06dt01yu_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp06dt01yu_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp06dt01yu_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp06dt01yu_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgz2vtseq_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgz2vtseq_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgz2vtseq_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgz2vtseq_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgz2vtseq_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgz2vtseq_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplna5_gm2_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnn9wxmwa_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnn9wxmwa_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnn9wxmwa_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnn9wxmwa_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnn9wxmwa_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnn9wxmwa_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, v := range list1 {\n        if len(v) != 2 {\n            continue\n        }\n        var product int = 1\n        for _, v2 := range v {\n            product *= v2.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpff23j_c2_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpff23j_c2_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpff23j_c2_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpff23j_c2_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpff23j_c2_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpff23j_c2_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l := range list1 {\n        for _, l2 := range list1 {\n            if l != l2 {\n                for _, num := range l {\n                    for _, num2 := range l2 {\n                        if num.(int) * num2.(int) > max {\n                            max = num.(int) * num2.(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpidsbh14z_test.go:13:18: invalid operation: l != l2 (slice can only be compared to nil)\n/tmp/tmpidsbh14z_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpidsbh14z_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpidsbh14z_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpidsbh14z_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpidsbh14z_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpidsbh14z_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product := list[i].(int) * list[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc04r_hoj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc04r_hoj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc04r_hoj_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i+1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpausr2523_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpausr2523_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpausr2523_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpausr2523_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpausr2523_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpausr2523_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := 1\n                for i := 0; i < len(tuple1); i++ {\n                    product *= tuple1[i].(int) * tuple2[i].(int)\n                }\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw_xj25n__test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmpw_xj25n__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw_xj25n__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpw_xj25n__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw_xj25n__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpw_xj25n__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw_xj25n__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqdlkvurh_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqdlkvurh_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqdlkvurh_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product := list[i].(int) * list[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfv36gxsn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfv36gxsn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfv36gxsn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfv36gxsn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfv36gxsn_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfv36gxsn_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, tuple := range list1 {\n        var product int = 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphu_adqfw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphu_adqfw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphu_adqfw_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphu_adqfw_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphu_adqfw_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphu_adqfw_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        if list1[i][j].(int) * list1[k][l].(int) > max {\n                            max = list1[i][j].(int) * list1[k][l].(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdm5dqodz_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdm5dqodz_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdm5dqodz_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdm5dqodz_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdm5dqodz_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdm5dqodz_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3o2xz5h_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product := list[i].(int) * list[j].(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5nxmqs8r_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5nxmqs8r_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5nxmqs8r_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5nxmqs8r_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5nxmqs8r_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5nxmqs8r_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpod3uzyty_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, pair := range list1 {\n        if pair[0].(int) * pair[1].(int) > max {\n            max = pair[0].(int) * pair[1].(int)\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpblmj6h8i_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpblmj6h8i_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpblmj6h8i_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpblmj6h8i_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpblmj6h8i_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpblmj6h8i_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, pair := range list1 {\n        product := pair[0].(int) * pair[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgr4v3rri_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgr4v3rri_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgr4v3rri_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgr4v3rri_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgr4v3rri_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgr4v3rri_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpivtdf1pf_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivtdf1pf_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivtdf1pf_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivtdf1pf_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivtdf1pf_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivtdf1pf_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, list2 := range list1 {\n        for _, i := range list2 {\n            for _, j := range list2 {\n                if i != j {\n                    product := i.(int) * j.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpht6guzqp_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpht6guzqp_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpht6guzqp_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpht6guzqp_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpht6guzqp_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpht6guzqp_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, item := range tuple {\n            product *= item.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbhhere80_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbhhere80_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbhhere80_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbhhere80_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbhhere80_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbhhere80_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn3duormo_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn3duormo_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn3duormo_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn3duormo_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn3duormo_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn3duormo_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l := range list1 {\n        for _, i := range l {\n            for _, j := range l {\n                if i != j {\n                    product := i.(int) * j.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj50xofxl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj50xofxl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj50xofxl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj50xofxl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj50xofxl_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj50xofxl_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list2 := range list1 {\n        for _, list3 := range list1 {\n            if list2 != list3 {\n                for _, num1 := range list2 {\n                    for _, num2 := range list3 {\n                        if num1.(int) * num2.(int) > max {\n                            max = num1.(int) * num2.(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbiuzpnpm_test.go:13:22: invalid operation: list2 != list3 (slice can only be compared to nil)\n/tmp/tmpbiuzpnpm_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbiuzpnpm_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbiuzpnpm_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbiuzpnpm_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbiuzpnpm_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbiuzpnpm_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for _, list2 := range list1 {\n        for _, num1 := range list2 {\n            for _, list3 := range list1 {\n                for _, num2 := range list3 {\n                    if num1 != num2 {\n                        product := num1.(int) * num2.(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgj_o83m6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgj_o83m6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgj_o83m6_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgj_o83m6_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgj_o83m6_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgj_o83m6_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, tuple := range list1 {\n        var product int = 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphu_adqfw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphu_adqfw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphu_adqfw_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphu_adqfw_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphu_adqfw_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphu_adqfw_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, tuple := range list1 {\n        var product int = 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfk5mct8d_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfk5mct8d_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfk5mct8d_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfk5mct8d_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfk5mct8d_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfk5mct8d_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, number := range tuple {\n            product *= number.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp92czr76l_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp92czr76l_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp92czr76l_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp92czr76l_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp92czr76l_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp92czr76l_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpod3uzyty_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                product := l1[0].(int) * l2[1].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6u2bxonj_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmp6u2bxonj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6u2bxonj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6u2bxonj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6u2bxonj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6u2bxonj_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6u2bxonj_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := tuple1[0].(int) * tuple2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptxtkctvc_test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmptxtkctvc_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptxtkctvc_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptxtkctvc_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptxtkctvc_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptxtkctvc_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptxtkctvc_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, sublist := range list1 {\n        for i, num1 := range sublist {\n            for _, num2 := range sublist[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnwyu7j6q_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnwyu7j6q_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnwyu7j6q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnwyu7j6q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnwyu7j6q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnwyu7j6q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            for _, list4 := range list3.([]interface{}) {\n                for _, list5 := range list4.([]interface{}) {\n                    for _, list6 := range list5.([]interface{}) {\n                        for _, list7 := range list6.([]interface{}) {\n                            for _, list8 := range list7.([]interface{}) {\n                                for _, list9 := range list8.([]interface{}) {\n                                    for _, list10 := range list9.([]interface{}) {\n                                        for _, list11 := range list10.([]interface{}) {\n                                            for _, list12 := range list11.([]interface{}) {\n                                                for _, list13 := range list12.([]interface{}) {\n                                                    for _, list14 := range list13.([]interface{}) {\n                                                        for _, list15 := range list14.([]interface{}) {\n                                                            for _, list16 := range list15.([]interface{}) {\n                                                                for _, list17 := range list16.([]interface{}) {\n                                                                    for _, list18 := range list17.([]interface{}) {\n                                                                        for _, list19 := range list18.([]interface{}) {\n                                                                            for _, list20 := range list19.([]interface{}) {\n                                                                                for _, list21 := range list20.([]interface{}) {\n                                                                                    for _, list22 := range list21.([]interface{}) {\n                                                                                        for _, list23 := range list22.([]interface{}) {\n                                                                                            for _, list24 := range list23.([]interface{}) {\n                                                                                                for _, list25 := range list24.([]interface{}) {\n                                                                                                    for _, list26 := range list25.([]interface{}) {\n                                                                                                        for _, list27 := range list26.([]interface{}) {\n                                                                                                            for _, list28\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsh0gha75_test.go:37:113: expected 1 expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        if tuple[0].(int) * tuple[1].(int) > max {\n            max = tuple[0].(int) * tuple[1].(int)\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0o0sx44j_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0o0sx44j_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0o0sx44j_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0o0sx44j_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0o0sx44j_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0o0sx44j_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    if num1.(int) * num2.(int) > max {\n                        max = num1.(int) * num2.(int)\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpt8v22d_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfpt8v22d_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfpt8v22d_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfpt8v22d_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfpt8v22d_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfpt8v22d_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list := range list1 {\n        for i, val1 := range list {\n            for j, val2 := range list {\n                if i != j {\n                    product := val1.(int) * val2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvu9w0qd0_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvu9w0qd0_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvu9w0qd0_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvu9w0qd0_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvu9w0qd0_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvu9w0qd0_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5fwpika_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5fwpika_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5fwpika_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        if list1[i][j].(int) * list1[k][l].(int) > max {\n                            max = list1[i][j].(int) * list1[k][l].(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmfpfvgrh_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmfpfvgrh_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmfpfvgrh_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmfpfvgrh_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmfpfvgrh_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmfpfvgrh_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                if list[i].(int) * list[j].(int) > max {\n                    max = list[i].(int) * list[j].(int)\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplna5_gm2_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplna5_gm2_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplna5_gm2_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, pair := range list1 {\n        var product int = pair[0].(int) * pair[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqw910d6q_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqw910d6q_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw910d6q_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqw910d6q_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw910d6q_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqw910d6q_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            return -1\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo8ik87tv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo8ik87tv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo8ik87tv_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo8ik87tv_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo8ik87tv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo8ik87tv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for _, num2 := range list[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4nfm_sfl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4nfm_sfl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4nfm_sfl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, v := range list1 {\n        if len(v) != 2 {\n            panic(\"List must contain only pairs\")\n        }\n        if v[0].(int) * v[1].(int) > max {\n            max = v[0].(int) * v[1].(int)\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpafoaqzyz_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafoaqzyz_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpafoaqzyz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafoaqzyz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpafoaqzyz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafoaqzyz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprld__w8c_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprld__w8c_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprld__w8c_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, sublist := range list1 {\n        for i := 0; i < len(sublist); i++ {\n            for j := i + 1; j < len(sublist); j++ {\n                product := sublist[i].(int) * sublist[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprpoyorz4_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprpoyorz4_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprpoyorz4_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprpoyorz4_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprpoyorz4_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprpoyorz4_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, v1 := range list1 {\n        for _, v2 := range list1 {\n            if v1 != v2 {\n                product := v1[0].(int) * v2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwkec29tr_test.go:13:19: invalid operation: v1 != v2 (slice can only be compared to nil)\n/tmp/tmpwkec29tr_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwkec29tr_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwkec29tr_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwkec29tr_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwkec29tr_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwkec29tr_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7jt2uh1r_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jt2uh1r_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jt2uh1r_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max_product {\n                max_product = list3.(int)\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj8deggkr_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj8deggkr_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj8deggkr_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj8deggkr_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj8deggkr_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj8deggkr_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product := list[i].(int) * list[j].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc04r_hoj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc04r_hoj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc04r_hoj_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc04r_hoj_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, val1 := range list {\n            for j, val2 := range list {\n                if i != j {\n                    product := val1.(int) * val2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124162,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmojve3nq_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmojve3nq_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmojve3nq_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmojve3nq_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmojve3nq_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmojve3nq_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzsxg2z6_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfzsxg2z6_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzsxg2z6_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfzsxg2z6_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzsxg2z6_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfzsxg2z6_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvjn25ohi_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvjn25ohi_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvjn25ohi_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, num1 := range list2 {\n            for _, list3 := range list1 {\n                for _, num2 := range list3 {\n                    if num1 != num2 {\n                        product := num1.(int) * num2.(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_9wwmx2b_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_9wwmx2b_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_9wwmx2b_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_9wwmx2b_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_9wwmx2b_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_9wwmx2b_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max_product {\n                        max_product = product\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvjn25ohi_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvjn25ohi_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvjn25ohi_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvjn25ohi_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i == j {\n                    continue\n                }\n                product := num1.(int) * num2.(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4tjob8g9_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4tjob8g9_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4tjob8g9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4tjob8g9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4tjob8g9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4tjob8g9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int = 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp82sw7629_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp82sw7629_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp82sw7629_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp82sw7629_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqb96jfx7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqb96jfx7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqb96jfx7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        v1 := tuple[0].(int)\n        v2 := tuple[1].(int)\n        product := v1 * v2\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5iqqx9f4_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5iqqx9f4_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5iqqx9f4_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5iqqx9f4_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5iqqx9f4_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5iqqx9f4_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for _, num2 := range list[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4nfm_sfl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4nfm_sfl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4nfm_sfl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                var product int = list[i].(int) * list[j].(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1gid5803_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1gid5803_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1gid5803_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1gid5803_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1gid5803_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1gid5803_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5fwpika_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5fwpika_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5fwpika_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5fwpika_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3o2xz5h_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max_product {\n                max_product = list3.(int)\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpav76wmxy_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpav76wmxy_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpav76wmxy_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpav76wmxy_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpav76wmxy_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpav76wmxy_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobcgeaob_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpobcgeaob_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpobcgeaob_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                product := l1[0].(int) * l2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpponl88it_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmpponl88it_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpponl88it_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpponl88it_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            return -1\n        }\n        product := tuple[0].(int) * tuple[1].(int)\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo8ik87tv_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo8ik87tv_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo8ik87tv_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo8ik87tv_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo8ik87tv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo8ik87tv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, tuple := range list1 {\n        if tuple[0].(int) * tuple[1].(int) > max {\n            max = tuple[0].(int) * tuple[1].(int)\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjfgkxjbl_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjfgkxjbl_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjfgkxjbl_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjfgkxjbl_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjfgkxjbl_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjfgkxjbl_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprld__w8c_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprld__w8c_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprld__w8c_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        if list1[i][j].(int) * list1[k][l].(int) > max {\n                            max = list1[i][j].(int) * list1[k][l].(int)\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq6yypcyk_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq6yypcyk_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq6yypcyk_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq6yypcyk_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq6yypcyk_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq6yypcyk_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3o2xz5h_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu3o2xz5h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu3o2xz5h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124156,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7jt2uh1r_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jt2uh1r_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jt2uh1r_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jt2uh1r_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    var product int = 0\n    for _, list := range list1 {\n        for i := 0; i < len(list); i++ {\n            for j := i + 1; j < len(list); j++ {\n                product = list[i].(int) * list[j].(int)\n                if product > max_product {\n                    max_product = product\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqausu5v9_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqausu5v9_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqausu5v9_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqausu5v9_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqausu5v9_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqausu5v9_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpod3uzyty_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpod3uzyty_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpod3uzyty_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, val := range tuple {\n            product *= val.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5bw5s15i_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5bw5s15i_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5bw5s15i_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5bw5s15i_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5bw5s15i_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5bw5s15i_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            if list1[i][j].(int) > max {\n                max = list1[i][j].(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpydwf0ql7_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpydwf0ql7_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpydwf0ql7_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpydwf0ql7_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpydwf0ql7_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpydwf0ql7_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int = 0\n    for _, tuple := range list1 {\n        var product int = 1\n        for _, value := range tuple {\n            product *= value.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiw850krp_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiw850krp_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiw850krp_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiw850krp_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiw850krp_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiw850krp_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for _, num2 := range list[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbdxfd5x1_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbdxfd5x1_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbdxfd5x1_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbdxfd5x1_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbdxfd5x1_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbdxfd5x1_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max_product {\n                            max_product = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprld__w8c_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprld__w8c_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprld__w8c_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprld__w8c_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple1 := range list1 {\n        for _, tuple2 := range list1 {\n            if tuple1 != tuple2 {\n                product := 1\n                for i := 0; i < len(tuple1); i++ {\n                    product *= tuple1[i].(int) * tuple2[i].(int)\n                }\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4b27_0c_test.go:13:23: invalid operation: tuple1 != tuple2 (slice can only be compared to nil)\n/tmp/tmpk4b27_0c_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk4b27_0c_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk4b27_0c_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk4b27_0c_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk4b27_0c_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk4b27_0c_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, x := range list1 {\n        for _, y := range list1 {\n            if x != y {\n                product := 1\n                for _, z := range x {\n                    for _, w := range y {\n                        if z != w {\n                            product *= z.(int) * w.(int)\n                        }\n                    }\n                }\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprwq55imo_test.go:13:18: invalid operation: x != y (slice can only be compared to nil)\n/tmp/tmprwq55imo_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprwq55imo_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprwq55imo_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprwq55imo_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprwq55imo_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprwq55imo_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for _, num2 := range list[i+1:] {\n                product := num1.(int) * num2.(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4nfm_sfl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4nfm_sfl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4nfm_sfl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4nfm_sfl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max {\n            max = product\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_zkb2c_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7_zkb2c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7_zkb2c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max_product int\n    for _, tuple := range list1 {\n        product := 1\n        for _, num := range tuple {\n            product *= num.(int)\n        }\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps7la7ph8_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmps7la7ph8_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps7la7ph8_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmps7la7ph8_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps7la7ph8_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmps7la7ph8_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for _, list2 := range list1 {\n        for _, list3 := range list2 {\n            if list3.(int) > max {\n                max = list3.(int)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln8zq1_v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln8zq1_v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln8zq1_v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, list := range list1 {\n        for i, num1 := range list {\n            for j, num2 := range list {\n                if i != j {\n                    product := num1.(int) * num2.(int)\n                    if product > max {\n                        max = product\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzlhc1mo6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzlhc1mo6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzlhc1mo6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                product := l1[0].(int) * l2[0].(int)\n                if product > max {\n                    max = product\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124159,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpponl88it_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmpponl88it_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpponl88it_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpponl88it_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpponl88it_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max_product := 0\n    for _, pair := range list1 {\n        product := pair[0].(int) * pair[1].(int)\n        if product > max_product {\n            max_product = product\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfer4yw0v_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfer4yw0v_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfer4yw0v_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfer4yw0v_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfer4yw0v_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfer4yw0v_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc6qh7f3h_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6qh7f3h_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6qh7f3h_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            for k := 0; k < len(list1); k++ {\n                for l := 0; l < len(list1[k]); l++ {\n                    if i != k && j != l {\n                        product := list1[i][j].(int) * list1[k][l].(int)\n                        if product > max {\n                            max = product\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510689,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5xuds9l_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5xuds9l_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5xuds9l_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, l1 := range list1 {\n        for _, l2 := range list1 {\n            if l1 != l2 {\n                for _, n1 := range l1 {\n                    for _, n2 := range l2 {\n                        if n1 != n2 {\n                            if n1.(int) * n2.(int) > max {\n                                max = n1.(int) * n2.(int)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124163,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0secae4c_test.go:13:19: invalid operation: l1 != l2 (slice can only be compared to nil)\n/tmp/tmp0secae4c_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0secae4c_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0secae4c_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0secae4c_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0secae4c_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0secae4c_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.\nfunc max_product_tuple(list1 [][]interface{}) int {\n    max := 0\n    for _, tuple := range list1 {\n        if len(tuple) != 2 {\n            continue\n        }\n        if tuple[0].(int) * tuple[1].(int) > max {\n            max = tuple[0].(int) * tuple[1].(int)\n        }\n    }\n    return max\n}\n\nfunc TestMax_Product_Tuple(t *testing.T) {\n  candidate := max_product_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },\n     { actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },\n     { actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124161,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0o0sx44j_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0o0sx44j_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0o0sx44j_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0o0sx44j_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0o0sx44j_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0o0sx44j_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}