{
  "name": "mbpp_457_Find_Min",
  "language": "go_test.go",
  "prompt": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py",
  "prompt_terminology": "reworded",
  "tests": "func TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(\"Not a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := lst[0]\n            for _, item := range lst {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_len := len(lst.([]interface{}))\n        min_lst := lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = Find_Min(v).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if v < min_string {\n                min_string = v\n            }\n        }\n        return min_string\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return []int{}\n        } else {\n            min_lst := lst_int[0]\n            for _, v := range lst_int {\n                if len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return []string{}\n        } else {\n            min_lst := lst_str[0]\n            for _, v := range lst_str {\n                if len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        if len(lst_lst) == 0 {\n            return lst\n        }\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst[1:] {\n            min_lst = Find_Min([]interface{}{min_lst, lst}).([]interface{})\n        }\n        return min_lst\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    default:\n        fmt.Println(\"Invalid type\")\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, l := range lst.([]interface{}) {\n            if l_len := len(l.([]interface{})); l_len < min_len {\n                min_len = l_len\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            } else {\n                min_lst := lst.([]interface{})[0]\n                for i := 1; i < lst_len; i++ {\n                    if len(lst.([]interface{})[i].([]interface{})) < len(min_lst.([]interface{})) {\n                        min_lst = lst.([]interface{})[i]\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n"
  ]
}