{
  "name": "mbpp_457_Find_Min",
  "language": "go_test.go",
  "prompt": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py",
  "prompt_terminology": "reworded",
  "tests": "func TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(\"Not a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := lst[0]\n            for _, item := range lst {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_len := len(lst.([]interface{}))\n        min_lst := lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = Find_Min(v).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if v < min_string {\n                min_string = v\n            }\n        }\n        return min_string\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return []int{}\n        } else {\n            min_lst := lst_int[0]\n            for _, v := range lst_int {\n                if len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return []string{}\n        } else {\n            min_lst := lst_str[0]\n            for _, v := range lst_str {\n                if len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        if len(lst_lst) == 0 {\n            return lst\n        }\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst[1:] {\n            min_lst = Find_Min([]interface{}{min_lst, lst}).([]interface{})\n        }\n        return min_lst\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    default:\n        fmt.Println(\"Invalid type\")\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, l := range lst.([]interface{}) {\n            if l_len := len(l.([]interface{})); l_len < min_len {\n                min_len = l_len\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            } else {\n                min_lst := lst.([]interface{})[0]\n                for i := 1; i < lst_len; i++ {\n                    if len(lst.([]interface{})[i].([]interface{})) < len(min_lst.([]interface{})) {\n                        min_lst = lst.([]interface{})[i]\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        } else if len(lst_) == 1 {\n            return lst_[0]\n        } else {\n            return Find_Min(lst_[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n",
    "    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, e := range lst.([]interface{}) {\n            if len(e.([]interface{})) < len(min.([]interface{})) {\n                min = e\n            }\n        }\n    }\n    return min\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            min := Find_Min(lst[0])\n            for _, v := range lst[1:] {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min.([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, e := range lst {\n            if len(e.([]interface{})) < len(min.([]interface{})) {\n                min = e\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, v := range lst_l {\n            min_l = Find_Min([]interface{}{min_l, v}).(interface{})\n        }\n        return min_l\n    case int:\n        return lst\n    case string:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{})[1:] {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    var min interface{}\n    var min_len int\n    switch lst.(type) {\n    case []int:\n        for _, v := range lst.([]int) {\n            if min_len == 0 || min_len > len(v) {\n                min = v\n                min_len = len(v)\n            }\n        }\n    case []string:\n        for _, v := range lst.([]string) {\n            if min_len == 0 || min_len > len(v) {\n                min = v\n                min_len = len(v)\n            }\n        }\n    case []float64:\n        for _, v := range lst.([]float64) {\n            if min_len == 0 || min_len > len(v) {\n                min = v\n                min_len = len(v)\n            }\n        }\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            }\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        } else {\n            min_ := lst_[0]\n            for _, v := range lst_[1:] {\n                if len(v.([]interface{})) < len(min_.([]interface{})) {\n                    min_ = v\n                }\n            }\n            return min_\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, i := range lst_int {\n            if i < min_int {\n                min_int = i\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, i := range lst_str {\n            if len(i) < len(min_str) {\n                min_str = i\n            }\n        }\n        return min_str\n    default:\n        return \"Invalid input type\"\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := Find_Min(lst[0]).([]interface{})\n            for _, item := range lst[1:] {\n                if len(Find_Min(item).([]interface{})) < len(min) {\n                    min = Find_Min(item).([]interface{})\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_len := len(lst.([]interface{}))\n        min_lst := lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(fmt.Sprintf(\"Find_Min: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, i := range lst {\n            if len(i.([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    default:\n        min = lst\n    }\n    return min\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            min := Find_Min(lst[0])\n            for _, v := range lst[1:] {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            } else if lst_len == 1 {\n                return lst.([]interface{})[0]\n            } else {\n                min_len := len(lst.([]interface{})[0].([]interface{}))\n                min_lst := lst.([]interface{})[0]\n                for _, item := range lst.([]interface{})[1:] {\n                    if len(item.([]interface{})) < min_len {\n                        min_len = len(item.([]interface{}))\n                        min_lst = item\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                } else {\n                    if len(v.([]interface{})) < len(min.([]interface{})) {\n                        min = v\n                    }\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if len(v) < len(min_str) {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := Find_Min(lst[0]).([]interface{})\n            for _, v := range lst[1:] {\n                if len(v.([]interface{})) < len(min) {\n                    min = v.([]interface{})\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := Find_Min(lst.([]interface{})[0])\n        for _, v := range lst.([]interface{})[1:] {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = Find_Min(v)\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        } else {\n            min := lst[0]\n            for _, e := range lst {\n                if len(e.([]interface{})) < len(min.([]interface{})) {\n                    min = e\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{})[1:] {\n                if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        if len(lst_l) == 0 {\n            return lst\n        } else {\n            min_l := lst_l[0]\n            for _, l := range lst_l {\n                if len(l.([]interface{})) < len(min_l.([]interface{})) {\n                    min_l = l\n                }\n            }\n            return min_l\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            } else {\n                return lst\n            }\n        case []int:\n            if len(lst.([]int)) == 0 {\n                return nil\n            } else {\n                return lst\n            }\n        case []string:\n            if len(lst.([]string)) == 0 {\n                return nil\n            } else {\n                return lst\n            }\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{}) != nil {\n                if len(min.([]interface{})) > len(v.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_len := len(lst.([]interface{})[0].([]interface{}))\n            min_lst := lst.([]interface{})[0]\n            for _, sublst := range lst.([]interface{})[1:] {\n                sublst_len := len(sublst.([]interface{}))\n                if sublst_len < min_len {\n                    min_len = sublst_len\n                    min_lst = sublst\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                min := Find_Min(lst.([]interface{})[0])\n                for _, v := range lst.([]interface{})[1:] {\n                    if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                        min = Find_Min(v)\n                    }\n                }\n                return min\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            sub_lst := lst.([]interface{})\n            min_lst := sub_lst[0]\n            for _, sub_lst := range sub_lst {\n                if len(Find_Min(sub_lst).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = sub_lst\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n",
    "    switch v := lst.(type) {\n    case []interface{}:\n        if len(v) == 0 {\n            return nil\n        }\n        min := v[0]\n        for _, item := range v {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                } else {\n                    if len(v.([]interface{})) < len(min.([]interface{})) {\n                        min = v\n                    }\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, i := range lst_int {\n            if i < min_int {\n                min_int = i\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, s := range lst_str {\n            if len(s) < len(min_str) {\n                min_str = s\n            }\n        }\n        return min_str\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min_len := len(lst.([]interface{})[0].([]interface{}))\n        min_lst := lst.([]interface{})[0]\n        for _, l := range lst.([]interface{}) {\n            if len(l.([]interface{})) < min_len {\n                min_len = len(l.([]interface{}))\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return []interface{}{}\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        case [][]interface{}:\n            if len(lst.([][]interface{})) == 0 {\n                return []interface{}{}\n            } else {\n                return Find_Min(lst.([][]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min_lst := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            } else {\n                min := lst.([]interface{})[0]\n                for _, v := range lst.([]interface{}) {\n                    if len(v.([]interface{})) < len(min.([]interface{})) {\n                        min = v\n                    }\n                }\n                return min\n            }\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_len := lst_len\n            min_lst := lst\n            for _, item := range lst.([]interface{}) {\n                if item_len := len(item.([]interface{})); item_len < min_len {\n                    min_len = item_len\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{})[1:] {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        for _, v := range lst.([]int) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        for _, v := range lst.([]string) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []float64:\n        var min_lst []float64\n        for _, v := range lst.([]float64) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, i := range lst.([]interface{}) {\n            if len(Find_Min(i).([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, e := range lst.([]interface{})[1:] {\n            if len(Find_Min(e).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = e\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, i := range lst_int {\n            if i < min_int {\n                min_int = i\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, s := range lst_str {\n            if s < min_str {\n                min_str = s\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, f := range lst_float {\n            if f < min_float {\n                min_float = f\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return lst\n        } else {\n            min_lst := lst_[0]\n            for _, v := range lst_ {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        } else {\n            min := lst[0]\n            for _, v := range lst {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min := lst_[0]\n        for _, e := range lst_[1:] {\n            if len(Find_Min(e).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = e\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []float64:\n            return Find_Min_float64(lst.([]float64))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min_len int = len(lst.([]interface{}))\n            var min_lst interface{} = lst\n            for _, v := range lst.([]interface{}) {\n                if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                    min_len = v_len\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        case int:\n            return lst\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, i := range lst.([]interface{}) {\n            if len(Find_Min(i).([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_lst = sub_lst\n                min_len = len(sub_lst.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := Find_Min(lst_[0])\n        for _, item := range lst_[1:] {\n            min_ = Min(min_, Find_Min(item))\n        }\n        return min_\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_l := lst.([]interface{})\n            if len(lst_l) == 0 {\n                return lst\n            } else {\n                min_lst := lst_l[0]\n                for _, sub_lst := range lst_l[1:] {\n                    if len(Find_Min(sub_lst).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                        min_lst = sub_lst\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        fmt.Println(\"Unsupported type.\")\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_lst = sub_lst\n                min_len = len(sub_lst.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min_len = len(item.([]interface{}))\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    // Your code here\n    return nil\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := lst_[0]\n        for _, v := range lst_[1:] {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_).([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    // Your code goes here\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return nil\n        }\n        min := lst_int[0]\n        for _, v := range lst_int {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return nil\n        }\n        min := lst_str[0]\n        for _, v := range lst_str {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst_lst := lst.([][]int)\n        if len(lst_lst) == 0 {\n            return nil\n        }\n        min := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min_sublist := lst[0]\n        for _, sublist := range lst[1:] {\n            if len(sublist.([]interface{})) < len(min_sublist.([]interface{})) {\n                min_sublist = sublist\n            }\n        }\n        return min_sublist\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, sub := range lst.([]interface{}) {\n            if len(sub.([]interface{})) < len(min.([]interface{})) {\n                min = sub\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            return Find_Min(lst[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min_len = len(item.([]interface{}))\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, i := range lst.([]interface{}) {\n            if len(i.([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len = len(lst.([]interface{}))\n        var min_lst = lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if v_lst, ok := v.([]interface{}); ok {\n                if v_len := len(v_lst); v_len < min_len {\n                    min_len = v_len\n                    min_lst = v_lst\n                }\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, elem := range lst {\n            if len(elem.([]interface{})) < len(min.([]interface{})) {\n                min = elem\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            return find_min_list(lst.([]interface{}))\n        case []int:\n            return find_min_list(lst.([]int))\n        case []string:\n            return find_min_list(lst.([]string))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return nil\n            } else if len(lst) == 1 {\n                return lst[0]\n            } else {\n                min := Find_Min(lst[0])\n                for i := 1; i < len(lst); i++ {\n                    if len(Find_Min(lst[i]).([]interface{})) < len(min.([]interface{})) {\n                        min = lst[i]\n                    }\n                }\n                return min\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_l := lst.([]interface{})\n            if len(lst_l) == 0 {\n                return lst\n            } else {\n                min_l := lst_l[0]\n                for _, l := range lst_l {\n                    min_l = Find_Min([]interface{}{min_l, l}).([]interface{})[0]\n                }\n                return min_l\n            }\n        case int:\n            return lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case [][]int:\n            return Find_Min_int_slice(lst.([][]int))\n        case [][]string:\n            return Find_Min_string_slice(lst.([][]string))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, item := range lst.([]interface{}) {\n            if min == nil {\n                min = item\n                min_len = len(item.([]interface{}))\n            } else {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            min := Find_Min(lst[0])\n            for _, v := range lst[1:] {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch v := lst.(type) {\n    case []interface{}:\n        min := v[0]\n        for _, x := range v {\n            if len(x.([]interface{})) < len(min.([]interface{})) {\n                min = x\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if len(v) < len(min_str) {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, sub := range lst.([]interface{}) {\n            if len(sub.([]interface{})) < len(min.([]interface{})) {\n                min = sub\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_len := lst_len\n            min_lst := lst\n            for _, sub_lst := range lst.([]interface{}) {\n                sub_lst_len := len(sub_lst.([]interface{}))\n                if sub_lst_len < min_len {\n                    min_len = sub_lst_len\n                    min_lst = sub_lst\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        min := l[0]\n        for _, v := range l {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, e := range lst.([]interface{}) {\n            if len(e.([]interface{})) < len(min.([]interface{})) {\n                min = e\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, item := range lst.([]interface{}) {\n            if min == nil {\n                min = item\n                min_len = len(item.([]interface{}))\n            } else {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return lst\n            } else {\n                min_lst := lst[0]\n                for _, l := range lst {\n                    if len(l.([]interface{})) < len(min_lst.([]interface{})) {\n                        min_lst = l\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_len := lst_len\n            min_lst := lst\n            for _, elem := range lst.([]interface{}) {\n                if elem_len := len(Find_Min(elem).([]interface{})); elem_len < min_len {\n                    min_len = elem_len\n                    min_lst = elem\n                }\n            }\n            return min_lst\n        }\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(min_lst.([]interface{})) > len(v.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_lst = sub_lst\n                min_len = len(sub_lst.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min_lst := lst[0]\n        for _, v := range lst {\n            min_lst = Find_Min([]interface{}{min_lst, v}).([]interface{})\n        }\n        return min_lst\n    case int:\n        return []interface{}{lst}\n    default:\n        panic(\"Invalid type\")\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for i := 1; i < lst_len; i++ {\n                if len(Find_Min(lst.([]interface{})[i]).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = lst.([]interface{})[i]\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                } else if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, elem := range lst_l {\n            min_l = Find_Min([]interface{}{min_l, elem}).([]interface{})\n        }\n        return min_l\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_len := len(lst.([]interface{}))\n        min_lst := lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v.([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            }\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{})[1:] {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        default:\n            return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            switch sub_lst.(type) {\n            case []interface{}:\n                if len(sub_lst.([]interface{})) < min_len {\n                    min_lst = sub_lst\n                    min_len = len(sub_lst.([]interface{}))\n                }\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []float64:\n        if len(lst.([]float64)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst.([]interface{})[0]\n        } else {\n            min_len := len(lst.([]interface{})[0].([]interface{}))\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{})[1:] {\n                if len(v.([]interface{})) < min_len {\n                    min_len = len(v.([]interface{}))\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    case int:\n        return []interface{}{}\n    default:\n        panic(\"Unknown type\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := len(lst[0])\n        for _, v := range lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        for _, v := range lst {\n            if len(v) == min {\n                return v\n            }\n        }\n        return nil\n    case [][]string:\n        lst := lst.([][]string)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := len(lst[0])\n        for _, v := range lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        for _, v := range lst {\n            if len(v) == min {\n                return v\n            }\n        }\n        return nil\n    case [][]float64:\n        lst := lst.([][]float64)\n       ",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return []int{}\n        }\n        min_lst := lst_int[0]\n        for _, item := range lst_int {\n            if len(item) < len(min_lst) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return []string{}\n        }\n        min_lst := lst_str[0]\n        for _, item := range lst_str {\n            if len(item) < len(min_lst) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{}\n        } else {\n            min := l[0]\n            for _, e := range l {\n                if len(e.([]interface{})) < len(min.([]interface{})) {\n                    min = e\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return lst.([]interface{})[0]\n        }\n    case [][]interface{}:\n        if len(lst.([][]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return lst.([][]interface{})[0]\n        }\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, v := range lst_l {\n            if len(v.([]interface{})) < len(min_l.([]interface{})) {\n                min_l = v\n            }\n        }\n        return min_l\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        case []int:\n            if len(lst.([]int)) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]int)[1:])\n            }\n        case []string:\n            if len(lst.([]string)) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]string)[1:])\n            }\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for i := 1; i < lst_len; i++ {\n            if len(Find_Min(lst.([]interface{})[i]).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = lst.([]interface{})[i]\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst_len = len(lst.([]interface{}))\n        var min_len = lst_len\n        var min_lst = lst\n        for i := 0; i < lst_len; i++ {\n            var sub_lst = Find_Min(lst.([]interface{})[i])\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min_lst := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n"
  ]
}