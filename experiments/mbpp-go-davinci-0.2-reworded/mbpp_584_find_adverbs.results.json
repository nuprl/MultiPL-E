{
  "name": "mbpp_584_find_adverbs",
  "language": "go_test.go",
  "prompt": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py",
  "prompt_terminology": "reworded",
  "tests": "func TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\n    var s3\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptqrszggu_test.go:99:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    var index int\n    var word string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var q\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv4hrs6ud_test.go:100:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 && text[i-1] == 'l' {\n                continue\n            }\n            if i > 0 && text[i-1] == ' ' {\n                index = i - 1\n            } else {\n                index = i\n            }\n            for j := index; j >= 0; j-- {\n                if text[j] == ' ' {\n                    result = text[j+1:i+2]\n                    found = true\n                    break\n                }\n            }\n            if !found {\n                result = text[:i+2]\n            }\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509985,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmptiibyayp_test.go:54: expected '0-7: Clearly', got 'Clearly'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmptiibyayp_test.go:54: expected '28-36: carefuly', got 'carefuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmptiibyayp_test.go:54: expected '18-25: quickly', got 'quickly'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var adverb string\n    var adverb_positions []int\n    var adverb_position int\n    var adverb_found bool\n    var adverb_length int\n    var text_length int\n    var i int\n\n    text_length = len(text)\n    adverb_found = false\n    for i = 0; i < text_length; i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb_found = true\n            adverb_position = i\n            adverb_length = 0\n            for text[i] != ' ' {\n                adverb_length++\n                i++\n            }\n            adverb = text[adverb_position-adverb_length:adverb_position+2]\n            adverbs = append(adverbs, adverb)\n            adverb_positions = append(adverb_positions, adverb_position-adverb_length)\n        }\n    }\n    if adverb_found {\n        return fmt.Sprintf(\"%v %v\", adverbs[0], adverb_positions[0])\n    } else {\n        return \"No adverbs found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\npanic: runtime error: index out of range [36] with length 36 [recovered]\n\tpanic: runtime error: index out of range [36] with length 36\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc00015e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc00015e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.find_adverbs(0x54c349, 0x24, 0xc00012c090, 0x7)\n\t/tmp/tmp8qkvzz_v_test.go:26 +0x3f8\ncommand-line-arguments_test.TestFind_Adverbs(0xc000102600)\n\t/tmp/tmp8qkvzz_v_test.go:50 +0x8b\ntesting.tRunner(0xc000102600, 0x54f288)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb_found bool\n    var adverb_start int\n    var adverb_end int\n    var adverb_length int\n    var adverb_index int\n    var adverb_count int\n    var adverb_positions string\n    var adverb_position int\n    var adverb_position_count int\n    var adverb_position_index int\n    var adverb_position_start int\n    var adverb_position_end int\n    var adverb_position_length int\n    var adverb_position_string string\n    var adverb_position_strings []string\n    var adverb_position_strings_index int\n    var adverb_position_strings_length int\n    var adverb_position_strings_string string\n    var adverb_position_strings_strings []string\n    var adverb_position_strings_strings_index int\n    var adverb_position_strings_strings_length int\n    var adverb_position_strings_strings_string string\n    var adverb_position_strings_strings_strings []string\n    var adverb_position_strings_strings_strings_index int\n    var adverb_position_strings_strings_strings_length int\n    var adverb_position_strings_strings_strings_string string\n    var adverb_position_strings_strings_strings_strings []string\n    var adverb_position_strings_strings_strings_strings_index int\n    var adverb_position_strings_strings_strings_strings_length int\n    var adverb_position_strings_strings_strings_strings_string string\n    var adverb_position_strings_strings_strings_strings_strings []string\n    var adverb_position_strings_strings_strings_strings_strings_index int\n    var adverb_position_strings_strings_strings_strings_strings_length int\n    var adverb_position_strings_strings_strings_strings_strings_string string\n    var adverb_position_strings_strings_strings_strings_strings_strings []string\n    var adverb_position_strings_strings_strings_strings_strings_strings_index int\n    var adverb_position_strings_strings_strings_strings_strings_strings_length int\n   \nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphv3f8q6d_test.go:49:6: expected '(', found TestFind_Adverbs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if found {\n                result = fmt.Sprintf(\"%s %d\", result, index)\n                found = false\n            }\n        } else if text[i] == 'l' {\n            if i < len(text) - 1 && text[i + 1] == 'y' {\n                if found {\n                    result = fmt.Sprintf(\"%s %d\", result, index)\n                } else {\n                    result = fmt.Sprintf(\"%s%d\", result, i)\n                    found = true\n                }\n            }\n        }\n        index++\n    }\n    if found {\n        result = fmt.Sprintf(\"%s %d\", result, index)\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp1q4k3rnc_test.go:52: expected '0-7: Clearly', got '5 8'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp1q4k3rnc_test.go:52: expected '28-36: carefuly', got '34 36'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp1q4k3rnc_test.go:52: expected '18-25: quickly', got '23 25'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            index = i\n            break\n        }\n    }\n    for i := index; i >= 0; i-- {\n        if text[i] == ' ' {\n            break\n        }\n        result = string(text[i]) + result\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpi7tko95o_test.go:42: expected '0-7: Clearly', got 'Clearl'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpi7tko95o_test.go:42: expected '28-36: carefuly', got 'careful'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpi7tko95o_test.go:42: expected '18-25: quickly', got 'quickl'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_found bool\n    var i int\n    var c byte\n\n    adverb_found = false\n    adverb = \"\"\n    adverb_pos = 0\n    adverb_end = 0\n    for i = 0; i < len(text); i++ {\n        c = text[i]\n        if c == ' ' || c == ',' {\n            if adverb_found {\n                adverb_end = i - 1\n                break\n            }\n            adverb = \"\"\n        } else if c == 'l' {\n            if adverb == \"y\" {\n                adverb_found = true\n                adverb_pos = i - 2\n            }\n            adverb = \"l\"\n        } else if c == 'y' {\n            if adverb == \"l\" {\n                adverb = \"ly\"\n            } else {\n                adverb = \"\"\n            }\n        } else {\n            adverb = \"\"\n        }\n    }\n    if adverb_found {\n        result = fmt.Sprintf(\"%s %d %d\", text[adverb_pos:adverb_end+1], adverb_pos, adverb_end)\n    } else {\n        result = \"Not found\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpawelpfsa_test.go:69: expected '0-7: Clearly', got 'Not found'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpawelpfsa_test.go:69: expected '28-36: carefuly', got 'Not found'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpawelpfsa_test.go:69: expected '18-25: quickly', got 'Not found'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == \"ly\" {\n            result = fmt.Sprintf(\"%d\", i)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw0h8g7na_test.go:12:17: cannot use \"ly\" (type untyped string) as type rune\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '0-7: Clearly', got 'arly 3'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '28-36: carefuly', got 'fuly 32'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '18-25: quickly', got 'ckly 21'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpeiahjtsn_test.go:100:6: expected '(', found TestFind_Adverbs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp22ciovd_test.go:101:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            pos = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp2vq0cwop_test.go:37: expected '0-7: Clearly', got 'early 5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp2vq0cwop_test.go:37: expected '28-36: carefuly', got 'efuly 34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp2vq0cwop_test.go:37: expected '18-25: quickly', got 'ickly 23'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var word string\n    var found bool\n    for _, char := range text {\n        if char == ' ' {\n            if len(word) > 2 && word[len(word)-2:] == \"ly\" {\n                result = word\n                found = true\n                break\n            }\n            word = \"\"\n        } else {\n            word += string(char)\n        }\n    }\n    if !found {\n        result = \"Not found\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp_ypd6dqy_test.go:46: expected '0-7: Clearly', got 'Not found'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp_ypd6dqy_test.go:46: expected '28-36: carefuly', got 'Not found'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp_ypd6dqy_test.go:46: expected '18-25: quickly', got 'Not found'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var position int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-3:i+2]\n            position = i-3\n            found = true\n            break\n        }\n    }\n    if found {\n        return fmt.Sprintf(\"%s %d\", adverb, position)\n    } else {\n        return \"Not found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmph5ub9s65_test.go:43: expected '0-7: Clearly', got 'early 2'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmph5ub9s65_test.go:43: expected '28-36: carefuly', got 'efuly 31'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmph5ub9s65_test.go:43: expected '18-25: quickly', got 'ickly 20'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == \"ly\" {\n            result = fmt.Sprintf(\"%s %d\", word, i)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy9obd_8b_test.go:12:17: cannot use \"ly\" (type untyped string) as type rune\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text) - 2; i++ {\n        if text[i:i+3] == \"ly \" {\n            result = text[i-1:i+3]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '28-36: carefuly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '18-25: quickly', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var result_positions string\n    var word string\n    var word_positions string\n    var word_length int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i_ int\n    var j_ int\n    var k_ int\n    var l_ int\n    var m_ int\n    var n_ int\n    var o_ int\n    var p_ int\n    var q_ int\n    var r_ int\n    var s_ int\n    var t_ int\n    var u_ int\n    var v_ int\n    var w_ int\n    var x_ int\n    var y_ int\n    var z_ int\n    var a_ int\n    var b_ int\n    var c_ int\n    var d_ int\n    var e_ int\n    var f_ int\n    var g_ int\n    var h_ int\n    var i__ int\n    var j__ int\n    var k__ int\n    var l__ int\n    var m__ int\n    var n__ int\n    var o__ int\n    var p__ int\n    var q__ int\n    var r__ int\n    var s__ int\n    var t__ int\n    var u__ int\n    var v__ int\n    var w__ int\n    var x__ int\n    var y__ int\n    var z__ int\n    var a__ int\n    var b__ int\n    var c__ int\n    var d__ int\n    var e__ int\n    var f__ int\n    var g__ int\n    var h__ int\n    var i___ int\n    var j___ int\n    var k___ int\n    var l___ int\n    var m___ int\n    var n___ int\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text) - 2; i++ {\n        if text[i] == 'l' && text[i + 1] == 'y' {\n            result = fmt.Sprintf(\"%s %d\", text[i - 4:i + 2], i - 4)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_found bool\n    var adverb_end_found bool\n    var adverb_end_pos int\n    var adverb_end_pos_found bool\n    var adverb_end_pos_end int\n    var adverb_end_pos_end_found bool\n    var adverb_end_pos_end_pos int\n    var adverb_end_pos_end_pos_found bool\n    var adverb_end_pos_end_pos_end int\n    var adverb_end_pos_end_pos_end_found bool\n    var adverb_end_pos_end_pos_end_pos int\n    var adverb_end_pos_end_pos_end_pos_found bool\n    var adverb_end_pos_end_pos_end_pos_end int\n    var adverb_end_pos_end_pos_end_pos_end_found bool\n    var adverb_end_pos_end_pos_end_pos_end_pos int\n    var adverb_end_pos_end_pos_end_pos_end_pos_found bool\n    var adverb_end_pos_end_pos_end_pos_end_pos_end int\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_found bool\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_pos int\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_pos_found bool\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_pos_end int\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_pos_end_found bool\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_pos_end_pos int\n    var adverb_end_pos_end_pos_end_pos_end_pos_end_pos_end_pos_found bool\n    var adverb\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            position = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'a' {\n            for j = i + 1; j < len(text); j++ {\n                if text[j] == 'd' {\n                    for k = j + 1; k < len(text); k++ {\n                        if text[k] == 'v' {\n                            for l = k + 1; l < len(text); l++ {\n                                if text[l] == 'e' {\n                                    for m = l + 1; m < len(text); m++ {\n                                        if text[m] == 'r' {\n                                            for n = m + 1; n < len(text); n++ {\n                                                if text[n] == 'b' {\n                                                    for o = n + 1; o < len(text); o++ {\n                                                        if text[o] == 's' {\n                                                            for p = o + 1; p < len(text); p++ {\n                                                                if text[p] == ' ' {\n                                                                    for q = p + 1; q < len(text); q++ {\n                                                                        if text[q] == 'e' {\n                                                                            for r = q + 1; r < len(text); r++ {\n                                                                                if text[r] == 'n' {\n                                                                                    for s = r + 1; s < len(text); s++ {\n                                                                                        if text[s] == 'd' {\n                                                                                            for t = s + 1; t < len(text); t++ {\n                                                                                                if text[t] == 'i' {\n                                                                                                    for u =\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var adverb string\n    var adverb_positions []int\n    var adverb_position int\n    var adverb_index int\n    var adverb_found bool\n    var adverb_length int\n    var text_length int\n    var text_index int\n    var text_char string\n    var text_char_code int\n\n    text_length = len(text)\n    adverb_found = false\n    adverb_length = 0\n    adverb_index = 0\n    adverb_position = 0\n    text_index = 0\n    for text_index < text_length {\n        text_char = string(text[text_index])\n        text_char_code = int(text[text_index])\n        if text_char_code >= 65 && text_char_code <= 90 {\n            text_char = string(text_char_code + 32)\n        }\n        if text_char == \" \" {\n            if adverb_found {\n                adverb_found = false\n                adverb_length = 0\n                adverb_index = 0\n                adverb_position = 0\n            }\n        } else {\n            if adverb_found {\n                if adverb_index == adverb_length - 1 {\n                    if text_char == \"y\" {\n                        adverbs = append(adverbs, adverb)\n                        adverb_positions = append(adverb_positions, adverb_position)\n                    }\n                    adverb_found = false\n                    adverb_length = 0\n                    adverb_index = 0\n                    adverb_position = 0\n                } else {\n                    adverb_index++\n                }\n            } else {\n                if text_char == \"l\" {\n                    adverb_found = true\n                    adverb_length = 2\n                    adverb_index = 1\n                    adverb_position = text_index - 1\n                    adverb = string(text[adverb_position])\n                }\n            }\n        }\n        text_index++\n    }\n    if len(adverbs) == 0 {\n        return \"No adverbs found.\"\n    } else {\n        return fmt.Sprintf(\"%v at %v\",\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            index = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, index)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 {\n                if text[i-1] == ' ' {\n                    index = i - 1\n                    found = true\n                }\n            } else {\n                index = i\n                found = true\n            }\n        }\n        if found {\n            for j := index; j >= 0; j-- {\n                if text[j] == ' ' {\n                    result = text[j+1:i+2]\n                    break\n                }\n            }\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            position = i\n            found = true\n            break\n        }\n    }\n    if found {\n        result = text[position-3:position+2]\n    } else {\n        result = \"Not found\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s %d\", text[i-3:i+2], i-3)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var adverb string\n    var adverb_positions []int\n    var adverb_position int\n    var adverb_found bool\n    var adverb_found_count int\n    var adverb_found_count_max int\n    var adverb_found_count_max_positions []int\n    var adverb_found_count_max_position int\n    var adverb_found_count_max_position_index int\n    var adverb_found_count_max_position_index_max int\n    var adverb_found_count_max_position_index_max_positions []int\n    var adverb_found_count_max_position_index_max_position int\n    var adverb_found_count_max_position_index_max_position_index int\n    var adverb_found_count_max_position_index_max_position_index_max int\n    var adverb_found_count_max_position_index_max_position_index_max_positions []int\n    var adverb_found_count_max_position_index_max_position_index_max_position int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index_max int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index_max_positions []int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index_max_position int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index_max_position_index int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index_max_position_index_max int\n    var adverb_found_count_max_position_index_max_position_index_max_position_index_max_position_index_max_positions []int\n    var adverb_found_count_max\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%s\", result, text[i-3:i+2])\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_positions []int\n    var adverb_position int\n    var adverb_found bool\n    var adverb_end_pos int\n    var adverb_end_pos_found bool\n    var adverb_end_pos_found_first bool\n    var adverb_end_pos_found_last bool\n    var adverb_end_pos_found_last_pos int\n    var adverb_end_pos_found_last_pos_found bool\n    var adverb_end_pos_found_last_pos_found_first bool\n    var adverb_end_pos_found_last_pos_found_last bool\n    var adverb_end_pos_found_last_pos_found_last_pos int\n    var adverb_end_pos_found_last_pos_found_last_pos_found bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_first bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos int\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos_found bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos_found_first bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos_found_last bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos_found_last_pos int\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos_found_last_pos_found bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found_last_pos_found_last_pos_found_first bool\n    var adverb_end_pos_found_last_pos_found_last_pos_found\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var last_index int\n    var word string\n    var last_word string\n    var last_word_length int\n    var last_word_last_char string\n    var last_word_last_char_length int\n\n    for i, char := range text {\n        if char == ' ' {\n            index = i\n            word = text[last_index:index]\n            last_word = word\n            last_index = index + 1\n        }\n    }\n    word = text[last_index:len(text)]\n    if word == last_word {\n        last_word = word\n    }\n\n    last_word_length = len(last_word)\n    last_word_last_char = string(last_word[last_word_length - 1])\n    last_word_last_char_length = len(last_word_last_char)\n\n    if last_word_last_char == \"y\" {\n        result = fmt.Sprintf(\"%s\", last_word)\n    } else {\n        result = fmt.Sprintf(\"%s\", last_word)\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if text[i-1] == 'y' && text[i-2] == 'l' && text[i-3] == 'y' {\n                result = fmt.Sprintf(\"%s %d\", text[i-4:i], i-4)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if found {\n                result = text[pos:i]\n                break\n            }\n        } else if text[i] == 'l' {\n            if i + 1 < len(text) && text[i + 1] == 'y' {\n                found = true\n                pos = i - 1\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_len int\n    var adverb_found bool\n    var adverb_end_found bool\n\n    adverb_found = false\n    adverb_end_found = false\n\n    for i, char := range text {\n        if char == 'l' {\n            adverb_pos = i\n            adverb_found = true\n        }\n        if adverb_found && char == 'y' {\n            adverb_end = i\n            adverb_end_found = true\n        }\n        if adverb_found && adverb_end_found {\n            adverb_len = adverb_end - adverb_pos + 1\n            adverb = text[adverb_pos:adverb_pos + adverb_len]\n            result = fmt.Sprintf(\"%s %d %d\", adverb, adverb_pos, adverb_end)\n            break\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var word string\n    var words []string\n    var adverbs []string\n    var adverb string\n    var adverb_index int\n\n    words = strings.Fields(text)\n    for i, word := range words {\n        if strings.HasSuffix(word, \"ly\") {\n            adverbs = append(adverbs, word)\n            adverb_index = i\n        }\n    }\n    adverb = adverbs[0]\n    result = fmt.Sprintf(\"%s %d\", adverb, adverb_index)\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var sss\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == 'l' && text[i+1] == 'y' {\n            result = text[i-1] + \"ly\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    return \"\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 && text[i-1] == 'l' {\n                continue\n            }\n            if i > 0 && text[i-1] == ' ' {\n                if i > 1 && text[i-2] == 'l' {\n                    continue\n                }\n                if i > 1 && text[i-2] == ' ' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '.' {\n                    continue\n                }\n                if i > 1 && text[i-2] == ',' {\n                    continue\n                }\n                if i > 1 && text[i-2] == ';' {\n                    continue\n                }\n                if i > 1 && text[i-2] == ':' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '!' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '?' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '-' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '(' {\n                    continue\n                }\n                if i > 1 && text[i-2] == ')' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '[' {\n                    continue\n                }\n                if i > 1 && text[i-2] == ']' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '{' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '}' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '\"' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '\\'' {\n                    continue\n                }\n                if i > 1 && text[i-2] == '`' {\n                    continue\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var sss\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_pos int\n    var adverb_found bool\n    var adverb_end_pos int\n    var adverb_end_found bool\n    var adverb_end_pos_found bool\n    var adverb_end_pos_found_first bool\n    var adverb_end_pos_found_second bool\n    var adverb_end_pos_found_third bool\n    var adverb_end_pos_found_fourth bool\n    var adverb_end_pos_found_fifth bool\n    var adverb_end_pos_found_sixth bool\n    var adverb_end_pos_found_seventh bool\n    var adverb_end_pos_found_eighth bool\n    var adverb_end_pos_found_ninth bool\n    var adverb_end_pos_found_tenth bool\n    var adverb_end_pos_found_eleventh bool\n    var adverb_end_pos_found_twelfth bool\n    var adverb_end_pos_found_thirteenth bool\n    var adverb_end_pos_found_fourteenth bool\n    var adverb_end_pos_found_fifteenth bool\n    var adverb_end_pos_found_sixteenth bool\n    var adverb_end_pos_found_seventeenth bool\n    var adverb_end_pos_found_eighteenth bool\n    var adverb_end_pos_found_nineteenth bool\n    var adverb_end_pos_found_twentieth bool\n    var adverb_end_pos_found_twentyfirst bool\n    var adverb_end_pos_found_twentysecond bool\n    var adverb_end_pos_found_twentythird bool\n    var adverb_end_pos_found_twentyfourth bool\n    var adverb_end_pos_found_twentyfifth bool\n    var adverb_end_pos_found_twentysixth bool\n    var adverb_end_pos_found_twentyseventh bool\n    var adverb_end_pos_found_twentyeighth bool\n    var adverb_end_pos_found_twentyninth bool\n    var adverb_end_pos_found\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions []int\n    var adverb_found bool\n    var adverb_start int\n    var adverb_end int\n    var adverb_length int\n    var adverb_index int\n\n    adverb_found = false\n    adverb_start = 0\n    adverb_end = 0\n    adverb_length = 0\n    adverb_index = 0\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if adverb_found {\n                adverb_end = i\n                adverb_length = adverb_end - adverb_start\n                adverb = text[adverb_start:adverb_end]\n                adverb_positions = append(adverb_positions, adverb_start)\n                adverb_positions = append(adverb_positions, adverb_end)\n                adverb_positions = append(adverb_positions, adverb_length)\n                adverb_found = false\n            }\n        } else if text[i] == 'l' {\n            if text[i+1] == 'y' {\n                adverb_found = true\n                adverb_start = i - 1\n            }\n        }\n    }\n\n    if adverb_found {\n        adverb_end = len(text)\n        adverb_length = adverb_end - adverb_start\n        adverb = text[adverb_start:adverb_end]\n        adverb_positions = append(adverb_positions, adverb_start)\n        adverb_positions = append(adverb_positions, adverb_end)\n        adverb_positions = append(adverb_positions, adverb_length)\n    }\n\n    if len(adverb_positions) == 0 {\n        return \"No adverbs found\"\n    }\n\n    return fmt.Sprintf(\"Adverb: %s\\nStart: %d\\nEnd: %d\\nLength: %d\", adverb, adverb_positions[adverb_index], adverb_positions[adverb_index+1], adverb_positions[adverb\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var positions []int\n    var result string\n\n    for i, word := range(strings.Split(text, \" \")) {\n        if len(word) > 2 && word[len(word)-2:] == \"ly\" {\n            adverbs = append(adverbs, word)\n            positions = append(positions, i)\n        }\n    }\n\n    if len(adverbs) > 0 {\n        result = fmt.Sprintf(\"%s %d\", adverbs[0], positions[0])\n    } else {\n        result = \"Not found\"\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp22ciovd_test.go:101:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-2:i+2]\n            break\n        }\n    }\n    return adverb\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb_found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 {\n                if text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 1 {\n                if text[i-2] == 'a' && text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 2 {\n                if text[i-3] == 'u' && text[i-2] == 'a' && text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 3 {\n                if text[i-4] == 'i' && text[i-3] == 'u' && text[i-2] == 'a' && text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 4 {\n                if text[i-5] == 'b' && text[i-4] == 'i' && text[i-3] == 'u' && text[i-2] == 'a' && text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 5 {\n                if text[i-6] == 'd' && text[i-5] == 'b' && text[i-4] == 'i' && text[i-3] == 'u' && text[i-2] == 'a' && text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 6 {\n                if text[i-7] == 'f' && text[i-6] == 'd' && text[i-5] == 'b' && text[i-4] == 'i' && text[i-3] == 'u' && text[i-2] == 'a' && text[i-1] == 'l' {\n                    continue\n                }\n            }\n            if i > 7 {\n                if text[i-8] == 'g\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            pos = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            pos = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 && text[i-1] == 'l' {\n                continue\n            }\n            if i > 0 && text[i-1] == ' ' {\n                pos = i - 1\n            } else {\n                pos = i\n            }\n            for j := i; j >= 0; j-- {\n                if text[j] == ' ' {\n                    result = text[j+1:i+2]\n                    found = true\n                    break\n                }\n            }\n            if found {\n                break\n            }\n        }\n    }\n    if found {\n        return fmt.Sprintf(\"%s %d\", result, pos)\n    }\n    return \"Not found\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var found bool\n    var i int\n    var j int\n\n    found = false\n    i = 0\n    for i < len(text) {\n        if text[i] == ' ' {\n            i++\n            continue\n        }\n        j = i\n        for j < len(text) && text[j] != ' ' {\n            j++\n        }\n        if j - i > 2 && text[j - 1] == 'y' && text[j - 2] == 'l' {\n            if !found {\n                adverb = text[i:j]\n                adverb_pos = i\n                adverb_end = j\n                found = true\n            }\n        }\n        i = j\n    }\n    if found {\n        return fmt.Sprintf(\"%s %d %d\", adverb, adverb_pos, adverb_end)\n    } else {\n        return \"Not found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 && text[i-1] == 'l' {\n                continue\n            }\n            if i > 0 && text[i-1] == ' ' {\n                if i > 1 && text[i-2] == ' ' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'l' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'e' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'a' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'i' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'o' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'u' {\n                    continue\n                }\n                if i > 1 && text[i-2] == 'y' {\n                    continue\n                }\n                if i > 2 && text[i-3] == ' ' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'l' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'e' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'a' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'i' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'o' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'u' {\n                    continue\n                }\n                if i > 2 && text[i-3] == 'y' {\n                    continue\n                }\n                if i > 3 && text[i-4] == ' ' {\n                    continue\n                }\n                if i > 3 && text[i-4\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if len(adverb) > 2 && adverb[len(adverb)-2:] == \"ly\" {\n                result = fmt.Sprintf(\"%s%s %d \", result, adverb, position)\n            }\n            adverb = \"\"\n            position = 0\n        } else {\n            adverb += string(text[i])\n            position++\n        }\n    }\n    if len(adverb) > 2 && adverb[len(adverb)-2:] == \"ly\" {\n        result = fmt.Sprintf(\"%s%s %d\", result, adverb, position)\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text) - 2; i++ {\n        if text[i:i+3] == \"ly \" {\n            result = text[i+3:]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var found bool\n    var i int\n    var j int\n    var k int\n\n    for i = 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if found {\n                result += fmt.Sprintf(\"%s: %d, %d\\n\", adverb, j, k)\n                found = false\n            }\n            j = i + 1\n        } else if text[i] == 'l' {\n            if i + 1 < len(text) && text[i + 1] == 'y' {\n                found = true\n                adverb = text[j:i + 2]\n                k = i + 2\n            }\n        }\n    }\n\n    if found {\n        result += fmt.Sprintf(\"%s: %d, %d\\n\", adverb, j, k)\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var word string\n    var last_letter string\n    var first_letter string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '0-7: Clearly', got 'arly 3'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '28-36: carefuly', got 'fuly 32'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '18-25: quickly', got 'ckly 21'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var word string\n    var word_length int\n\n    found = false\n    i = 0\n    j = 0\n    word_length = 0\n    for i < len(text) {\n        if text[i] == ' ' {\n            word = text[j:i]\n            word_length = len(word)\n            if word_length > 2 && word[word_length - 2:] == \"ly\" {\n                result = word\n                found = true\n                break\n            }\n            j = i + 1\n        }\n        i++\n    }\n    if !found {\n        result = \"Not found\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs string\n    var positions string\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverbs += text[i-1:i+2] + \" \"\n            positions += fmt.Sprintf(\"%d \", i-1)\n        }\n    }\n\n    return adverbs + \"(\" + positions + \")\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_positions string\n    var adverb_found bool\n    var adverb_start int\n    var adverb_end int\n    var adverb_length int\n    var adverb_count int\n    var i int\n    var j int\n    var k int\n    var c byte\n    var c1 byte\n    var c2 byte\n    var c3 byte\n    var c4 byte\n    var c5 byte\n    var c6 byte\n    var c7 byte\n    var c8 byte\n    var c9 byte\n    var c10 byte\n    var c11 byte\n    var c12 byte\n    var c13 byte\n    var c14 byte\n    var c15 byte\n    var c16 byte\n    var c17 byte\n    var c18 byte\n    var c19 byte\n    var c20 byte\n    var c21 byte\n    var c22 byte\n    var c23 byte\n    var c24 byte\n    var c25 byte\n    var c26 byte\n    var c27 byte\n    var c28 byte\n    var c29 byte\n    var c30 byte\n    var c31 byte\n    var c32 byte\n    var c33 byte\n    var c34 byte\n    var c35 byte\n    var c36 byte\n    var c37 byte\n    var c38 byte\n    var c39 byte\n    var c40 byte\n    var c41 byte\n    var c42 byte\n    var c43 byte\n    var c44 byte\n    var c45 byte\n    var c46 byte\n    var c47 byte\n    var c48 byte\n    var c49 byte\n    var c50 byte\n    var c51 byte\n    var c52 byte\n    var c53 byte\n    var c54 byte\n    var c55 byte\n    var c56 byte\n    var c57 byte\n    var c58 byte\n    var c59 byte\n    var c60 byte\n    var c61 byte\n    var c62 byte\n    var c63 byte\n    var c64 byte\n    var c65 byte\n    var c66 byte\n    var c67 byte\n    var c68 byte\n    var c69 byte\n    var c70 byte\n    var c71 byte\n    var c72 byte\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 && text[i-1] == 'l' {\n                continue\n            }\n            if i > 1 && text[i-2] == 'a' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 1 && text[i-2] == 'u' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 2 && text[i-3] == 'f' && text[i-2] == 'u' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 2 && text[i-3] == 'w' && text[i-2] == 'e' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 3 && text[i-4] == 'w' && text[i-3] == 'e' && text[i-2] == 'l' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 3 && text[i-4] == 's' && text[i-3] == 'e' && text[i-2] == 'l' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 4 && text[i-5] == 's' && text[i-4] == 'e' && text[i-3] == 'l' && text[i-2] == 'l' && text[i-1] == 'l' {\n                continue\n            }\n            if i > 4 && text[i-5] == 'a' && text[i-4] == 'l' && text[i-3] == 'l' && text[i-2] == 'l' && text[i-1] == 'y' {\n                continue\n            }\n            if i > 5 && text[i-6] == 'a' && text[i-\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var adverb string\n    var adverb_found bool\n    var adverb_found_first bool = false\n    var adverb_found_last bool = false\n    var adverb_found_first_index int\n    var adverb_found_last_index int\n\n    for index = 0; index < len(text); index++ {\n        if text[index] == ' ' {\n            if adverb_found {\n                adverb_found_last = true\n                adverb_found_last_index = index\n            }\n            adverb_found = false\n        } else if text[index] == 'l' {\n            if index + 1 < len(text) && text[index + 1] == 'y' {\n                adverb_found = true\n                if !adverb_found_first {\n                    adverb_found_first = true\n                    adverb_found_first_index = index\n                }\n            }\n        }\n    }\n\n    if adverb_found {\n        adverb_found_last = true\n        adverb_found_last_index = index\n    }\n\n    if adverb_found_first && adverb_found_last {\n        adverb = text[adverb_found_first_index:adverb_found_last_index]\n        result = fmt.Sprintf(\"First adverb found: %s, first index: %d, last index: %d\", adverb, adverb_found_first_index, adverb_found_last_index)\n    } else {\n        result = \"No adverbs found\"\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    words := strings.Fields(text)\n    for i, word := range words {\n        if len(word) > 2 && word[len(word)-2:] == \"ly\" {\n            result = fmt.Sprintf(\"%s %d\", word, i)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 {\n                if text[i-1] == ' ' {\n                    pos = i\n                }\n            }\n            if i < len(text) - 2 {\n                if text[i+2] == ' ' {\n                    result = text[pos:i+2]\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s, %d\", text[i-3:i+2], i-3)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' {\n            if text[i+1] == 'y' {\n                result = fmt.Sprintf(\"%s%s\", result, text[i:i+2])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var ab int\n    var ac int\n    var ad int\n    var ae int\n    var af int\n    var ag int\n    var ah int\n    var ai int\n    var aj int\n    var ak int\n    var al int\n    var am int\n    var an int\n    var ao int\n    var ap int\n    var aq int\n    var ar int\n    var as int\n    var at int\n    var au int\n    var av int\n    var aw int\n    var ax int\n    var ay int\n    var az int\n    var ba int\n    var bb int\n    var bc int\n    var bd int\n    var be int\n    var bf int\n    var bg int\n    var bh int\n    var bi int\n    var bj int\n    var bk int\n    var bl int\n    var bm int\n    var bn int\n    var bo int\n    var bp int\n    var bq int\n    var br int\n    var bs int\n    var bt int\n    var bu int\n    var bv int\n    var bw int\n    var bx int\n    var by int\n    var bz int\n    var ca int\n    var cb int\n    var cc int\n    var cd int\n    var ce int\n    var cf int\n    var cg int\n    var ch int\n    var ci int\n    var cj int\n    var ck int\n    var cl int\n    var cm int\n    var cn int\n    var co int\n    var cp int\n    var cq int\n    var cr int\n    var cs int\n    var ct int\n    var cu int\n    var cv int\n    var cw int\n    var cx\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var start int\n    var end int\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n   \nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            index = i\n            break\n        }\n    }\n    for i := index; i >= 0; i-- {\n        if text[i] == ' ' {\n            break\n        }\n        result = string(text[i]) + result\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpi7tko95o_test.go:42: expected '0-7: Clearly', got 'Clearl'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpi7tko95o_test.go:42: expected '28-36: carefuly', got 'careful'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpi7tko95o_test.go:42: expected '18-25: quickly', got 'quickl'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions string\n    var adverb_found bool = false\n    var adverb_start int = 0\n    var adverb_end int = 0\n    var adverb_length int = 0\n    var adverb_count int = 0\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if adverb_found {\n                adverb_end = i\n                adverb_length = adverb_end - adverb_start\n                adverb = text[adverb_start:adverb_end]\n                adverb_positions = fmt.Sprintf(\"%s%d-%d \", adverb_positions, adverb_start, adverb_end)\n                adverb_found = false\n                adverb_count++\n            }\n        } else if text[i] == 'l' {\n            if i < len(text) - 1 && text[i+1] == 'y' {\n                adverb_found = true\n                adverb_start = i\n            }\n        }\n    }\n\n    if adverb_found {\n        adverb_end = len(text)\n        adverb_length = adverb_end - adverb_start\n        adverb = text[adverb_start:adverb_end]\n        adverb_positions = fmt.Sprintf(\"%s%d-%d \", adverb_positions, adverb_start, adverb_end)\n        adverb_count++\n    }\n\n    if adverb_count > 0 {\n        return fmt.Sprintf(\"%s%s\", adverb, adverb_positions)\n    } else {\n        return \"Not found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    // TODO: implement this function\n    return \"\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-3:i+2]\n            position = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", adverb, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            index = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, index)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions []int\n    var adverb_found bool\n    var adverb_start int\n    var adverb_end int\n    var adverb_length int\n    var adverb_counter int\n    var adverb_index int\n    var adverb_position int\n    var adverb_position_string string\n    var adverb_position_string_length int\n    var adverb_position_string_counter int\n    var adverb_position_string_index int\n    var adverb_position_string_position int\n    var adverb_position_string_position_string string\n    var adverb_position_string_position_string_length int\n    var adverb_position_string_position_string_counter int\n    var adverb_position_string_position_string_index int\n    var adverb_position_string_position_string_position int\n    var adverb_position_string_position_string_position_string string\n    var adverb_position_string_position_string_position_string_length int\n    var adverb_position_string_position_string_position_string_counter int\n    var adverb_position_string_position_string_position_string_index int\n    var adverb_position_string_position_string_position_string_position int\n    var adverb_position_string_position_string_position_string_position_string string\n    var adverb_position_string_position_string_position_string_position_string_length int\n    var adverb_position_string_position_string_position_string_position_string_counter int\n    var adverb_position_string_position_string_position_string_position_string_index int\n    var adverb_position_string_position_string_position_string_position_string_position int\n    var adverb_position_string_position_string_position_string_position_string_position_string string\n    var adverb_position_string_position_string_position_string_position_string_position_string_length int\n    var adverb_position_string_position_string_position_string_position_string_position_string_counter int\n    var adverb_\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_found bool\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb_pos = i - 1\n            adverb_end = i + 2\n            adverb_found = true\n            break\n        }\n    }\n\n    if adverb_found {\n        for i := adverb_pos; i >= 0; i-- {\n            if text[i] == ' ' {\n                adverb_pos = i + 1\n                break\n            }\n        }\n        for i := adverb_end; i < len(text); i++ {\n            if text[i] == ' ' {\n                adverb_end = i\n                break\n            }\n        }\n        adverb = text[adverb_pos:adverb_end]\n    } else {\n        adverb = \"No adverb found\"\n    }\n\n    return adverb\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var sss\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-3:i+2]\n            pos = i-3\n            found = true\n            break\n        }\n    }\n    if found {\n        return fmt.Sprintf(\"%s %d\", adverb, pos)\n    } else {\n        return \"Not found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var adverb string\n    var adverb_positions []int\n    var adverb_position int\n    var adverb_found bool\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb_found = true\n            adverb_position = i\n            for j := i; j >= 0; j-- {\n                if text[j] == ' ' {\n                    adverb_position = j\n                    break\n                }\n            }\n            adverb = text[adverb_position:i+2]\n            adverbs = append(adverbs, adverb)\n            adverb_positions = append(adverb_positions, adverb_position)\n        }\n    }\n\n    if adverb_found {\n        return fmt.Sprintf(\"The first adverb is %s and its positions are %v\", adverbs[0], adverb_positions[0])\n    } else {\n        return \"There are no adverbs in the text\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == 'l' {\n            if text[i+1] == 'y' {\n                result = text[i-1:i+2]\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_pos int\n    var adverb_found bool\n    var adverb_end_pos int\n    var adverb_end_pos_found bool\n    var adverb_end_pos_found_first bool\n    var adverb_end_pos_found_second bool\n    var adverb_end_pos_found_third bool\n    var adverb_end_pos_found_fourth bool\n    var adverb_end_pos_found_fifth bool\n    var adverb_end_pos_found_sixth bool\n    var adverb_end_pos_found_seventh bool\n    var adverb_end_pos_found_eighth bool\n    var adverb_end_pos_found_ninth bool\n    var adverb_end_pos_found_tenth bool\n    var adverb_end_pos_found_eleventh bool\n    var adverb_end_pos_found_twelfth bool\n    var adverb_end_pos_found_thirteenth bool\n    var adverb_end_pos_found_fourteenth bool\n    var adverb_end_pos_found_fifteenth bool\n    var adverb_end_pos_found_sixteenth bool\n    var adverb_end_pos_found_seventeenth bool\n    var adverb_end_pos_found_eighteenth bool\n    var adverb_end_pos_found_nineteenth bool\n    var adverb_end_pos_found_twentieth bool\n    var adverb_end_pos_found_twenty_first bool\n    var adverb_end_pos_found_twenty_second bool\n    var adverb_end_pos_found_twenty_third bool\n    var adverb_end_pos_found_twenty_fourth bool\n    var adverb_end_pos_found_twenty_fifth bool\n    var adverb_end_pos_found_twenty_sixth bool\n    var adverb_end_pos_found_twenty_seventh bool\n    var adverb_end_pos_found_twenty_eighth bool\n    var adverb_end_pos_found_twenty_ninth bool\n    var adverb_end_pos_found_th\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            index = i\n            break\n        }\n    }\n    for i := index; i >= 0; i-- {\n        if text[i] == ' ' {\n            break\n        }\n        result = string(text[i]) + result\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpi7tko95o_test.go:42: expected '0-7: Clearly', got 'Clearl'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpi7tko95o_test.go:42: expected '28-36: carefuly', got 'careful'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpi7tko95o_test.go:42: expected '18-25: quickly', got 'quickl'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var sss\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s %d\", text[i-3:i+2], i-3)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\n    var s3\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptqrszggu_test.go:99:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 && text[i-1] == 'l' {\n                continue\n            }\n            if i > 0 && text[i-1] == ' ' {\n                index = i\n                found = true\n                break\n            }\n        }\n    }\n    if found {\n        for i := index; i < len(text); i++ {\n            if text[i] == ' ' {\n                break\n            }\n            result += string(text[i])\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions []int\n    var adverb_positions_string string\n    var adverb_found bool\n    var adverb_end int\n    var adverb_start int\n    var adverb_length int\n    var i int\n    var j int\n    var k int\n\n    adverb_found = false\n    adverb_end = 0\n    adverb_start = 0\n    adverb_length = 0\n    i = 0\n    j = 0\n    k = 0\n\n    for i < len(text) {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb_end = i + 1\n            adverb_length = adverb_end - adverb_start + 1\n            adverb_positions = append(adverb_positions, adverb_start)\n            adverb_positions = append(adverb_positions, adverb_end)\n            adverb_found = true\n            break\n        }\n        i++\n    }\n\n    if adverb_found {\n        for j < len(text) {\n            if text[j] == ' ' {\n                adverb_start = j + 1\n                break\n            }\n            j++\n        }\n\n        for k < len(text) {\n            if text[k] == ' ' {\n                adverb_end = k - 1\n                adverb_length = adverb_end - adverb_start + 1\n                adverb_positions = append(adverb_positions, adverb_start)\n                adverb_positions = append(adverb_positions, adverb_end)\n                break\n            }\n            k++\n        }\n\n        adverb = text[adverb_positions[0]:adverb_positions[1]+1]\n        adverb_positions_string = fmt.Sprintf(\"%v\", adverb_positions)\n        return adverb + \" \" + adverb_positions_string\n    } else {\n        return \"No adverb found.\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            index = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, index)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var words []string\n    var adverbs []string\n    var positions []int\n    var adverb string\n    var position int\n    var i int\n\n    words = strings.Split(text, \" \")\n    for _, word := range words {\n        if strings.HasSuffix(word, \"ly\") {\n            adverbs = append(adverbs, word)\n            position = strings.Index(text, word)\n            positions = append(positions, position)\n        }\n    }\n    if len(adverbs) > 0 {\n        adverb = adverbs[0]\n        position = positions[0]\n        for i = 1; i < len(adverbs); i++ {\n            if positions[i] < position {\n                adverb = adverbs[i]\n                position = positions[i]\n            }\n        }\n        result = fmt.Sprintf(\"%s %d\", adverb, position)\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            pos = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-3:i+2]\n            break\n        }\n    }\n    return adverb\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var last_index int\n    var word string\n    var last_word string\n    var last_word_length int\n    var last_word_last_char string\n    var last_word_first_char string\n    var last_word_first_two_chars string\n    var last_word_first_three_chars string\n    var last_word_first_four_chars string\n    var last_word_first_five_chars string\n    var last_word_first_six_chars string\n    var last_word_first_seven_chars string\n    var last_word_first_eight_chars string\n    var last_word_first_nine_chars string\n    var last_word_first_ten_chars string\n    var last_word_first_eleven_chars string\n    var last_word_first_twelve_chars string\n    var last_word_first_thirteen_chars string\n    var last_word_first_fourteen_chars string\n    var last_word_first_fifteen_chars string\n    var last_word_first_sixteen_chars string\n    var last_word_first_seventeen_chars string\n    var last_word_first_eighteen_chars string\n    var last_word_first_nineteen_chars string\n    var last_word_first_twenty_chars string\n    var last_word_first_twentyone_chars string\n    var last_word_first_twentytwo_chars string\n    var last_word_first_twentythree_chars string\n    var last_word_first_twentyfour_chars string\n    var last_word_first_twentyfive_chars string\n    var last_word_first_twentysix_chars string\n    var last_word_first_twentyseven_chars string\n    var last_word_first_twentyeight_chars string\n    var last_word_first_twentynine_chars string\n    var last_word_first_thirty_chars string\n    var last_word_first_thirtyone_ch\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions string\n    var position int\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var position int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverbs = make(map[string]int)\n    var words = make([]string, 0)\n    var word string\n    var index int\n    var last_index int\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            words = append(words, text[last_index:i])\n            last_index = i + 1\n        }\n    }\n    words = append(words, text[last_index:])\n\n    for _, word = range words {\n        if len(word) > 2 && word[len(word) - 2:] == \"ly\" {\n            adverbs[word] = index\n        }\n        index++\n    }\n\n    for word, index = range adverbs {\n        result = fmt.Sprintf(\"%s%s: %d\\n\", result, word, index)\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == 'l' {\n            if text[i+1] == 'y' {\n                result = text[i-1:i+2]\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var result string\n    words := strings.Fields(text)\n    for _, word := range words {\n        if strings.HasSuffix(word, \"ly\") {\n            adverbs = append(adverbs, word)\n        }\n    }\n    if len(adverbs) > 0 {\n        result = adverbs[0]\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122492,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var sss\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-4:i+2]\n            found = true\n            break\n        }\n    }\n    if found {\n        return result\n    }\n    return \"No adverbs found\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            index = i\n            found = true\n            break\n        }\n    }\n    if found {\n        for i := index; i >= 0; i-- {\n            if text[i] == ' ' {\n                break\n            }\n            result = string(text[i]) + result\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' && text[i-1] == 'l' {\n            result = fmt.Sprintf(\"%s %d\", text[i-2:i+2], i-2)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'l' {\n            for j = i + 1; j < len(text); j++ {\n                if text[j] == 'y' {\n                    for k = j + 1; k < len(text); k++ {\n                        if text[k] == ' ' {\n                            for l = k + 1; l < len(text); l++ {\n                                if text[l] == 'a' {\n                                    for m = l + 1; m < len(text); m++ {\n                                        if text[m] == 'd' {\n                                            for n = m + 1; n < len(text); n++ {\n                                                if text[n] == 'v' {\n                                                    for o = n + 1; o < len(text); o++ {\n                                                        if text[o] == 'e' {\n                                                            for p = o + 1; p < len(text); p++ {\n                                                                if text[p] == 'r' {\n                                                                    for q = p + 1; q < len(text); q++ {\n                                                                        if text[q] == 'b' {\n                                                                            for r = q + 1; r < len(text); r++ {\n                                                                                if text[r] == ' ' {\n                                                                                    for s = r + 1; s < len(text); s++ {\n                                                                                        if text[s] == 'e' {\n                                                                                            for t = s\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            index = i\n            found = true\n            break\n        }\n    }\n    if found {\n        for i := index; i >= 0; i-- {\n            if text[i] == ' ' {\n                break\n            }\n            result = string(text[i]) + result\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverbs []string\n    var adverb string\n    var index int\n    var found bool\n    var last_index int\n    var last_adverb string\n    var last_found bool\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            if found {\n                adverbs = append(adverbs, adverb)\n                adverb = \"\"\n                found = false\n            }\n        } else if text[i] == 'l' {\n            if text[i + 1] == 'y' {\n                if found {\n                    adverbs = append(adverbs, adverb)\n                    adverb = \"\"\n                    found = false\n                }\n                found = true\n                index = i\n            }\n        } else if text[i] == '.' {\n            if found {\n                adverbs = append(adverbs, adverb)\n                adverb = \"\"\n                found = false\n            }\n        } else if found {\n            adverb += string(text[i])\n        }\n    }\n\n    for i := 0; i < len(adverbs); i++ {\n        if adverbs[i][len(adverbs[i]) - 2:] == \"ly\" {\n            last_adverb = adverbs[i]\n            last_index = index\n            last_found = true\n            break\n        }\n    }\n\n    if last_found {\n        result = fmt.Sprintf(\"%s %d\", last_adverb, last_index)\n    } else {\n        result = \"Not found\"\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            index = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, index)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n   \nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text) - 2; i++ {\n        if text[i:i+3] == \"ly \" {\n            result = text[i-1:i+3]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '28-36: carefuly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '18-25: quickly', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    var adverb string\n    var adverb_positions string\n    for i, word := range text {\n        if word == 'l' {\n            if text[i+1] == 'y' {\n                adverb = text[i-1] + \"ly\"\n                adverbs = append(adverbs, adverb)\n                adverb_positions = adverb_positions + fmt.Sprintf(\"%d \", i-1)\n            }\n        }\n    }\n    if len(adverbs) == 0 {\n        return \"No adverbs ending with ly found.\"\n    }\n    return fmt.Sprintf(\"The first adverb ending with ly is %s and its positions are %s\", adverbs[0], adverb_positions)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            pos = i\n            found = true\n            break\n        }\n    }\n    if found {\n        result = fmt.Sprintf(\"%s %d\", text[:pos+2], pos)\n    } else {\n        result = \"Not found\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var word string\n    var end int\n    var start int\n    var found bool\n    for index < len(text) {\n        if text[index] == ' ' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == ',' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == '.' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == '!' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == '?' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == '\\n' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == '\\t' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d-%d\", result, word, start, end)\n                found = false\n            }\n            index++\n            continue\n        }\n        if text[index] == '\\r' {\n            if found {\n                result = fmt.Sprintf(\"%s %s:%d\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s %d\", text[i-3:i+2], i-3)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_found bool\n    var adverb_end_found bool\n    var adverb_end_pos int\n    var adverb_end_pos_found bool\n    var adverb_end_pos_found_first bool\n    var adverb_end_pos_found_first_pos int\n    var adverb_end_pos_found_first_pos_found bool\n    var adverb_end_pos_found_first_pos_found_first bool\n    var adverb_end_pos_found_first_pos_found_first_pos int\n    var adverb_end_pos_found_first_pos_found_first_pos_found bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos int\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found_first bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos int\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos_found bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos_found_first bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos int\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos_found_first_pos_found bool\n    var adverb_end_pos_found_first_pos_found_first_pos_found_first\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' && text[i-1] == 'l' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var index int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var index int\n    for index = 0; index < len(text); index++ {\n        if text[index] == 'l' && text[index + 1] == 'y' {\n            result = text[index - 3:index + 2]\n            found = true\n            break\n        }\n    }\n    if found {\n        return fmt.Sprintf(\"%s, %d\", result, index - 3)\n    } else {\n        return \"Not found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == 'l' && text[i+1] == 'y' {\n            result = text[i-1:]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions []int\n    var adverb_found bool\n    var adverb_start int\n    var adverb_end int\n    var adverb_length int\n    var adverb_index int\n    var adverb_count int\n    var adverb_position int\n    var adverb_position_index int\n    var adverb_position_count int\n    var adverb_position_string string\n    var adverb_position_string_length int\n    var adverb_position_string_index int\n    var adverb_position_string_count int\n    var adverb_position_string_character string\n    var adverb_position_string_character_index int\n    var adverb_position_string_character_count int\n    var adverb_position_string_character_is_digit bool\n    var adverb_position_string_character_is_comma bool\n    var adverb_position_string_character_is_space bool\n    var adverb_position_string_character_is_valid bool\n    var adverb_position_string_character_is_invalid bool\n    var adverb_position_string_character_is_valid_count int\n    var adverb_position_string_character_is_invalid_count int\n    var adverb_position_string_character_is_valid_index int\n    var adverb_position_string_character_is_invalid_index int\n    var adverb_position_string_character_is_valid_character string\n    var adverb_position_string_character_is_invalid_character string\n    var adverb_position_string_character_is_valid_character_index int\n    var adverb_position_string_character_is_invalid_character_index int\n    var adverb_position_string_character_is_valid_character_count int\n    var adverb_position_string_character_is_invalid_character_count int\n    var adverb_position_string_character_is_valid_character_is_digit bool\n    var adverb_position_string_character_is_invalid_character_is_digit bool\n    var adverb_position_string_character_is_\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text) - 2; i++ {\n        if text[i:i+3] == \"ly \" {\n            result = text[i-1:i+3]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '28-36: carefuly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp7lcs1l8i_test.go:36: expected '18-25: quickly', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = fmt.Sprintf(\"%s%d\", result, i)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpzsojcr78_test.go:34: expected '0-7: Clearly', got '5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpzsojcr78_test.go:34: expected '28-36: carefuly', got '34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpzsojcr78_test.go:34: expected '18-25: quickly', got '23'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverbs []string\n    var positions []int\n    var index int\n    var word string\n    var last_char string\n    var last_two_chars string\n    var last_three_chars string\n    var last_four_chars string\n    var last_five_chars string\n    var last_six_chars string\n    var last_seven_chars string\n    var last_eight_chars string\n    var last_nine_chars string\n    var last_ten_chars string\n    var last_eleven_chars string\n    var last_twelve_chars string\n    var last_thirteen_chars string\n    var last_fourteen_chars string\n    var last_fifteen_chars string\n    var last_sixteen_chars string\n    var last_seventeen_chars string\n    var last_eighteen_chars string\n    var last_nineteen_chars string\n    var last_twenty_chars string\n    var last_twentyone_chars string\n    var last_twentytwo_chars string\n    var last_twentythree_chars string\n    var last_twentyfour_chars string\n    var last_twentyfive_chars string\n    var last_twentysix_chars string\n    var last_twentyseven_chars string\n    var last_twentyeight_chars string\n    var last_twentynine_chars string\n    var last_thirty_chars string\n    var last_thirtyone_chars string\n    var last_thirtytwo_chars string\n    var last_thirtythree_chars string\n    var last_thirtyfour_chars string\n    var last_thirtyfive_chars string\n    var last_thirtysix_chars string\n    var last_thirtyseven_chars string\n    var last_thirtyeight_chars string\n    var last_thirtynine_chars string\n    var last_forty_chars string\n    var last_fortyone_chars string\n    var last_fortytwo_chars string\n    var last_fortythree_chars string\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            index = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, index)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-3:i+2]\n            position = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", adverb, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    words := strings.Fields(text)\n    for i, word := range words {\n        if strings.HasSuffix(word, \"ly\") {\n            result = fmt.Sprintf(\"%s %d\", word, i)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            pos = i\n            for j := i; j >= 0; j-- {\n                if text[j] == ' ' {\n                    result = text[j+1:pos+2]\n                    return result\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n   \nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '0-7: Clearly', got 'arly 3'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '28-36: carefuly', got 'fuly 32'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '18-25: quickly', got 'ckly 21'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var i int\n    var j int\n    var k int\n    var found bool\n    var word string\n    var last_char string\n    var last_last_char string\n\n    result = \"\"\n    pos = 0\n    i = 0\n    j = 0\n    k = 0\n    found = false\n    word = \"\"\n    last_char = \"\"\n    last_last_char = \"\"\n\n    for i = 0; i < len(text); i++ {\n        if text[i] == ' ' || text[i] == ',' || text[i] == '.' {\n            if found {\n                result = fmt.Sprintf(\"%s%s (%d, %d)\", result, word, pos, i)\n                found = false\n            }\n            pos = i + 1\n            word = \"\"\n            last_char = \"\"\n            last_last_char = \"\"\n        } else {\n            word = fmt.Sprintf(\"%s%c\", word, text[i])\n            if len(word) > 2 {\n                last_last_char = last_char\n                last_char = string(word[len(word) - 1])\n                if last_char == \"y\" && last_last_char == \"l\" {\n                    found = true\n                }\n            }\n        }\n    }\n\n    if found {\n        result = fmt.Sprintf(\"%s%s (%d, %d)\", result, word, pos, i)\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_found bool\n    var adverb_end_found bool\n    var adverb_end_pos int\n    var adverb_end_pos_found bool\n    var adverb_end_pos_prev int\n    var adverb_end_pos_prev_found bool\n    var adverb_end_pos_prev_prev int\n    var adverb_end_pos_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_prev_prev_found bool\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var adverb_end_pos_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_found bool\n    var adverb\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            position = i - 3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpjeiucz_g_test.go:37: expected '0-7: Clearly', got 'early 2'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpjeiucz_g_test.go:37: expected '28-36: carefuly', got 'efuly 31'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpjeiucz_g_test.go:37: expected '18-25: quickly', got 'ickly 20'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var sss\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            index = i\n            break\n        }\n    }\n    for i := index; i >= 0; i-- {\n        if text[i] == ' ' {\n            break\n        }\n        result = string(text[i]) + result\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpi7tko95o_test.go:42: expected '0-7: Clearly', got 'Clearl'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpi7tko95o_test.go:42: expected '28-36: carefuly', got 'careful'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpi7tko95o_test.go:42: expected '18-25: quickly', got 'quickl'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var word string\n    var word_length int\n    var word_start int\n    var word_end int\n    var word_found bool\n    var word_is_adverb bool\n    var word_is_adjective bool\n    var word_is_verb bool\n    var word_is_noun bool\n    var word_is_pronoun bool\n    var word_is_article bool\n    var word_is_preposition bool\n    var word_is_conjunction bool\n    var word_is_interjection bool\n    var word_is_adverb_ending_with_ly bool\n    var word_is_adjective_ending_with_ly bool\n    var word_is_verb_ending_with_ly bool\n    var word_is_noun_ending_with_ly bool\n    var word_is_pronoun_ending_with_ly bool\n    var word_is_article_ending_with_ly bool\n    var word_is_preposition_ending_with_ly bool\n    var word_is_conjunction_ending_with_ly bool\n    var word_is_interjection_ending_with_ly bool\n    var word_is_adverb_ending_with_ly_found bool\n    var word_is_adjective_ending_with_ly_found bool\n    var word_is_verb_ending_with_ly_found bool\n    var word_is_noun_ending_with_ly_found bool\n    var word_is_pronoun_ending_with_ly_found bool\n    var word_is_article_ending_with_ly_found bool\n    var word_is_preposition_ending_with_ly_found bool\n    var word_is_conjunction_ending_with_ly_found bool\n    var word_is_interjection_ending_with_ly_found bool\n    var word_is_adverb_ending_with_ly_found_first bool\n    var word_is_adjective_ending_with_ly_found_first bool\n    var word_is_verb_ending_with_ly_found_first bool\n    var word_is_noun_ending_with_ly_found_\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpguh1ivmm_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122461,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var index int\n    var word string\n    var last_char string\n    var next_char string\n    var next_index int\n\n    for index = 0; index < len(text); index++ {\n        if text[index] == ' ' {\n            if found {\n                result = fmt.Sprintf(\"%s %d\", result, index)\n                found = false\n            }\n        } else {\n            if !found {\n                word = string(text[index])\n                last_char = string(text[index])\n                next_index = index + 1\n                if next_index < len(text) {\n                    next_char = string(text[next_index])\n                    if last_char == \"l\" && next_char == \"y\" {\n                        found = true\n                        result = fmt.Sprintf(\"%s%s\", result, word)\n                    }\n                }\n            } else {\n                word = fmt.Sprintf(\"%s%s\", word, string(text[index]))\n                last_char = string(text[index])\n                next_index = index + 1\n                if next_index < len(text) {\n                    next_char = string(text[next_index])\n                    if last_char == \"l\" && next_char == \"y\" {\n                        result = fmt.Sprintf(\"%s%s\", result, word)\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122544,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp9s4dgsdc_test.go:67: expected '0-7: Clearly', got 'l 8'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp9s4dgsdc_test.go:67: expected '28-36: carefuly', got 'l'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp9s4dgsdc_test.go:67: expected '18-25: quickly', got 'l'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 {\n                if text[i-1] == ' ' {\n                    pos = i - 1\n                    found = true\n                }\n            } else {\n                pos = i\n                found = true\n            }\n        }\n        if found {\n            result = text[pos:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpncy0ie7y_test.go:48: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpncy0ie7y_test.go:48: expected '28-36: carefuly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpncy0ie7y_test.go:48: expected '18-25: quickly', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            position = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s, %d\", result, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122544,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpvsepyu83_test.go:37: expected '0-7: Clearly', got 'arly, 5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpvsepyu83_test.go:37: expected '28-36: carefuly', got 'fuly, 34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpvsepyu83_test.go:37: expected '18-25: quickly', got 'ckly, 23'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions []int\n    var adverb_positions_string string\n    var adverb_found bool\n    var adverb_found_string string\n    var adverb_found_string_final string\n    var adverb_found_string_final_string string\n    var adverb_found_string_final_string_final string\n    var adverb_found_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final string\n    var adverb_found_string_final_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final_string_final string\n    var adverb_found_string_final_string_final_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final_string_final string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final_string_final_string_final string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final_string_final_string_final_string string\n    var adverb_found_string_final_string_final_string_final_string_final_string_final_string_final_string_final\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpplkvelal_test.go:31:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    for i, word := range text {\n        if word == ' ' {\n            result += \" \"\n        } else {\n            result += string(word)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbkdm4h52_test.go:11:9: i declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var word string\n    var last_char string\n    var last_char_pos int\n    var first_char_pos int\n    var word_length int\n    var text_length int\n    var text_array []string\n    text_array = make([]string, 0)\n    text_array = append(text_array, text)\n    text_length = len(text_array)\n    for i = 0; i < text_length; i++ {\n        word = text_array[i]\n        word_length = len(word)\n        last_char_pos = word_length - 1\n        last_char = string(word[last_char_pos])\n        if last_char == \"y\" {\n            first_char_pos = 0\n            for j = 0; j < word_length; j++ {\n                if string(word[j]) == \"a\" || string(word[j]) == \"e\" || string(word[j]) == \"i\" || string(word[j]) == \"o\" || string(word[j]) == \"u\" {\n                    first_char_pos = j\n                    break\n                }\n            }\n            if first_char_pos == 0 {\n                result = word\n                found = true\n                break\n            }\n        }\n    }\n    if found == false {\n        result = \"No adverbs found.\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp6xp9qa6z_test.go:65: expected '0-7: Clearly', got 'No adverbs found.'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp6xp9qa6z_test.go:65: expected '28-36: carefuly', got 'No adverbs found.'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp6xp9qa6z_test.go:65: expected '18-25: quickly', got 'No adverbs found.'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    result := \"\"\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122544,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpruvuw9gz_test.go:35: expected '0-7: Clearly', got 'early'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpruvuw9gz_test.go:35: expected '28-36: carefuly', got 'efuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpruvuw9gz_test.go:35: expected '18-25: quickly', got 'ickly'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if text[i-1] == 'l' {\n                result = text[i-2:i+2]\n                index = i-2\n                found = true\n                break\n            }\n            if text[i-2] == 'l' {\n                result = text[i-3:i+2]\n                index = i-3\n                found = true\n                break\n            }\n        }\n    }\n    if found {\n        return fmt.Sprintf(\"%s %d\", result, index)\n    }\n    return \"Not found\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp2t8qmw93_test.go:50: expected '0-7: Clearly', got 'Not found'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp2t8qmw93_test.go:50: expected '28-36: carefuly', got 'Not found'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp2t8qmw93_test.go:50: expected '18-25: quickly', got 'Not found'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            if i > 0 {\n                if text[i-1] == ' ' {\n                    pos = i - 1\n                    found = true\n                }\n            } else {\n                pos = i\n                found = true\n            }\n        }\n        if found {\n            for j := pos; j >= 0; j-- {\n                if text[j] == ' ' {\n                    result = text[j+1:i+2]\n                    break\n                }\n            }\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpptz62ehk_test.go:53: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpptz62ehk_test.go:53: expected '28-36: carefuly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpptz62ehk_test.go:53: expected '18-25: quickly', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            pos = i\n            found = true\n            break\n        }\n    }\n\n    if found {\n        result = text[pos-2:pos+2]\n    }\n\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp2bpm958x_test.go:44: expected '0-7: Clearly', got 'arly'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp2bpm958x_test.go:44: expected '28-36: carefuly', got 'fuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp2bpm958x_test.go:44: expected '18-25: quickly', got 'ckly'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-1:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpj1_q9isd_test.go:36: expected '0-7: Clearly', got 'rly'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpj1_q9isd_test.go:36: expected '28-36: carefuly', got 'uly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpj1_q9isd_test.go:36: expected '18-25: quickly', got 'kly'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            pos = i\n            found = true\n            break\n        }\n    }\n    if found {\n        result = text[pos-3:pos+2]\n    } else {\n        result = \"Not found\"\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpixpvin0t_test.go:43: expected '0-7: Clearly', got 'early'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpixpvin0t_test.go:43: expected '28-36: carefuly', got 'efuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpixpvin0t_test.go:43: expected '18-25: quickly', got 'ickly'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb = text[i-3:i+2]\n            position = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", adverb, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var index int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    for i = 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            for j = i + 1; j < len(text); j++ {\n                if text[j] == ' ' {\n                    if text[j - 1] == 'y' && text[j - 2] == 'l' {\n                        result = text[i + 1:j]\n                        return result\n                    }\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp4ks0jy7x_test.go:44: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp4ks0jy7x_test.go:44: expected '28-36: carefuly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp4ks0jy7x_test.go:44: expected '18-25: quickly', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var index int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            index = i\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s: %d\", result, index)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp0rnfj_6j_test.go:37: expected '0-7: Clearly', got 'early: 5'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp0rnfj_6j_test.go:37: expected '28-36: carefuly', got 'efuly: 34'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp0rnfj_6j_test.go:37: expected '18-25: quickly', got 'ickly: 23'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_len int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo0oyh_c4_test.go:98:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_pos int\n    var adverb_found bool\n    var adverb_end_pos int\n\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            adverb_pos = i - 1\n            adverb_end_pos = i + 2\n            adverb_found = true\n            break\n        }\n    }\n\n    if adverb_found {\n        for i := adverb_pos; i >= 0; i-- {\n            if text[i] == ' ' {\n                adverb_pos = i + 1\n                break\n            }\n        }\n\n        for i := adverb_end_pos; i < len(text); i++ {\n            if text[i] == ' ' {\n                adverb_end_pos = i\n                break\n            }\n        }\n\n        adverb = text[adverb_pos:adverb_end_pos]\n    } else {\n        adverb = \"No adverbs found\"\n    }\n\n    return adverb\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmph2zu85_s_test.go:62: expected '0-7: Clearly', got 'rly,'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmph2zu85_s_test.go:62: expected '28-36: carefuly', got 'carefuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmph2zu85_s_test.go:62: expected '18-25: quickly', got 'quickly'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' {\n            if text[i+1] == 'y' {\n                if text[i-1] == 'l' {\n                    if text[i-2] == 'y' {\n                        if text[i-3] == 'l' {\n                            if text[i-4] == 'y' {\n                                if text[i-5] == 'l' {\n                                    if text[i-6] == 'y' {\n                                        if text[i-7] == 'l' {\n                                            if text[i-8] == 'y' {\n                                                if text[i-9] == 'l' {\n                                                    if text[i-10] == 'y' {\n                                                        if text[i-11] == 'l' {\n                                                            if text[i-12] == 'y' {\n                                                                if text[i-13] == 'l' {\n                                                                    if text[i-14] == 'y' {\n                                                                        if text[i-15] == 'l' {\n                                                                            if text[i-16] == 'y' {\n                                                                                if text[i-17] == 'l' {\n                                                                                    if text[i-18] == 'y' {\n                                                                                        if text[i-19] == 'l' {\n                                                                                            if text[i-20] == 'y' {\n                                                                                                if text[i-21] == 'l' {\n                                                                                                    if text[i-22] == 'y' {\n                                                                                                        if text[i-23] == 'l' {\n                                                                                                            if text[i-24] == 'y' {\n                                                                                                                if text[i-25] == 'l' {\n                                                                                                                    if text[i-26] == 'y' {\n                                                                                                                        if text[i-27] == 'l\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwsh8s714_test.go:41:138: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            position = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmp384122ec_test.go:37: expected '0-7: Clearly', got 'arly 3'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmp384122ec_test.go:37: expected '28-36: carefuly', got 'fuly 32'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmp384122ec_test.go:37: expected '18-25: quickly', got 'ckly 21'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            position = i\n            found = true\n            break\n        }\n    }\n    if found {\n        for j := position; j >= 0; j-- {\n            if text[j] == ' ' {\n                result = text[j+1:position+2]\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122545,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpdgh02y3g_test.go:46: expected '0-7: Clearly', got ''\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpdgh02y3g_test.go:46: expected '28-36: carefuly', got 'carefuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpdgh02y3g_test.go:46: expected '18-25: quickly', got 'quickly'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var start int\n    var end int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            end = i + 2\n            for j := i; j >= 0; j-- {\n                if text[j] == ' ' {\n                    start = j + 1\n                    break\n                }\n            }\n            result = fmt.Sprintf(\"%s %d %d\", text[start:end], start, end)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122544,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpiccgcc2__test.go:44: expected '0-7: Clearly', got 'Clearly 0 7'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpiccgcc2__test.go:44: expected '28-36: carefuly', got 'carefuly 28 36'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpiccgcc2__test.go:44: expected '18-25: quickly', got 'quickly 18 25'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var pos int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-2:i+2]\n            pos = i-2\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, pos)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '0-7: Clearly', got 'arly 3'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '28-36: carefuly', got 'fuly 32'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpotdg5cgd_test.go:37: expected '18-25: quickly', got 'ckly 21'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    var i int\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            position = i\n            break\n        }\n    }\n    for i = position; i >= 0; i-- {\n        if text[i] == ' ' {\n            break\n        }\n    }\n    result = text[i+1:position+2]\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122544,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpt7lsiziv_test.go:43: expected '0-7: Clearly', got 'Clearly'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpt7lsiziv_test.go:43: expected '28-36: carefuly', got 'carefuly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpt7lsiziv_test.go:43: expected '18-25: quickly', got 'quickly'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverb string\n    var adverb_positions []int\n    var adverb_found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' {\n            if text[i+1] == 'y' {\n                adverb_found = true\n                adverb_positions = append(adverb_positions, i)\n                for j := i; j >= 0; j-- {\n                    if text[j] == ' ' {\n                        adverb_positions = append(adverb_positions, j)\n                        break\n                    }\n                }\n                adverb = text[adverb_positions[1]:adverb_positions[0]+2]\n                break\n            }\n        }\n    }\n    if adverb_found {\n        return fmt.Sprintf(\"%s %d %d\", adverb, adverb_positions[1], adverb_positions[0]+2)\n    } else {\n        return \"Not found\"\n    }\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122546,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\npanic: runtime error: index out of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.find_adverbs(0x54d978, 0x2c, 0x4cd164, 0x5fa220)\n\t/tmp/tmp08qgzt6w_test.go:24 +0x2dd\ncommand-line-arguments_test.TestFind_Adverbs(0xc000001380)\n\t/tmp/tmp08qgzt6w_test.go:43 +0x53\ntesting.tRunner(0xc000001380, 0x54f288)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    return \"\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var adverbs []string\n    for _, word := range(split_words(text)) {\n        if len(word) > 2 && word[len(word)-2:] == \"ly\" {\n            adverbs = append(adverbs, word)\n        }\n    }\n    return fmt.Sprintf(\"%v\", adverbs)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122546,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw14nkufr_test.go:11:26: undefined: split_words\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmxc8389s_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var ab int\n    var ac int\n    var ad int\n    var ae int\n    var af int\n    var ag int\n    var ah int\n    var ai int\n    var aj int\n    var ak int\n    var al int\n    var am int\n    var an int\n    var ao int\n    var ap int\n    var aq int\n    var ar int\n    var as int\n    var at int\n    var au int\n    var av int\n    var aw int\n    var ax int\n    var ay int\n    var az int\n    var ba int\n    var bb int\n    var bc int\n    var bd int\n    var be int\n    var bf int\n    var bg int\n    var bh int\n    var bi int\n    var bj int\n    var bk int\n    var bl int\n    var bm int\n    var bn int\n    var bo int\n    var bp int\n    var bq int\n    var br int\n    var bs int\n    var bt int\n    var bu int\n    var bv int\n    var bw int\n    var bx int\n    var by int\n    var bz int\n    var ca int\n    var cb int\n    var cc int\n    var cd int\n    var ce int\n    var cf int\n    var cg int\n    var ch int\n    var ci int\n    var cj int\n    var ck int\n    var cl int\n    var cm int\n    var cn int\n    var co int\n    var cp int\n    var cq int\n    var cr int\n    var cs int\n    var ct int\n    var cu int\n    var cv int\n    var cw int\n    var cx\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122491,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var position int\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            position = i-3\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s %d\", result, position)\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var i int\n    for i = 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-3:i+2]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122431,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var found bool\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'l' && text[i+1] == 'y' {\n            result = text[i-1:i+2]\n            found = true\n            break\n        }\n    }\n    if found {\n        return result\n    }\n    return \"No adverbs found\"\n}\n\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122546,
      "stdout": "--- FAIL: TestFind_Adverbs (0.00s)\n    --- FAIL: TestFind_Adverbs/test_num__0 (0.00s)\n        tmpf7xmpd5i_test.go:40: expected '0-7: Clearly', got 'rly'\n    --- FAIL: TestFind_Adverbs/test_num__1 (0.00s)\n        tmpf7xmpd5i_test.go:40: expected '28-36: carefuly', got 'uly'\n    --- FAIL: TestFind_Adverbs/test_num__2 (0.00s)\n        tmpf7xmpd5i_test.go:40: expected '18-25: quickly', got 'kly'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text string) string {\n    var result string\n    var adverb string\n    var adverb_pos int\n    var adverb_end int\n    var adverb_found bool\n    var adverb_end_found bool\n    var adverb_start_found bool\n    var adverb_start int\n    var adverb_end_pos int\n    var adverb_start_pos int\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos_found bool\n    var adverb_pos_found bool\n    var adverb_end_pos_found bool\n    var adverb_start_pos\nfunc TestFind_Adverbs(t *testing.T) {\n  candidate := find_adverbs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },\n     { actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },\n     { actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122546,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr2b61tq4_test.go:57:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}