{
  "name": "mbpp_71_comb_sort",
  "language": "go_test.go",
  "prompt": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py",
  "prompt_terminology": "reworded",
  "tests": "func TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp3x4zhcgf_test.go:44: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    if len(nums) < 2 {\n        return nums\n    }\n\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for swapped {\n        swapped = false\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp34chwgfk_test.go:44: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n\n    // Initialize the swapped flag to true.\n    swapped := true\n\n    // While the gap is greater than 1 and the swapped flag is true.\n    for gap > 1 || swapped {\n        // Reset the swapped flag to false.\n        swapped = false\n\n        // Update the gap value for the next comb.\n        gap = int(float64(gap) / 1.3)\n\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n\n        // For each pair of elements separated by the gap.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the first element is greater than the second element.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n\n                // Set the swapped flag to true.\n                swapped = true\n            }\n        }\n    }\n\n    // Return the sorted list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    if len(nums) < 2 {\n        return nums\n    }\n\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap size.\n    gap := len(nums)\n    // Initialize the shrink factor.\n    shrink := 1.3\n    // Initialize the sorted flag.\n    sorted := false\n    // Loop until the list is sorted.\n    for !sorted {\n        // Update the gap size.\n        gap = int(float64(gap) / shrink)\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n        // Initialize the sorted flag.\n        sorted = true\n        // Loop over the list.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the current element is greater than the next element, swap them.\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the sorted flag to false.\n                sorted = false\n            }\n        }\n    }\n    // Return the sorted list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmpvhpcccus_test.go:55: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    var gap int = len(nums)\n    var swapped bool = true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / shrink)\n        }\n        swapped = false\n        for i := 0; gap + i < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    var gap int = len(nums)\n    var shrink float64 = 1.3\n    var swapped bool = true\n\n    for swapped {\n        swapped = false\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            for i := 0; i + gap < len(nums); i++ {\n                if nums[i] > nums[i + gap] {\n                    nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                    swapped = true\n                }\n            }\n        } else {\n            for i := 0; i < len(nums) - 1; i++ {\n                if nums[i] > nums[i + 1] {\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                    swapped = true\n                }\n            }\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp9_ujkssl_test.go:52: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmptnfdmncd_test.go:43: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n    // Initialize the shrink factor to 1.3.\n    shrink := 1.3\n    // Initialize the swapped flag to true.\n    swapped := true\n    // While the gap is greater than 1 and the swapped flag is true.\n    for gap > 1 || swapped {\n        // Set the gap to the floor of the gap divided by the shrink factor.\n        gap = int(float64(gap) / shrink)\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n        // Set the swapped flag to false.\n        swapped = false\n        // For each pair of elements separated by the gap.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the first element is greater than the second element.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the swapped flag to true.\n                swapped = true\n            }\n        }\n    }\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    var gap int = len(nums)\n    var shrink float64 = 1.3\n    var swapped bool = true\n    for swapped {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            swapped = false\n        }\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124132,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.247330950103979)\n        }\n        swapped = false\n        for i := 0; gap+i < len(nums); i++ {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    sorted := false\n    gap := len(nums)\n    for !sorted {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        sorted = true\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmpdth27y9c_test.go:43: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = gap * 10 / 13\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmptnfdmncd_test.go:43: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap size.\n    gap := len(nums)\n\n    // Initialize the shrink factor.\n    shrink := 1.3\n\n    // Loop until the gap size is 1.\n    for gap > 1 {\n        // Update the gap size.\n        gap = int(float64(gap) / shrink)\n\n        // Initialize the left index.\n        left := 0\n\n        // Loop until the right index is less than the length of the list.\n        for right := gap; right < len(nums); right++ {\n            // If the left element is greater than the right element, swap them.\n            if nums[left] > nums[right] {\n                nums[left], nums[right] = nums[right], nums[left]\n            }\n\n            // Increment the left index.\n            left++\n        }\n    }\n\n    // Return the sorted list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp3x4zhcgf_test.go:44: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmptnfdmncd_test.go:43: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // The gap starts with a large value and shrinks by a factor of 1.3\n    // until it reaches the value 1.\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        // Update the gap value for a next comb.\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / shrink)\n        }\n        swapped = false\n        for i := 0; gap + i < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for swapped {\n        swapped = false\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp34chwgfk_test.go:44: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Set the gap to the length of the list.\n    gap := len(nums)\n    // Set the shrink factor to 1.3.\n    shrink := 1.3\n    // Set the sorted flag to false.\n    sorted := false\n\n    // While the sorted flag is false.\n    for !sorted {\n        // Set the gap to the floor of the gap divided by the shrink factor.\n        gap = int(float64(gap) / shrink)\n        // If the gap is less than 1.\n        if gap < 1 {\n            // Set the gap to 1.\n            gap = 1\n        }\n        // Set the sorted flag to true.\n        sorted = true\n        // For each index in the list.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the current element is greater than the next element.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the sorted flag to false.\n                sorted = false\n            }\n        }\n    }\n\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmpun5ws2wz_test.go:59: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp3x4zhcgf_test.go:44: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n    // Initialize the shrink factor to 1.3.\n    shrink := 1.3\n    // While the gap is greater than 1.\n    for gap > 1 {\n        // Set the gap to the floor of the gap divided by the shrink factor.\n        gap = int(float64(gap) / shrink)\n        // Initialize the i to 0.\n        i := 0\n        // While i is less than the length of the list minus the gap.\n        for i < len(nums) - gap {\n            // If the element at i is greater than the element at i plus the gap.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements at i and i plus the gap.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n            }\n            // Increment i by 1.\n            i++\n        }\n    }\n    // Initialize the swapped to true.\n    swapped := true\n    // While swapped is true.\n    for swapped {\n        // Set swapped to false.\n        swapped = false\n        // Initialize the i to 0.\n        i := 0\n        // While i is less than the length of the list minus 1.\n        for i < len(nums) - 1 {\n            // If the element at i is greater than the element at i plus 1.\n            if nums[i] > nums[i + 1] {\n                // Swap the elements at i and i plus 1.\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                // Set swapped to true.\n                swapped = true\n            }\n            // Increment i by 1.\n            i++\n        }\n    }\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    if len(nums) < 2 {\n        return nums\n    }\n\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n\n        sorted = true\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmpfdhrphag_test.go:51: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n    // Initialize the shrink factor to 1.3.\n    shrink := 1.3\n    // Initialize the swapped flag to true.\n    swapped := true\n\n    // While the gap is greater than 1 and the swapped flag is true.\n    for gap > 1 || swapped {\n        // Set the gap to the floor of the gap divided by the shrink factor.\n        gap = int(float64(gap) / shrink)\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n        // Set the swapped flag to false.\n        swapped = false\n        // For each pair of elements separated by the gap.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the first element is greater than the second element.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the swapped flag to true.\n                swapped = true\n            }\n        }\n    }\n\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    var gap int = len(nums)\n    var shrink float64 = 1.3\n    var swapped bool\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / shrink)\n        }\n        swapped = false\n        for i := 0; gap + i < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n    // Initialize the shrink factor to 1.3.\n    shrink := 1.3\n    // Initialize the swapped flag to true.\n    swapped := true\n    // While the gap is greater than 1 and the swapped flag is true.\n    for gap > 1 || swapped {\n        // Set the gap to the floor of the gap divided by the shrink factor.\n        gap = int(float64(gap) / shrink)\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n        // Set the swapped flag to false.\n        swapped = false\n        // For each pair of elements separated by the gap.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the first element is greater than the second element.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the swapped flag to true.\n                swapped = true\n            }\n        }\n    }\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    var gap int = len(nums)\n    var shrink float64 = 1.3\n    var sorted bool = false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap size.\n    gap := len(nums)\n    // Initialize the shrink factor.\n    shrink := 1.3\n    // Initialize the swapped flag.\n    swapped := true\n    // While the gap is greater than 1 and the swapped flag is true.\n    for gap > 1 || swapped {\n        // Update the gap size.\n        gap = int(float64(gap) / shrink)\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n        // Reset the swapped flag to false.\n        swapped = false\n        // Iterate over the list.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the current element is greater than the next element.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the swapped flag to true.\n                swapped = true\n            }\n        }\n    }\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n    for swapped {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmp3x4zhcgf_test.go:44: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    if len(nums) < 2 {\n        return nums\n    }\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124109,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.247330950103979)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // The gap starts at the length of the list and shrinks by a factor of 1.3\n    // until it is 1.\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    swapped := true\n\n    for swapped {\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "--- FAIL: TestComb_Sort (0.00s)\n    --- FAIL: TestComb_Sort/test_num__0 (0.00s)\n        tmpap7k_tvu_test.go:45: expected '[%!s(int=5) %!s(int=15) %!s(int=25) %!s(int=37) %!s(int=79)]', got '[%!s(int=5) %!s(int=15) %!s(int=37) %!s(int=25) %!s(int=79)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n    // Initialize the shrink factor to 1.3.\n    shrink := 1.3\n    // While the gap is greater than 1.\n    for gap > 1 {\n        // Set the gap to the floor of the gap divided by the shrink factor.\n        gap = int(float64(gap) / shrink)\n        // Initialize the i to 0.\n        i := 0\n        // While i is less than the length of the list minus the gap.\n        for i < len(nums) - gap {\n            // If the element at i is greater than the element at i plus the gap.\n            if nums[i] > nums[i + gap] {\n                // Swap the element at i with the element at i plus the gap.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n            }\n            // Increment i by 1.\n            i += 1\n        }\n    }\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap size.\n    gap := len(nums)\n    // Initialize the shrink factor.\n    shrink := 1.3\n    // Initialize the swapped flag.\n    swapped := false\n\n    // Loop until the gap is 1 and no elements have been swapped.\n    for gap > 1 || swapped {\n        // Update the gap value for a next comb.\n        gap = int(float64(gap) / shrink)\n        if gap < 1 {\n            gap = 1\n        }\n        // Reset the swapped flag.\n        swapped = false\n        // Compare all elements with the current gap.\n        for i := 0; i + gap < len(nums); i++ {\n            // Compare the current element with the element at the current gap.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the swapped flag to true.\n                swapped = true\n            }\n        }\n    }\n\n    // Return the sorted list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    // Initialize the gap to the length of the list.\n    gap := len(nums)\n    // Initialize the swap flag to true.\n    swapped := true\n    // While the gap is greater than 1 and the swap flag is true.\n    for gap > 1 || swapped {\n        // Set the gap to the floor of the gap divided by 1.3.\n        gap = int(float64(gap) / 1.3)\n        // If the gap is less than 1, set it to 1.\n        if gap < 1 {\n            gap = 1\n        }\n        // Set the swap flag to false.\n        swapped = false\n        // For each index in the list.\n        for i := 0; i + gap < len(nums); i++ {\n            // If the element at the index is greater than the element at the index plus the gap.\n            if nums[i] > nums[i + gap] {\n                // Swap the elements at the index and the index plus the gap.\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                // Set the swap flag to true.\n                swapped = true\n            }\n        }\n    }\n    // Return the list.\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    if len(nums) < 2 {\n        return nums\n    }\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i++\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap <= 1 {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i + gap < len(nums) {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n\n    for sorted == false {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        gap = int(float64(gap) / 1.3)\n        if gap < 1 {\n            gap = 1\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    swapped := true\n    for gap > 1 || swapped {\n        if gap > 1 {\n            gap = int(float64(gap) / 1.3)\n        }\n        swapped = false\n        for i := 0; i + gap < len(nums); i++ {\n            if nums[i] > nums[i + gap] {\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = true\n            }\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a list of elements.\nfunc comb_sort(nums []int) []int {\n    gap := len(nums)\n    shrink := 1.3\n    sorted := false\n    for !sorted {\n        gap = int(float64(gap) / shrink)\n        if gap > 1 {\n            sorted = false\n        } else {\n            gap = 1\n            sorted = true\n        }\n        i := 0\n        for i+gap < len(nums) {\n            if nums[i] > nums[i+gap] {\n                nums[i], nums[i+gap] = nums[i+gap], nums[i]\n                sorted = false\n            }\n            i += 1\n        }\n    }\n    return nums\n}\n\nfunc TestComb_Sort(t *testing.T) {\n  candidate := comb_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },\n     { actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },\n     { actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}