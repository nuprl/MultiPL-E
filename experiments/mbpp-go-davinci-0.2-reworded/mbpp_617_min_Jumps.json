{
  "name": "mbpp_617_min_Jumps",
  "language": "go_test.go",
  "prompt": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Write your code here\n    var result float64\n    result = 0\n    var x float64\n    x = 0\n    var y float64\n    y = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n        if x == float64(d) {\n            result += 1\n            x = 0\n            y = 0\n        } else if x > float64(d) {\n            result += 1\n            x = x - float64(d)\n        }\n    }\n    if x != 0 {\n        result += 1\n    }\n    return result\n}\n",
    "    var (\n        x float64 = 0\n        y float64 = 0\n        jumps float64 = 0\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            jumps += 1\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            count++\n            x = 0\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        x, y float64 = 0, 0\n        jumps float64 = 0\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            jumps += 1\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    return 0.0\n}\n",
    "    // Write your code here\n    var result float64\n    result = 0\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step == \"N\" {\n                y++\n            } else if step == \"S\" {\n                y--\n            } else if step == \"E\" {\n                x++\n            } else if step == \"W\" {\n                x--\n            }\n        case int:\n            result += float64(step.(int))\n        }\n    }\n    if x == d && y == 0 {\n        return result\n    }\n    if x == 0 && y == 0 {\n        return -1\n    }\n    if x == 0 {\n        if y > 0 {\n            return result + float64(y)\n        } else {\n            return result + float64(-y)\n        }\n    }\n    if y == 0 {\n        if x > 0 {\n            return result + float64(x)\n        } else {\n            return result + float64(-x)\n        }\n    }\n    if x > 0 && y > 0 {\n        return result + float64(x) + float64(y)\n    }\n    if x > 0 && y < 0 {\n        return result + float64(x) + float64(-y)\n    }\n    if x < 0 && y > 0 {\n        return result + float64(-x) + float64(y)\n    }\n    if x < 0 && y < 0 {\n        return result + float64(-x) + float64(-y)\n    }\n    return -1\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        dp [][]float64 = make([][]float64, n)\n        res float64 = 0.0\n    )\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            dp[i][j] = -1.0\n        }\n    }\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            if i == j {\n                dp[i][j] = 0.0\n            } else {\n                if i < j {\n                    for k = i; k < j; k++ {\n                        if dp[i][k] != -1.0 && dp[k+1][j] != -1.0 {\n                            if dp[i][j] == -1.0 {\n                                dp[i][j] = dp[i][k] + dp[k+1][j] + 1.0\n                            } else {\n                                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1.0)\n                            }\n                        }\n                    }\n                } else {\n                    for k = j; k < i; k++ {\n                        if dp[i][k] != -1.0 && dp[k+1][j] != -1.0 {\n                            if dp[i][j] == -1.0 {\n                                dp[i][j] = dp[i][k] + dp[k+1][j] + 1.0\n                            } else {\n                                dp",
    "    // Write your code here\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n    }\n    return (x + y) / float64(d)\n}\n",
    "    var (\n        n = len(steps)\n        dp = make([]float64, n)\n    )\n\n    for i := 0; i < n; i++ {\n        dp[i] = float64(d)\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 0; j < i; j++ {\n            if steps[j] != nil {\n                dp[i] = min(dp[i], dp[j] + float64(i - j) / steps[j].(float64))\n            }\n        }\n    }\n\n    return dp[n - 1]\n}\n",
    "    var count float64\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        count++\n        if x == float64(d) {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var result float64\n    var x, y int\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += v.(int)\n        case string:\n            if v.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == d {\n            result += 1\n            x = 0\n        }\n        if y == 0 {\n            result += 1\n            y = 0\n        }\n    }\n    return result\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        count++\n        if x >= float64(d) {\n            break\n        }\n    }\n    if x < float64(d) {\n        count += (float64(d) - x) / y\n    }\n    return count\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == 0 && y == 0 {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var (\n        x, y int\n        jumps float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            return jumps + float64(y)\n        }\n    }\n    return -1\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        aa int\n        bb int\n        cc int\n        dd int\n        ee int\n        ff int\n        gg int\n        hh int\n        ii int\n        jj int\n        kk int\n        ll int\n        mm int\n        nn int\n        oo int\n        pp int\n        qq int\n        rr int\n        ss int\n        tt int\n        uu int\n        vv int\n        ww int\n        xx int\n        yy int\n        zz int\n        aaa int\n        bbb int\n        ccc int\n        ddd int\n        eee int\n        fff int\n        ggg int\n        hhh int\n        iii int\n        jjj int\n        kkk int\n        lll int\n        mmm int\n        nnn int\n        ooo int\n        ppp int\n        qqq int\n        rrr int\n        sss int\n        ttt int\n        uuu int\n        vvv int\n        www int\n        xxx int\n        yyy int\n        zzz int\n        aaaa int\n        bbbb int\n        cccc int\n        dddd int\n        eeee int\n        ffff int\n        gggg int\n        hhhh int\n        iiii int\n        jjjj int\n        kkkk int\n        llll int\n        mmmm int\n        nnnn int\n        oooo int\n        pppp int\n        qqqq int\n        rrrr int\n        ssss int\n        tttt int\n        uuuu int\n        vvvv int\n        wwww int\n        xxxx int\n        yyyy int\n        zzzz int\n        aaaaa int\n        bbbbb int\n        ccccc int\n        ddddd int\n        eeeee int\n        fffff int\n        ggggg int\n",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        count++\n        if x == float64(d) || y == float64(d) {\n            break\n        }\n    }\n    return count\n}\n",
    "    var (\n        n int = len(steps)\n        m int = n/2\n        i int\n        j int\n        k int\n        x int\n        y int\n        z int\n        x1 int\n        y1 int\n        z1 int\n        x2 int\n        y2 int\n        z2 int\n        x3 int\n        y3 int\n        z3 int\n        x4 int\n        y4 int\n        z4 int\n        x5 int\n        y5 int\n        z5 int\n        x6 int\n        y6 int\n        z6 int\n        x7 int\n        y7 int\n        z7 int\n        x8 int\n        y8 int\n        z8 int\n        x9 int\n        y9 int\n        z9 int\n        x10 int\n        y10 int\n        z10 int\n        x11 int\n        y11 int\n        z11 int\n        x12 int\n        y12 int\n        z12 int\n        x13 int\n        y13 int\n        z13 int\n        x14 int\n        y14 int\n        z14 int\n        x15 int\n        y15 int\n        z15 int\n        x16 int\n        y16 int\n        z16 int\n        x17 int\n        y17 int\n        z17 int\n        x18 int\n        y18 int\n        z18 int\n        x19 int\n        y19 int\n        z19 int\n        x20 int\n        y20 int\n        z20 int\n        x21 int\n        y21 int\n        z21 int\n        x22 int\n        y22 int\n        z22 int\n        x23 int\n        y23 int\n        z23 int\n        x24 int\n        y24 int\n        z24 int\n        x25 int\n        y25 int\n        z25 int\n        x26 int\n        y26 int\n        z26 int\n        x27 int\n        y27 int\n        z27 int\n        x28 int\n        y28 int\n        z28 int\n        x29 int\n        y29 int\n        z29 int\n        x30 int\n        y30 int\n        z30 int\n        x31 int\n        y31 int\n        z31 int\n       ",
    "    var (\n        i, j, k int\n        n, m, x float64\n    )\n    n = float64(len(steps))\n    m = float64(d)\n    x = 0\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            x += float64(j)\n        case float64:\n            k = int(steps[i].(float64))\n            x += float64(k)\n        }\n    }\n    return (m - x) / n\n}\n",
    "    var count float64\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            count += float64(v.(int))\n        case float64:\n            count += v.(float64)\n        }\n    }\n    return count / float64(d)\n}\n",
    "    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += step.(int)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            } else if step.(string) == \"L\" {\n                x -= 1\n            } else if step.(string) == \"R\" {\n                x += 1\n            }\n        }\n        if x == d && y == 0 {\n            return float64(count)\n        }\n    }\n    return -1\n}\n",
    "    var x, y, jumps float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == float64(d) {\n            return jumps + y\n        }\n    }\n    return -1\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        count++\n    }\n\n    if x == 0 && y == 0 {\n        return count\n    }\n\n    if x == 0 {\n        return count + float64(d - int(y))\n    }\n\n    if y == 0 {\n        return count + float64(d - int(x))\n    }\n\n    return count + float64(d - int(x)) + float64(d - int(y))\n}\n",
    "    var (\n        i, j int\n        n int = len(steps)\n        m int = len(steps[0].([]interface{}))\n    )\n    var dp [][]float64 = make([][]float64, n)\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            dp[i][j] = -1\n        }\n    }\n    return min_Jumps_helper(steps, d, 0, 0, dp)\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x, y float64 = 0, 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        count += 1\n        if x == float64(d) || y == float64(d) {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var result float64\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case float64:\n            y += int(step.(float64))\n        default:\n            fmt.Println(\"Invalid step\")\n        }\n        if x == d {\n            return float64(y)\n        }\n    }\n    result = float64(y) + float64(d - x)\n    return result\n}\n",
    "    var (\n        n int\n        sum float64\n    )\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            n = v.(int)\n        case float64:\n            sum += v.(float64)\n        }\n    }\n    return float64(d) / sum * float64(n)\n}\n",
    "    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return float64(count)\n        }\n        if x > d {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var (\n        n int = len(steps)\n        dp = make([]float64, n+1)\n    )\n    dp[0] = 0\n    for i := 1; i <= n; i++ {\n        dp[i] = float64(d)\n        for j := 1; j <= i; j++ {\n            if steps[j-1].(int) + j - 1 >= i {\n                dp[i] = min(dp[i], dp[j-1] + 1)\n            }\n        }\n    }\n    return dp[n]\n}\n",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var (\n        i, j int\n        sum float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            sum += float64(steps[i].(int))\n        case float64:\n            sum += steps[i].(float64)\n        }\n        if sum >= float64(d) {\n            break\n        }\n    }\n    if i == len(steps) {\n        return -1\n    }\n    return float64(i) + 1\n}\n",
    "    // Write your code here\n    var count float64\n    var x, y float64\n    for _, v := range steps {\n        switch v.(type) {\n        case string:\n            if v.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            if v.(int) > 0 {\n                x += float64(v.(int))\n            } else {\n                x -= float64(v.(int))\n            }\n        }\n        count += 1\n        if x == float64(d) && y == 0 {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var result float64\n    var current_x float64\n    var current_y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                current_y -= 1\n            } else {\n                current_y += 1\n            }\n        case int:\n            current_x += float64(step.(int))\n        }\n        if current_x >= float64(d) {\n            result += 1\n            current_x = 0\n        }\n        if current_y == 0 {\n            result += 1\n            current_y = 0\n        }\n    }\n    return result\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        m int = 0\n        c int = 0\n        a int = 0\n        b int = 0\n        r float64 = 0\n        s float64 = 0\n        t float64 = 0\n        u float64 = 0\n        v float64 = 0\n        w float64 = 0\n        x1 float64 = 0\n        y1 float64 = 0\n        z1 float64 = 0\n        x2 float64 = 0\n        y2 float64 = 0\n        z2 float64 = 0\n        x3 float64 = 0\n        y3 float64 = 0\n        z3 float64 = 0\n        x4 float64 = 0\n        y4 float64 = 0\n        z4 float64 = 0\n        x5 float64 = 0\n        y5 float64 = 0\n        z5 float64 = 0\n        x6 float64 = 0\n        y6 float64 = 0\n        z6 float64 = 0\n        x7 float64 = 0\n        y7 float64 = 0\n        z7 float64 = 0\n        x8 float64 = 0\n        y8 float64 = 0\n        z8 float64 = 0\n        x9 float64 = 0\n        y9 float64 = 0\n        z9 float64 = 0\n        x10 float64 = 0\n        y10 float64 = 0\n        z10 float64 = 0\n        x11 float64 = 0\n        y11 float64 = 0\n        z11 float64 = 0\n        x12 float64 = 0\n        y12 float64 = 0\n        z12 float64 = 0\n        x13 float64 = 0\n        y13 float64 = 0\n        z13 float64 = 0\n        x14 float64 = 0\n        y14 float64 = 0\n        z14 float64 = 0\n        x15 float64 = 0\n        y15 float64 = 0\n        z15 float64 = 0\n        x16 float64 = 0\n        y16 float64 = 0\n        z16 float64 = 0\n        x17 float64 = 0\n        y17 float",
    "    var (\n        x, y float64\n        count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x == float64(d) || y == float64(d) {\n            count += 1\n        }\n    }\n    return count\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x == d || y == d {\n            break\n        }\n        count += 1\n    }\n    return count\n}\n",
    "    var (\n        n int\n        x, y float64\n    )\n    n = len(steps)\n    x = 0\n    y = 0\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        }\n        if x > float64(d) {\n            return -1\n        }\n        y = float64(d) - x\n        if y < 0 {\n            y = -y\n        }\n        if y < x {\n            x = y\n        }\n    }\n    return x\n}\n",
    "    // Write your code here\n    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x == float64(d) && y == 0 {\n            count += 1\n        }\n    }\n    return count\n}\n",
    "    var (\n        count int\n        x, y int\n        x_count, y_count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += step.(int)\n                x_count++\n            case string:\n                y += step.(string)\n                y_count++\n        }\n    }\n    if x_count > y_count {\n        count = x_count\n    } else {\n        count = y_count\n    }\n    return float64(count)\n}\n",
    "    var (\n        x, y float64\n        count float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"up\" {\n                y += 1\n            } else if step.(string) == \"down\" {\n                y -= 1\n            }\n        }\n        if x == float64(d) {\n            count += 1\n            x = 0\n        } else if x > float64(d) {\n            count += 1\n            x = x - float64(d)\n        }\n    }\n    return count\n}\n",
    "    var count float64\n    var x float64\n    var y float64\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += float64(step.(int))\n            case float64:\n                x += step.(float64)\n        }\n        if x > d {\n            x = d\n        }\n        y = d - x\n        count += y\n    }\n    return count\n}\n",
    "    var cnt float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            if v.(int) > d {\n                return -1\n            }\n            cnt += float64(v.(int)) / float64(d)\n        case float64:\n            if v.(float64) > float64(d) {\n                return -1\n            }\n            cnt += v.(float64) / float64(d)\n        }\n    }\n    return cnt\n}\n",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n            case \"up\":\n                y++\n            case \"down\":\n                y--\n            case \"left\":\n                x--\n            case \"right\":\n                x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        if steps[0].(int) == d {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if steps[0].(int) == d {\n        return 1\n    }\n    if steps[0].(int) > d {\n        return 0\n    }\n    return min_Jumps(steps[1:], d - steps[0].(int)) + 1\n}\n",
    "    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step {\n            case \"up\":\n                y += 1\n            case \"down\":\n                y -= 1\n            case \"left\":\n                x -= 1\n            case \"right\":\n                x += 1\n        }\n        if x == float64(d) || y == float64(d) {\n            count += 1\n            x, y = 0, 0\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        n int\n        x, y int\n        res float64\n    )\n    n = len(steps)\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x += steps[i].(int)\n        case float64:\n            y += int(steps[i].(float64))\n        }\n    }\n    res = float64(x) / float64(d)\n    if y > 0 {\n        res += float64(y)\n    }\n    return res\n}\n",
    "    var result float64\n    var x float64\n    var y float64\n    var x_step float64\n    var y_step float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x_step = float64(step.(int))\n            y_step = 0\n        case float64:\n            x_step = step.(float64)\n            y_step = 0\n        case string:\n            x_step = 0\n            y_step = 1\n        }\n        x += x_step\n        y += y_step\n        if x > d {\n            result += 1\n            x = 0\n        }\n        if y > 0 {\n            result += 1\n            y = 0\n        }\n    }\n    if x > 0 {\n        result += 1\n    }\n    if y > 0 {\n        result += 1\n    }\n    return result\n}\n",
    "    // Write your code here\n    var jump_count float64 = 0\n    var x_pos float64 = 0\n    var y_pos float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x_pos += float64(step.(int))\n        case float64:\n            x_pos += step.(float64)\n        default:\n            fmt.Println(\"Invalid step\")\n        }\n        if x_pos > float64(d) {\n            x_pos = float64(d)\n        }\n        if x_pos == float64(d) {\n            break\n        }\n        jump_count++\n        y_pos += x_pos\n        x_pos = 0\n        if y_pos > float64(d) {\n            y_pos = float64(d)\n        }\n        if y_pos == float64(d) {\n            break\n        }\n        jump_count++\n    }\n    return jump_count\n}\n",
    "    var (\n        n int\n        x, y int\n        x_, y_ int\n        x_max, y_max int\n        x_min, y_min int\n        x_sum, y_sum int\n        x_avg, y_avg float64\n        x_avg_, y_avg_ float64\n        x_avg_max, y_avg_max float64\n        x_avg_min, y_avg_min float64\n        x_avg_sum, y_avg_sum float64\n        x_avg_avg, y_avg_avg float64\n        x_avg_avg_, y_avg_avg_ float64\n        x_avg_avg_max, y_avg_avg_max float64\n        x_avg_avg_min, y_avg_avg_min float64\n        x_avg_avg_sum, y_avg_avg_sum float64\n        x_avg_avg_avg, y_avg_avg_avg float64\n        x_avg_avg_avg_, y_avg_avg_avg_ float64\n        x_avg_avg_avg_max, y_avg_avg_avg_max float64\n        x_avg_avg_avg_min, y_avg_avg_avg_min float64\n        x_avg_avg_avg_sum, y_avg_avg_avg_sum float64\n        x_avg_avg_avg_avg, y_avg_avg_avg_avg float64\n        x_avg_avg_avg_avg_, y_avg_avg_avg_avg_ float64\n        x_avg_avg_avg_avg_max, y_avg_avg_avg_avg_max float64\n        x_avg_avg_avg_avg_min, y_avg_avg_avg_avg_min float",
    "    var x, y float64 = 0, 0\n    var count int = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == float64(d) || y == float64(d) {\n            count++\n            x, y = 0, 0\n        }\n    }\n    return float64(count)\n}\n",
    "    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            count += 1\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        x, y int\n        count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d || y == d {\n            return count + 1\n        }\n        count++\n    }\n    return count\n}\n",
    "    var (\n        n int = len(steps)\n        dp []float64 = make([]float64, d+1)\n    )\n    dp[0] = 1.0\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n            case int:\n                for j := steps[i].(int); j <= d; j++ {\n                    dp[j] += dp[j-steps[i].(int)]\n                }\n            case float64:\n                for j := int(steps[i].(float64)); j <= d; j++ {\n                    dp[j] += dp[j-int(steps[i].(float64))]\n                }\n        }\n    }\n    return dp[d]\n}\n",
    "    var (\n        count float64 = 0\n        x int = 0\n        y int = 0\n    )\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += step.(int)\n        case string:\n            switch step.(string) {\n            case \"N\":\n                y += count\n            case \"S\":\n                y -= count\n            case \"E\":\n                x += count\n            case \"W\":\n                x -= count\n            }\n            count = 0\n        }\n    }\n    if x == d && y == 0 {\n        return float64(count)\n    }\n    return -1\n}\n",
    "    var result float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            result += float64(step.(int))\n        case float64:\n            result += step.(float64)\n        }\n    }\n    return result / float64(d)\n}\n",
    "    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            for k = 0; k < n; k++ {\n                for l = 0; l < n; l++ {\n                    for m = 0; m < n; m++ {\n                        for o = 0; o < n; o++ {\n                            for p = 0; p < n; p++ {\n                                for q = 0; q < n; q++ {\n                                    for r = 0; r < n; r++ {\n                                        for s = 0; s < n; s++ {\n                                            for t = 0; t < n; t++ {\n                                                for u = 0; u < n; u++ {\n                                                    for v = 0; v < n; v++ {\n                                                        for w = 0; w < n; w++ {\n                                                            for x = 0; x < n; x++ {\n                                                                for y = 0; y < n; y++ {\n                                                                    for z = 0; z < n; z++ {\n                                                                        if steps[i] + steps[j] + steps[k] + steps[l] + steps[m] + steps[o] + steps[p] + steps[q] + steps[r] + steps[s] + steps[t] + steps[u] + steps[v] + steps[w] + steps[x] + steps[y] + steps[z] == d {\n                                                                            return float64(i + j + k + l + m + o + p + q + r + s + t + u + v + w + x + y + z)\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                       ",
    "    var (\n        i, j, k, l, m int\n        n, p, q, r, s float64\n        t, u, v, w, x float64\n        y, z, aa, ab float64\n        ac, ad, ae, af float64\n        ag, ah, ai, aj float64\n        ak, al, am, an float64\n        ao, ap, aq, ar float64\n        as, at, au, av float64\n        aw, ax, ay, az float64\n        ba, bb, bc, bd float64\n        be, bf, bg, bh float64\n        bi, bj, bk, bl float64\n        bm, bn, bo, bp float64\n        bq, br, bs, bt float64\n        bu, bv, bw, bx float64\n        by, bz, ca, cb float64\n        cc, cd, ce, cf float64\n        cg, ch, ci, cj float64\n        ck, cl, cm, cn float64\n        co, cp, cq, cr float64\n        cs, ct, cu, cv float64\n        cw, cx, cy, cz float64\n        da, db, dc, dd float64\n        de, df, dg, dh float64\n        di, dj, dk, dl float64\n        dm, dn, do, dp float64\n        dq, dr, ds, dt float64\n        du, dv, dw, dx float64\n        dy, dz, ea, eb float64\n        ec, ed, ee, ef float64\n        eg, eh, ei, ej float64\n        ek, el, em, en float64\n        eo, ep, eq, er float64\n        es, et, eu, ev float64\n        ew, ex, ey, ez float64\n        fa, fb, fc, fd float64\n        fe, ff, fg, fh float64\n        fi, fj, fk, fl float64\n        fm, fn, fo, fp float64",
    "    // Write your code here\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    if sum < float64(d) {\n        return -1\n    }\n    var count float64 = 0\n    var i float64 = 0\n    for i < float64(d) {\n        var max float64 = 0\n        var max_index float64 = 0\n        for j, v := range steps {\n            if v.(float64) > max {\n                max = v.(float64)\n                max_index = float64(j)\n            }\n        }\n        steps[int(max_index)] = 0\n        i += max\n        count += 1\n    }\n    return count\n}\n",
    "    var x, y int = 0, 0\n    var count int = 0\n    for _, step := range steps {\n        switch step {\n            case \"N\":\n                y++\n            case \"S\":\n                y--\n            case \"E\":\n                x++\n            case \"W\":\n                x--\n        }\n        if x == d || y == d {\n            return float64(count)\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var x, y float64 = 0, 0\n    var x_dir, y_dir float64 = 1, 1\n    var x_max, y_max float64 = 0, 0\n    var x_min, y_min float64 = 0, 0\n    var x_jump, y_jump float64 = 0, 0\n    var x_jump_max, y_jump_max float64 = 0, 0\n    var x_jump_min, y_jump_min float64 = 0, 0\n    var x_jump_max_dir, y_jump_max_dir float64 = 1, 1\n    var x_jump_min_dir, y_jump_min_dir float64 = 1, 1\n    var x_jump_max_dir_prev, y_jump_max_dir_prev float64 = 1, 1\n    var x_jump_min_dir_prev, y_jump_min_dir_prev float64 = 1, 1\n    var x_jump_max_prev, y_jump_max_prev float64 = 0, 0\n    var x_jump_min_prev, y_jump_min_prev float64 = 0, 0\n    var x_jump_max_prev_prev, y_jump_max_prev_prev float64 = 0, 0\n    var x_jump_min_prev_prev, y_jump_min_prev_prev float64 = 0, 0\n    var x_jump_max_prev_prev_prev, y_jump_max_prev_prev_prev float64 = 0, 0\n    var x_jump_min_prev_prev_prev, y_jump_min_prev_prev_prev float64 = 0, 0\n    var x_jump_max_prev_prev_prev_prev, y_jump_max_prev_prev_prev_prev float64 = 0, 0\n    var x_jump_min_prev_prev_prev_prev, y_jump_min_prev_prev_prev_prev float64 = 0, 0\n    var x_jump_max_prev_prev_prev_prev_prev, y_jump_max_prev_prev_prev_prev_prev float64 = 0, 0\n    var x_jump_min_prev_prev",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        count++\n        if x == float64(d) || y == float64(d) {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n            case \"N\":\n                y++\n            case \"S\":\n                y--\n            case \"E\":\n                x++\n            case \"W\":\n                x--\n        }\n        if x == d || y == d {\n            count++\n            x, y = 0, 0\n        }\n    }\n    if x != 0 || y != 0 {\n        count++\n    }\n    return count\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count += 1\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    return 0.0\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return steps[0].(float64)\n    }\n    if len(steps) == 2 {\n        return steps[0].(float64) + steps[1].(float64)\n    }\n    if len(steps) == 3 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64)\n    }\n    if len(steps) == 4 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64) + steps[3].(float64)\n    }\n    if len(steps) == 5 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64) + steps[3].(float64) + steps[4].(float64)\n    }\n    if len(steps) == 6 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64) + steps[3].(float64) + steps[4].(float64) + steps[5].(float64)\n    }\n    if len(steps) == 7 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64) + steps[3].(float64) + steps[4].(float64) + steps[5].(float64) + steps[6].(float64)\n    }\n    if len(steps) == 8 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64) + steps[3].(float64) + steps[4].(float64) + steps[5].(float64) + steps[6].(float64) + steps[7].(float64)\n    }\n    if len(steps) == 9 {\n        return steps[0].(float64) + steps[1].(float64) + steps[2].(float64) + steps[3].(float64) + steps[",
    "    // Write your code here\n    var count int\n    var x int\n    var y int\n    var i int\n    for i = 0; i < len(steps); i++ {\n        if steps[i] == \"U\" {\n            y++\n        } else if steps[i] == \"D\" {\n            y--\n        } else if steps[i] == \"L\" {\n            x--\n        } else if steps[i] == \"R\" {\n            x++\n        }\n        if x == d {\n            count++\n            x = 0\n        }\n        if y == d {\n            count++\n            y = 0\n        }\n    }\n    return float64(count)\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var x, y float64 = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n    }\n    if x == float64(d) {\n        return y\n    }\n    return -1\n}\n",
    "    var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z int\n    var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z float64\n    var aa, bb, cc, dd, ee, ff, gg, hh, ii, jj, kk, ll, mm, nn, oo, pp, qq, rr, ss, tt, uu, vv, ww, xx, yy, zz string\n    var aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk, lll, mmm, nnn, ooo, ppp, qqq, rrr, sss, ttt, uuu, vvv, www, xxx, yyy, zzz []string\n    var aaaa, bbbb, cccc, dddd, eeee, ffff, gggg, hhhh, iiii, jjjj, kkkk, llll, mmmm, nnnn, oooo, pppp, qqqq, rrrr, ssss, tttt, uuuu, vvvv, wwww, xxxx, yyyy, zzzz [][]string\n    var aaaaa, bbbbb, ccccc, ddddd, eeeee, fffff, ggggg, hhhhh, iiiii, jjjjj, kkkkk, lllll, mmmmm, nnnnn, ooooo, ppppp, qqqqq, rrrrr, sssss, ttttt, uuuuu, vvvvv, wwww, xxxxx, yyyyy, zzzzz [][][]string\n    var aaaaaa, bbbbbb, cccccc, dddddd, eeeeee, ffffff, gggggg, hhhhhh, iiiiii, jjjjjj, kkkkkk, llllll, mmmmmm, nnn",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n        if x == float64(d) && y == 0 {\n            count += 1\n        }\n    }\n    return count\n}\n",
    "    // Write your code here\n    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var (\n        n int\n        x, y int\n    )\n    n = len(steps)\n    x = 0\n    y = 0\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x += steps[i].(int)\n        case string:\n            if steps[i].(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n    }\n    if x == d && y == 0 {\n        return float64(n)\n    }\n    if x < d {\n        return -1\n    }\n    if x == d && y != 0 {\n        return float64(n) + float64(y)\n    }\n    return float64(n) + float64(y) + float64(x - d)\n}\n",
    "    // Write your code here\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n    if x == float64(d) {\n        return y\n    }\n    if x < float64(d) {\n        return -1\n    }\n    return y + (x - float64(d))\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        x float64\n        y float64\n        z float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            if j > 0 {\n                for k = 0; k < j; k++ {\n                    x += 1\n                    y += 1\n                }\n            } else {\n                for k = 0; k < -j; k++ {\n                    x -= 1\n                    y -= 1\n                }\n            }\n        case float64:\n            z = steps[i].(float64)\n            if z > 0 {\n                for k = 0; k < int(z); k++ {\n                    x += 1\n                    y += 1\n                }\n            } else {\n                for k = 0; k < int(-z); k++ {\n                    x -= 1\n                    y -= 1\n                }\n            }\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return 0\n    }\n    if x == float64(d) && y != 0 {\n        return y\n    }\n    if x != float64(d) && y == 0 {\n        return x\n    }\n    if x > float64(d) && y > 0 {\n        return y\n    }\n    if x < float64(d) && y < 0 {\n        return -y\n    }\n    if x > float64(d) && y < 0 {\n        return -y + (x - float64(d))\n    }\n    if x < float64(d) && y > 0 {\n        return y + (float64(d) - x)\n    }\n    return 0\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var (\n        x, y float64\n        min_jumps float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n        if x == float64(d) {\n            min_jumps = y\n            break\n        }\n    }\n    return min_jumps\n}\n",
    "    var x, y, jumps float64\n    x = 0\n    y = 0\n    jumps = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        default:\n            fmt.Println(\"Invalid input\")\n        }\n        if x == float64(d) {\n            return jumps + 1\n        } else if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            jumps += 1\n        }\n    }\n    return -1\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                x += 1\n            } else if step.(string) == \"U\" {\n                x -= 1\n            } else if step.(string) == \"L\" {\n                y -= 1\n            } else if step.(string) == \"R\" {\n                y += 1\n            }\n        case int:\n            if step.(int) > 0 {\n                x += float64(step.(int))\n            } else {\n                x -= float64(step.(int))\n            }\n        }\n        if x == float64(d) {\n            count += 1\n            x = 0\n        }\n    }\n    return count\n}\n",
    "    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n    if x == float64(d) {\n        return y\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var count int = 0\n    var x, y int = 0, 0\n    var x_arr, y_arr []int\n    for _, step := range steps {\n        switch step {\n            case \"UP\":\n                y += 1\n            case \"DOWN\":\n                y -= 1\n            case \"LEFT\":\n                x -= 1\n            case \"RIGHT\":\n                x += 1\n        }\n        x_arr = append(x_arr, x)\n        y_arr = append(y_arr, y)\n    }\n    for i := 0; i < len(x_arr); i++ {\n        if x_arr[i] == d {\n            count++\n        }\n        if y_arr[i] == 0 {\n            count++\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    return 0\n}\n",
    "    var x, y float64 = 0, 0\n    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"up\" {\n                y += 1\n            } else if step.(string) == \"down\" {\n                y -= 1\n            }\n        }\n        if x == float64(d) {\n            return count\n        }\n        count += 1\n    }\n    return -1\n}\n",
    "    var x, y, count float64\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += float64(v.(int))\n        case float64:\n            y += v.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += 1\n            x += float64(step.(int))\n        case float64:\n            count += 1\n            x += step.(float64)\n        case string:\n            count += 1\n            y += 1\n        }\n    }\n    if x == float64(d) {\n        return count\n    }\n    if x > float64(d) {\n        return -1\n    }\n    return count + float64(d) - x\n}\n",
    "    var (\n        n int\n        x, y float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            n = step.(int)\n        case float64:\n            if x == 0 {\n                x = step.(float64)\n            } else {\n                y = step.(float64)\n            }\n        }\n    }\n    if x == 0 && y == 0 {\n        return 0\n    }\n    if x == 0 {\n        return float64(n)\n    }\n    if y == 0 {\n        return float64(n)\n    }\n    if x == float64(d) {\n        return float64(n)\n    }\n    if y == float64(d) {\n        return float64(n)\n    }\n    return float64(n) + (float64(d) - x) / y\n}\n",
    "    var (\n        jumps float64\n        i int\n    )\n    for i = 0; i < len(steps); i++ {\n        if steps[i] == \"D\" {\n            d--\n        } else {\n            jumps++\n        }\n        if d == 0 {\n            break\n        }\n    }\n    if d != 0 {\n        return -1\n    }\n    return jumps\n}\n",
    "    var (\n        n int\n        x, y float64\n    )\n    n = len(steps)\n    x = 0\n    y = 0\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        case string:\n            switch steps[i].(string) {\n            case \"up\":\n                y += 1\n            case \"down\":\n                y -= 1\n            case \"left\":\n                x -= 1\n            case \"right\":\n                x += 1\n            }\n        }\n    }\n    return (x + y) / float64(d)\n}\n",
    "    var (\n        i, j, k int\n        n, m, l int\n        x, y, z float64\n        a, b, c float64\n        dp [][]float64\n        t float64\n    )\n    n = len(steps)\n    dp = make([][]float64, n)\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, d+1)\n        for j = 0; j <= d; j++ {\n            dp[i][j] = -1.0\n        }\n    }\n    dp[0][0] = 0.0\n    for i = 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x = float64(steps[i].(int))\n            y = 0.0\n            z = 0.0\n        case float64:\n            x = steps[i].(float64)\n            y = 0.0\n            z = 0.0\n        case []interface{}:\n            x = steps[i].([]interface{})[0].(float64)\n            y = steps[i].([]interface{})[1].(float64)\n            z = steps[i].([]interface{})[2].(float64)\n        }\n        for j = 0; j <= d; j++ {\n            if dp[i][j] == -1.0 {\n                continue\n            }\n            if j + int(x) <= d {\n                dp[i+1][j+int(x)] = dp[i][j] + y\n            }\n            if i + 1 < n {\n                dp[i+1][j] = dp[i][j] + z\n            }\n        }\n    }\n    t = -1.0\n    for i = 0; i <= d; i++ {\n        if dp[n-1][i] != -1.0 {\n            if t == -1.0 || t > dp[n-1][i] {\n                t = dp[n-1][i]\n            }\n        }",
    "    var (\n        i, j int\n        k float64\n        n int = len(steps)\n    )\n    for i = 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            if j > d {\n                return -1\n            }\n            d -= j\n        case float64:\n            k = steps[i].(float64)\n            if k > d {\n                return -1\n            }\n            d -= k\n        default:\n            return -1\n        }\n    }\n    if d != 0 {\n        return -1\n    }\n    return float64(n)\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var result float64\n    result = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            result += float64(step.(int))\n        case float64:\n            result += step.(float64)\n        }\n    }\n    return result / float64(d)\n}\n",
    "    // Write your code here\n    var count float64\n    var x float64\n    var y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x == float64(d) && y == 0 {\n            count += 1\n            x = 0\n            y = 0\n        }\n    }\n    return count\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int",
    "    var (\n        i int\n        j float64\n        k float64\n        l float64\n        m float64\n        n float64\n        o float64\n        p float64\n        q float64\n        r float64\n        s float64\n        t float64\n        u float64\n        v float64\n        w float64\n        x float64\n        y float64\n        z float64\n    )\n    for i, j = range steps {\n        switch j.(type) {\n        case int:\n            k = float64(j.(int))\n        case float64:\n            k = j.(float64)\n        }\n        switch i {\n        case 0:\n            l = k\n        case 1:\n            m = k\n        case 2:\n            n = k\n        case 3:\n            o = k\n        case 4:\n            p = k\n        case 5:\n            q = k\n        case 6:\n            r = k\n        case 7:\n            s = k\n        case 8:\n            t = k\n        case 9:\n            u = k\n        case 10:\n            v = k\n        case 11:\n            w = k\n        case 12:\n            x = k\n        case 13:\n            y = k\n        case 14:\n            z = k\n        }\n    }\n    return l + m + n + o + p + q + r + s + t + u + v + w + x + y + z\n}\n",
    "    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        nn int\n        nnn int\n        nnnn int\n        nnnnn int\n        nnnnnn int\n        nnnnnnn int\n        nnnnnnnn int\n        nnnnnnnnn int\n        nnnnnnnnnn int\n        nnnnnnnnnnn int\n        nnnnnnnnnnnn int\n        nnnnnnnnnnnnn int\n        nnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn int\n        nnnnnnnnnnnnnnnnnnnnnnnnn",
    "    // Write your code here\n    if len(steps) == 0 {\n        return 0\n    }\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        count++\n        if x == float64(d) || y == float64(d) {\n            return count\n        }\n    }\n    return 0\n}\n",
    "    var (\n        x, y float64\n        count float64\n    )\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += float64(v.(int))\n        case float64:\n            x += v.(float64)\n        case string:\n            if v.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        count += 1\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var (\n        i int\n        j float64\n        x float64\n        y float64\n        z float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x = float64(steps[i].(int))\n        case float64:\n            x = steps[i].(float64)\n        default:\n            return 0\n        }\n        if x == 0 {\n            continue\n        }\n        y = x * x\n        z = y + j * j\n        j = z / (2 * x)\n    }\n    return j\n}\n",
    "    var (\n        i int\n        j float64\n        k float64\n        l float64\n        m float64\n        n float64\n        o float64\n    )\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            i = v.(int)\n        case float64:\n            j = v.(float64)\n        }\n    }\n    k = float64(i)\n    l = j\n    m = float64(d)\n    n = m / k\n    o = n / l\n    return o\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    var x_step float64 = 0\n    var y_step float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x_step = float64(step.(int))\n        case float64:\n            x_step = step.(float64)\n        }\n        x += x_step\n        y = 0\n        for y < x {\n            y += 1\n            count += 1\n        }\n        if x == float64(d) {\n            break\n        }\n    }\n    return count\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        s2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        s3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        s4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0\n        w4 int = 0\n        x5 int = 0\n        y5 int = 0\n        z5 int = 0\n        a5 int = 0\n        b5 int = 0\n        c5 int = 0\n        s5 int = 0\n        t5 int = 0\n        u5 int = 0\n        v5 int = 0\n        w5 int = 0\n        x6 int = 0\n        y6 int = 0\n        z6",
    "    // Write your code here\n    var (\n        x int\n        y int\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n    }\n    if x == d {\n        return float64(count)\n    }\n    return float64(count)\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var (\n        x, y int\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n    }\n    if x == d {\n        return float64(count)\n    }\n    if x > d {\n        return -1\n    }\n    if x < d {\n        count += (d - x)\n    }\n    return float64(count)\n}\n",
    "    // Write your code here\n    var (\n        x, y float64\n        x_step, y_step float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x_step = float64(step.(int))\n        case float64:\n            x_step = step.(float64)\n        }\n        y_step = 1 - x_step\n        x += x_step\n        y += y_step\n        if x > d {\n            count++\n            x = 0\n        }\n    }\n    if x != 0 {\n        count++\n    }\n    return float64(count)\n}\n",
    "    // Write your code here\n    return 0.0\n}\n",
    "    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n_jumps float64\n    )\n\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            if steps[i].(int) < steps[j].(int) {\n                break\n            }\n        }\n\n        if j == n {\n            break\n        }\n\n        for k = j; k < n; k++ {\n            if steps[k].(int) > steps[j - 1].(int) {\n                break\n            }\n        }\n\n        if k == n {\n            break\n        }\n\n        for l = k; l < n; l++ {\n            if steps[l].(int) < steps[k - 1].(int) {\n                break\n            }\n        }\n\n        if l == n {\n            break\n        }\n\n        for m = l; m < n; m++ {\n            if steps[m].(int) > steps[l - 1].(int) {\n                break\n            }\n        }\n\n        if m == n {\n            break\n        }\n\n        n_jumps += 1\n        i = m - 1\n    }\n\n    return n_jumps\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var i float64 = 0\n    for i < float64(d) {\n        if i + float64(steps[0].(int)) > float64(d) {\n            count++\n            break\n        }\n        i += float64(steps[0].(int))\n        count++\n    }\n    return count\n}\n",
    "    // Write your code here\n    var x, y int\n    var count float64\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            return count + 1\n        }\n        count++\n    }\n    return count\n}\n",
    "    // Write your code here\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step {\n            case \"up\":\n                y++\n            case \"down\":\n                y--\n            case \"left\":\n                x--\n            case \"right\":\n                x++\n        }\n    }\n    if x == 0 {\n        return y / float64(d)\n    } else if y == 0 {\n        return x / float64(d)\n    } else {\n        return (x + y) / float64(d)\n    }\n}\n",
    "    // Write your code here\n    var count float64\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a float64 = 0.0\n        b float64 = 0.0\n        c float64 = 0.0\n        d1 float64 = 0.0\n        d2 float64 = 0.0\n        d3 float64 = 0.0\n        d4 float64 = 0.0\n        d5 float64 = 0.0\n        d6 float64 = 0.0\n        d7 float64 = 0.0\n        d8 float64 = 0.0\n        d9 float64 = 0.0\n        d10 float64 = 0.0\n        d11 float64 = 0.0\n        d12 float64 = 0.0\n        d13 float64 = 0.0\n        d14 float64 = 0.0\n        d15 float64 = 0.0\n        d16 float64 = 0.0\n        d17 float64 = 0.0\n        d18 float64 = 0.0\n        d19 float64 = 0.0\n        d20 float64 = 0.0\n        d21 float64 = 0.0\n        d22 float64 = 0.0\n        d23 float64 = 0.0\n        d24 float64 = 0.0\n        d25 float64 = 0.0\n        d26 float64 = 0.0\n        d27 float64 = 0.0\n        d28 float64 = 0.0\n        d29 float64 = 0.0\n        d30 float64 = 0.0\n        d31 float64 = 0.0\n        d32 float64 = 0.0\n        d33 float64 = 0.0\n        d34 float64 = 0.0\n        d35 float64 = 0.0\n        d36 float64 = 0.0\n        d37 float64 = 0.0\n        d38 float64 = 0.0\n        d39 float64 = 0.0\n        d40 float64 = 0.0\n        d41 float64 = 0.0\n        d42 float64 = 0.0\n        d43 float64 = 0.0\n        d44 float64",
    "    var (\n        i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z int\n        a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z float64\n    )\n\n    return 0\n}\n",
    "    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for i = 0; i < n; i++ {\n        if steps[i] == \"U\" {\n            j++\n        } else if steps[i] == \"D\" {\n            k++\n        } else if steps[i] == \"L\" {\n            l++\n        } else if steps[i] == \"R\" {\n            m++\n        } else if steps[i] == \"UL\" {\n            n++\n        } else if steps[i] == \"UR\" {\n            o++\n        } else if steps[i] == \"DL\" {\n            p++\n        } else if steps[i] == \"DR\" {\n            q++\n        } else if steps[i] == \"LU\" {\n            r++\n        } else if steps[i] == \"LD\" {\n            s++\n        } else if steps[i] == \"RU\" {\n            t++\n        } else if steps[i] == \"RD\" {\n            u++\n        } else if steps[i] == \"ULD\" {\n            v++\n        } else if steps[i] == \"URD\" {\n            w++\n        } else if steps[i] == \"DLU\" {\n            x++\n        } else if steps[i] == \"DRU\" {\n            y++\n        } else if steps[i] == \"LUR\" {\n            z++\n        }\n    }\n    return float64(j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z)\n}\n",
    "    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            switch step.(string) {\n            case \"up\":\n                y += 1\n            case \"down\":\n                y -= 1\n            case \"left\":\n                x -= 1\n            case \"right\":\n                x += 1\n            }\n        case int:\n            for i := 0; i < step.(int); i++ {\n                count += 1\n                x += 1\n                if x == d {\n                    return float64(count)\n                }\n            }\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        aa int\n        bb int\n        cc int\n        dd int\n        ee int\n        ff int\n        gg int\n        hh int\n        ii int\n        jj int\n        kk int\n        ll int\n        mm int\n        nn int\n        oo int\n        pp int\n        qq int\n        rr int\n        ss int\n        tt int\n        uu int\n        vv int\n        ww int\n        xx int\n        yy int\n        zz int\n        aaa int\n        bbb int\n        ccc int\n        ddd int\n        eee int\n        fff int\n        ggg int\n        hhh int\n        iii int\n        jjj int\n        kkk int\n        lll int\n        mmm int\n        nnn int\n        ooo int\n        ppp int\n        qqq int\n        rrr int\n        sss int\n        ttt int\n        uuu int\n        vvv int\n        www int\n        xxx int\n        yyy int\n        zzz int\n        aaaa int\n        bbbb int\n        cccc int\n        dddd int\n        eeee int\n        ffff int\n        gggg int\n        hhhh int\n        iiii int\n        jjjj int\n        kkkk int\n        llll int\n        mmmm int\n        nnnn int\n        oooo int\n        pppp int\n        qqqq int\n        rrrr int\n        ssss int\n        tttt int\n        uuuu int\n        vvvv int\n        wwww int\n        xxxx int\n        yyyy int\n        zzzz int\n        aaaaa int\n        bbbbb int\n        ccccc int\n        ddddd int\n        eeeee int\n        fffff int\n        ggggg int\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var (\n        i, j int\n        x, y float64\n        min_jumps float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        }\n        if x >= float64(d) {\n            return 1\n        }\n        for j = i + 1; j < len(steps); j++ {\n            switch steps[j].(type) {\n            case int:\n                y += float64(steps[j].(int))\n            case float64:\n                y += steps[j].(float64)\n            }\n            if x + y >= float64(d) {\n                min_jumps = min(min_jumps, 1 + min_Jumps(steps[j:], d))\n            }\n        }\n    }\n    return min_jumps\n}\n",
    "    // Write your code here\n    var count float64\n    count = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += float64(step.(int))\n        case float64:\n            count += step.(float64)\n        }\n    }\n    return count / float64(d)\n}\n",
    "    var x, y, count float64\n    x = 0\n    y = 0\n    count = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n            x = 0\n            y = 0\n        }\n    }\n    return count\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            i = step.(int)\n        case float64:\n            j = int(step.(float64))\n        case string:\n            k = len(step.(string))\n        case bool:\n            l = 0\n            if step.(bool) {\n                l = 1\n            }\n        case []interface{}:\n            m = len(step.([]interface{}))\n        case map[string]interface{}:\n            n = len(step.(map[string]interface{}))\n        case map[int]interface{}:\n            o = len(step.(map[int]interface{}))\n        case map[float64]interface{}:\n            p = len(step.(map[float64]interface{}))\n        case map[bool]interface{}:\n            q = len(step.(map[bool]interface{}))\n        case map[interface{}]interface{}:\n            r = len(step.(map[interface{}]interface{}))\n        case chan int:\n            s = 0\n            select {\n            case <-step.(chan int):\n                s = 1\n            default:\n            }\n        case chan float64:\n            t = 0\n            select {\n            case <-step.(chan float64):\n                t = 1\n            default:\n            }\n        case chan string:\n            u = 0\n            select {\n            case <-step.(chan string):\n                u = 1\n            default:\n            }\n        case chan bool:\n            v = 0\n            select {\n            case <-step.(chan bool):\n                v = 1\n            default:\n            }\n        case chan interface{}:\n            w = 0\n            select {\n            case <-step.(chan interface{}):\n                w = 1\n            default:\n",
    "    var (\n        i, j int\n        n int = len(steps)\n        m int = len(steps[0].([]interface{}))\n        dp [][]float64 = make([][]float64, n)\n    )\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if i == 0 && j == 0 {\n                dp[i][j] = 1\n            } else if i == 0 {\n                dp[i][j] = dp[i][j - 1] * steps[i].([]interface{})[j].(float64)\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] * steps[i].([]interface{})[j].(float64)\n            } else {\n                dp[i][j] = dp[i - 1][j] * steps[i].([]interface{})[j].(float64) + dp[i][j - 1] * steps[i].([]interface{})[j].(float64)\n            }\n        }\n    }\n    return dp[n - 1][m - 1]\n}\n",
    "    var (\n        i, j int\n        x, y float64\n        res float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        }\n        if x >= float64(d) {\n            break\n        }\n    }\n    for j = i; j < len(steps); j++ {\n        switch steps[j].(type) {\n        case int:\n            y += float64(steps[j].(int))\n        case float64:\n            y += steps[j].(float64)\n        }\n        if y >= float64(d) {\n            break\n        }\n    }\n    res = float64(i) + float64(j) - float64(i) * float64(j)\n    return res\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n",
    "    var x, y float64 = 0, 0\n    var jumps float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + y\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            i = step.(int)\n        case float64:\n            j = int(step.(float64))\n        case string:\n            k = len(step.(string))\n        case []int:\n            l = len(step.([]int))\n        case []float64:\n            m = len(step.([]float64))\n        case []string:\n            n = len(step.([]string))\n        case [][]int:\n            o = len(step.([][]int))\n        case [][]float64:\n            p = len(step.([][]float64))\n        case [][]string:\n            q = len(step.([][]string))\n        case []interface{}:\n            r = len(step.([]interface{}))\n        case [][]interface{}:\n            s = len(step.([][]interface{}))\n        case map[int]int:\n            t = len(step.(map[int]int))\n        case map[int]float64:\n            u = len(step.(map[int]float64))\n        case map[int]string:\n            v = len(step.(map[int]string))\n        case map[int]interface{}:\n            w = len(step.(map[int]interface{}))\n        case map[string]int:\n            x = len(step.(map[string]int))\n        case map[string]float64:\n            y = len(step.(map[string]float64))\n        case map[string]string:\n            z = len(step.(map[string]string))\n        case map[string]interface{}:\n            i = len(step.(map[string]interface{}))\n        }\n    }\n    return float64(i+",
    "    var (\n        i, j, k int\n        n int = len(steps)\n        m float64 = 0\n        x, y float64 = 0, 0\n        a, b float64 = 0, 0\n        c float64 = 0\n        dp [][]float64\n        dp_1 [][]float64\n    )\n\n    dp = make([][]float64, n)\n    dp_1 = make([][]float64, n)\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n        dp_1[i] = make([]float64, n)\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            dp[i][j] = 0\n            dp_1[i][j] = 0\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        x = steps[i].([]interface{})[0].(float64)\n        y = steps[i].([]interface{})[1].(float64)\n        dp[i][0] = x\n        dp[i][1] = y\n        dp_1[i][0] = x\n        dp_1[i][1] = y\n    }\n\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            a = dp[i][0]\n            b = dp[i][1]\n            c = dp[j][0]\n            dp[j][0] = a + c\n            dp[j][1] = b + dp[j][1]\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            a = dp_1[i][0]\n            b = dp_1[i][1]\n            c = dp_1[j][0]\n            dp_1[j][0] = a + c\n            d",
    "    var x, y, jumps float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + y\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y > 0 {\n            jumps++\n            y = 0\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var (\n        x, y float64\n        n int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            n = step.(int)\n        case string:\n            switch step.(string) {\n            case \"N\":\n                y += float64(n)\n            case \"S\":\n                y -= float64(n)\n            case \"E\":\n                x += float64(n)\n            case \"W\":\n                x -= float64(n)\n            }\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return 0\n    }\n    if x == float64(d) && y != 0 {\n        return 1\n    }\n    if x < float64(d) && y == 0 {\n        return float64(d - int(x))\n    }\n    if x < float64(d) && y != 0 {\n        return float64(d - int(x)) + 1\n    }\n    if x > float64(d) && y == 0 {\n        return float64(int(x) - d)\n    }\n    if x > float64(d) && y != 0 {\n        return float64(int(x) - d) + 1\n    }\n    return 0\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                count += step.(int)\n            case float64:\n                count += step.(float64)\n            case string:\n                if step.(string) == \"N\" {\n                    y += count\n                } else if step.(string) == \"S\" {\n                    y -= count\n                } else if step.(string) == \"E\" {\n                    x += count\n                } else if step.(string) == \"W\" {\n                    x -= count\n                }\n                count = 0\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return count\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    if sum == float64(d) {\n        return 1\n    }\n    if sum > float64(d) {\n        return 0\n    }\n    var min float64 = float64(d)\n    for i := 0; i < len(steps); i++ {\n        var new_steps []interface{}\n        for j := 0; j < len(steps); j++ {\n            if j != i {\n                new_steps = append(new_steps, steps[j])\n            }\n        }\n        var new_min float64 = min_Jumps(new_steps, d - int(steps[i].(float64)))\n        if new_min != 0 && new_min + 1 < min {\n            min = new_min + 1\n        }\n    }\n    return min\n}\n",
    "    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y--\n            } else {\n                y++\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x >= float64(d) {\n            return float64(count) + (x - float64(d))/y\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            count++\n            x = 0\n        }\n        if y == 0 {\n            count++\n            y = 0\n        }\n    }\n    return count\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n    }\n    return float64(count)\n}\n",
    "    var count float64\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step == \"N\" {\n                y++\n            } else if step == \"S\" {\n                y--\n            } else if step == \"E\" {\n                x++\n            } else if step == \"W\" {\n                x--\n            }\n        case int:\n            if step.(int) > 0 {\n                x += float64(step.(int))\n            } else {\n                x -= float64(step.(int))\n            }\n        }\n        if x == float64(d) {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n    return (d - x) / y\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        p1 int = 0\n        q1 int = 0\n        r1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        p2 int = 0\n        q2 int = 0\n        r2 int = 0\n        s2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        p3 int = 0\n        q3 int = 0\n        r3 int = 0\n        s3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        p4 int = 0\n        q4 int = 0\n        r4 int = 0\n        s4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        dp [][]float64 = make([][]float64, n)\n        s float64 = 0.0\n        t float64 = 0.0\n        u float64 = 0.0\n        v float64 = 0.0\n        w float64 = 0.0\n        x1 float64 = 0.0\n        y1 float64 = 0.0\n        z1 float64 = 0.0\n        a1 float64 = 0.0\n        b1 float64 = 0.0\n        c1 float64 = 0.0\n    )\n\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            dp[i][j] = 0.0\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        dp[i][i] = 1.0\n    }\n\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            if steps[j].(int) - steps[i].(int) <= d {\n                dp[i][j] = 1.0\n            }\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            for k = i + 1; k < j; k++ {\n                if dp[i][k] > 0.0 && dp[k][j] > 0.0 {\n                    dp[i][j] = dp[i][k] + dp[k][j]\n                }\n            }\n        }\n    }\n\n    for i = 0; i < n; i++",
    "    // Write your code here\n    var x, y, count int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return float64(count + 1)\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n",
    "    var sum float64 = 0\n    for _, step := range steps {\n        sum += step.(float64)\n    }\n    return sum / float64(d)\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var max_jump float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            max_jump += float64(step.(int))\n        case float64:\n            max_jump += step.(float64)\n        }\n    }\n    return float64(d) / max_jump\n}\n",
    "    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var (\n        x, y float64\n        count int\n    )\n    for _, v := range steps {\n        switch v.(type) {\n        case string:\n            switch v.(string) {\n            case \"UP\":\n                y++\n            case \"DOWN\":\n                y--\n            case \"LEFT\":\n                x--\n            case \"RIGHT\":\n                x++\n            }\n        case int:\n            x += float64(v.(int))\n        case float64:\n            x += v.(float64)\n        }\n        if x == float64(d) {\n            count++\n            x = 0\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        n int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n_jumps float64\n    )\n    n = len(steps)\n    n_jumps = 0\n    for i = 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            n_jumps += float64(steps[i].(int))\n        case []int:\n            l = len(steps[i].([]int))\n            for j = 0; j < l; j++ {\n                n_jumps += float64(steps[i].([]int)[j])\n            }\n        case [][]int:\n            l = len(steps[i].([][]int))\n            for j = 0; j < l; j++ {\n                m = len(steps[i].([][]int)[j])\n                for k = 0; k < m; k++ {\n                    n_jumps += float64(steps[i].([][]int)[j][k])\n                }\n            }\n        }\n    }\n    return n_jumps\n}\n",
    "    // Write your code here\n    var x, y int\n    var count int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return float64(count)\n        }\n        count++\n    }\n    return float64(count)\n}\n",
    "    // Write your code here\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var result float64 = 0\n    var sum float64 = 0\n    var i int = 0\n    for i < len(steps) {\n        sum += steps[i].(float64)\n        if sum >= float64(d) {\n            result++\n            sum = 0\n        }\n        i++\n    }\n    return result\n}\n",
    "    var x, y float64 = 0, 0\n    var x_steps, y_steps float64 = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x_steps += float64(step.(int))\n        case float64:\n            y_steps += step.(float64)\n        }\n    }\n    x, y = x_steps, y_steps\n    if x == 0 {\n        return 0\n    }\n    if y == 0 {\n        return 1\n    }\n    return (d - x) / y\n}\n",
    "    // Write your code here\n    var (\n        x, y int\n        count int\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return float64(count)\n}\n",
    "    var (\n        x, y int\n        count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x == d || y == d {\n            return count + 1\n        }\n        count += 1\n    }\n    return count\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        p1 int = 0\n        q1 int = 0\n        r1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        p2 int = 0\n        q2 int = 0\n        r2 int = 0\n        s2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        p3 int = 0\n        q3 int = 0\n        r3 int = 0\n        s3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        p4 int = 0\n        q4 int = 0\n        r4 int = 0\n        s4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0\n        w4 int =",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y--\n            } else {\n                y++\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y += 1\n        case \"S\":\n            y -= 1\n        case \"E\":\n            x += 1\n        case \"W\":\n            x -= 1\n        }\n        if x == d || y == d {\n            count += 1\n            x = 0\n            y = 0\n        }\n    }\n    if x != 0 || y != 0 {\n        count += 1\n    }\n    return count\n}\n",
    "    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        count++\n        if x == float64(d) || y == float64(d) {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    var min_jumps float64 = 0\n    var x, y float64 = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return min_jumps\n        }\n        if x > float64(d) {\n            return -1\n        }\n        min_jumps++\n    }\n    if y == 0 {\n        return -1\n    }\n    return min_jumps + (float64(d) - x) / y\n}\n",
    "    var x, y, jumps float64 = 0, 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + y\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y > 0 {\n            jumps += y\n            y = 0\n        }\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var count float64 = 0\n    var x int = 0\n    var y int = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return count\n        }\n        if x > d {\n            return -1\n        }\n        count += 1\n    }\n    return -1\n}\n",
    "    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        default:\n            fmt.Println(\"Error: Invalid step type\")\n            return -1\n        }\n    }\n    return (d - x) / y\n}\n",
    "    // Write your code here\n    var (\n        x, y int\n        count float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            return count + float64(y)\n        }\n        if x > d {\n            return -1\n        }\n        count += 1\n    }\n    return -1\n}\n",
    "    var (\n        i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z int\n        a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z float64\n    )\n\n    return 0\n}\n",
    "    var (\n        i, j, k int\n        n int = len(steps)\n        m int = n / 2\n        x, y, z int\n        x1, y1, z1 int\n        x2, y2, z2 int\n        x3, y3, z3 int\n        x4, y4, z4 int\n        x5, y5, z5 int\n        x6, y6, z6 int\n        x7, y7, z7 int\n        x8, y8, z8 int\n        x9, y9, z9 int\n        x10, y10, z10 int\n        x11, y11, z11 int\n        x12, y12, z12 int\n        x13, y13, z13 int\n        x14, y14, z14 int\n        x15, y15, z15 int\n        x16, y16, z16 int\n        x17, y17, z17 int\n        x18, y18, z18 int\n        x19, y19, z19 int\n        x20, y20, z20 int\n        x21, y21, z21 int\n        x22, y22, z22 int\n        x23, y23, z23 int\n        x24, y24, z24 int\n        x25, y25, z25 int\n        x26, y26, z26 int\n        x27, y27, z27 int\n        x28, y28, z28 int\n        x29, y29, z29 int\n        x30, y30, z30 int\n        x31, y31, z31 int\n        x32, y32, z32 int\n        x33, y33, z33 int\n        x34, y34, z34 int\n        x35, y35, z35 int\n        x36, y36, z36 int\n        x37, y37, z37 int\n        x38, y38, z38 int\n        x39, y39, z39 int\n        x40, y40, z40 int\n        x41, y41, z41 int\n        x42, y42, z42 int\n        x43, y43, z43 int\n       ",
    "    // Write your code here\n    var count int = 0\n    var x int = 0\n    var y int = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case string:\n            if v.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            if v.(int) > 0 {\n                x += v.(int)\n            } else {\n                x -= v.(int)\n            }\n        default:\n            fmt.Println(\"Unknown type\")\n        }\n        if x == d {\n            break\n        }\n        count += 1\n    }\n    return float64(count)\n}\n",
    "    var count int = 0\n    var x, y int = 0, 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d || y == d {\n            return float64(count + 1)\n        }\n        count++\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var (\n        x float64\n        y float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return 1\n    }\n    if x > float64(d) || y != 0 {\n        return 0\n    }\n    return 1 + min_Jumps(steps[1:], d)\n}\n",
    "    var (\n        n int = len(steps)\n        m int = n / 2\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        p1 int = 0\n        q1 int = 0\n        r1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        p2 int = 0\n        q2 int = 0\n        r2 int = 0\n        s2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        p3 int = 0\n        q3 int = 0\n        r3 int = 0\n        s3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        p4 int = 0\n        q4 int = 0\n        r4 int = 0\n        s4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0\n        w4",
    "    var (\n        n int\n        x, y int\n        x_, y_ int\n        x_max, y_max int\n        x_min, y_min int\n        x_d, y_d int\n        x_d_, y_d_ int\n        x_d__, y_d__ int\n        x_d___, y_d___ int\n        x_d____, y_d____ int\n        x_d_____, y_d_____ int\n        x_d______, y_d______ int\n        x_d_______, y_d_______ int\n        x_d________, y_d________ int\n        x_d_________, y_d_________ int\n        x_d__________, y_d__________ int\n        x_d___________, y_d___________ int\n        x_d____________, y_d____________ int\n        x_d_____________, y_d_____________ int\n        x_d______________, y_d______________ int\n        x_d_______________, y_d_______________ int\n        x_d________________, y_d________________ int\n        x_d_________________, y_d_________________ int\n        x_d__________________, y_d__________________ int\n        x_d___________________, y_d___________________ int\n        x_d____________________, y_d____________________ int\n        x_d_____________________, y_d_____________________ int\n        x_d______________________, y_d______________________ int\n        x_d_______________________, y_d_______________________ int\n        x_d________________________, y_d________________________ int\n        x_d_________________________, y_d_________________________ int\n        x_d__________________________, y_d__________________________ int\n        x_d___________________________, y_d___________________________ int\n        x_d____________________________, y_d____________________________ int\n        x_d_____________________________, y_d_____________________________ int\n        x_d______________________________, y_d______________________________ int\n        x_d_______________________________, y_d_______________________________ int\n        x_d________________________________, y_d________________________________ int\n        x_d_________________________________, y_d_________________________________ int\n        x_d__________________________________, y_d__________________________________ int\n        x_d________________________________",
    "    if len(steps) == 0 {\n        return 0\n    }\n    if steps[0] == \"D\" {\n        return 1\n    }\n    if steps[0] == \"U\" {\n        return 1\n    }\n    if steps[0] == \"R\" {\n        return 1\n    }\n    if steps[0] == \"L\" {\n        return 1\n    }\n    return min_Jumps(steps[1:], d)\n}\n",
    "    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += step.(int)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                x += 1\n            }\n        }\n    }\n    if count == 0 {\n        return float64(abs(x) + abs(y))\n    }\n    return float64(abs(x) + abs(y)) / float64(count)\n}\n",
    "    var x, y int\n    var count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        count += 1\n        if x == d {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    var (\n        i, j, k int\n        n, m, x, y, z float64\n        a, b, c float64\n    )\n    n = float64(len(steps))\n    m = float64(d)\n    a = 0\n    b = 0\n    c = 0\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x = float64(steps[i].(int))\n        case float64:\n            x = steps[i].(float64)\n        }\n        a += x\n        b += x * x\n        c += x * x * x\n    }\n    y = a * a - n * b\n    z = a * b - n * c\n    return (m * m * y + m * z) / (2 * y)\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var max float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n            case int:\n                if float64(v.(int)) > max {\n                    max = float64(v.(int))\n                }\n            case float64:\n                if v.(float64) > max {\n                    max = v.(float64)\n                }\n        }\n    }\n    return float64(d) / max\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count += 1\n        }\n    }\n    return -1\n}\n",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + y\n        }\n    }\n    return -1\n}\n",
    "    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if y == 0 {\n            count++\n            x = 0\n            y = 0\n        }\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var jump float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jump\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            jump++\n        }\n    }\n    return -1\n}\n",
    "    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += float64(step.(int))\n        case float64:\n            count += step.(float64)\n        }\n    }\n    return count / float64(d)\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += float64(step.(int))\n            case float64:\n                y += float64(step.(float64))\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if y == 0 {\n            return count + 1\n        }\n        count += 1\n    }\n    return count\n}\n",
    "    var x float64 = 0\n    var y float64 = 0\n    var jumps float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n        if x > d {\n            return -1\n        }\n        if x == d {\n            return jumps + 1\n        }\n        if x < d {\n            y = d - x\n            if y > x {\n                jumps += 2\n                x = 0\n            } else {\n                jumps += 1\n                x = 0\n            }\n        }\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var (\n        x float64 = 0\n        y float64 = 0\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n    return (d - x) / y\n}\n",
    "    // Write your code here\n    var (\n        n int\n        x, y float64\n    )\n    n = len(steps)\n    x = 0\n    y = 0\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            y += steps[i].(float64)\n        }\n    }\n    return (x + y) / float64(d)\n}\n",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        dp [][]float64 = make([][]float64, n)\n        dp_1 [][]float64 = make([][]float64, n)\n        dp_2 [][]float64 = make([][]float64, n)\n        dp_3 [][]float64 = make([][]float64, n)\n        dp_4 [][]float64 = make([][]float64, n)\n        dp_5 [][]float64 = make([][]float64, n)\n        dp_6 [][]float64 = make([][]float64, n)\n        dp_7 [][]float64 = make([][]float64, n)\n        dp_8 [][]float64 = make([][]float64, n)\n        dp_9 [][]float64 = make([][]float64, n)\n        dp_10 [][]float64 = make([][]float64, n)\n        dp_11 [][]float64 = make([][]float64, n)\n        dp_12 [][]float64 = make([][]float64, n)\n        dp_13 [][]float64 = make([][]float64, n)\n        dp_14 [][]float64 = make([][]float64, n)\n        dp_15 [][]float64 = make([][]float64, n)\n        dp_16 [][]float64 = make([][]float64, n)\n        dp_17 [][]float64 = make([][]float64, n)\n        dp_18 [][]float64 = make([][]float64, n)\n        dp_19 [][]float64 = make([][]float64, n)\n        dp_20 [][]float64 = make([][",
    "    var min_jumps float64 = 0\n    var x, y int = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return min_jumps\n        }\n        if y == 0 {\n            min_jumps++\n        }\n    }\n    return min_jumps\n}\n",
    "    var (\n        i, j int\n        res float64\n        temp float64\n    )\n    for i = 0; i < len(steps); i++ {\n        temp = steps[i].(float64)\n        if temp > d {\n            res += temp / d\n        } else {\n            res += 1\n        }\n    }\n    return res\n}\n",
    "    // Write your code here\n    var count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += float64(step.(int))\n        case float64:\n            count += step.(float64)\n        }\n    }\n    return count / float64(d)\n}\n",
    "    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n            case \"N\":\n                y++\n            case \"S\":\n                y--\n            case \"E\":\n                x++\n            case \"W\":\n                x--\n        }\n        count++\n        if x == float64(d) && y == 0 {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n            count++\n        case \"down\":\n            y--\n            count++\n        case \"left\":\n            x--\n            count++\n        case \"right\":\n            x++\n            count++\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n    }\n    return -1\n}\n",
    "    var (\n        i, j int\n        n int = len(steps)\n        m int = n + 1\n        dp [][]float64 = make([][]float64, m)\n        step float64\n    )\n    for i = 0; i < m; i++ {\n        dp[i] = make([]float64, d + 1)\n    }\n    for i = 0; i < m; i++ {\n        for j = 0; j <= d; j++ {\n            if i == 0 {\n                dp[i][j] = float64(j)\n            } else {\n                step = steps[i - 1].(float64)\n                if j < int(step) {\n                    dp[i][j] = dp[i - 1][j]\n                } else {\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - int(step)])\n                }\n            }\n        }\n    }\n    return dp[n][d]\n}\n",
    "    var x, y, jumps float64\n    x = 0\n    y = 0\n    jumps = 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        default:\n            fmt.Println(\"Invalid direction\")\n        }\n        if x == d && y == 0 {\n            return jumps\n        }\n        jumps++\n    }\n    return -1\n}\n",
    "    var x, y float64 = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += float64(step.(int))\n            case float64:\n                y += step.(float64)\n            default:\n                fmt.Println(\"Invalid input\")\n        }\n    }\n    return (x + y) / float64(d)\n}\n",
    "    var total float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            total += float64(step.(int))\n        case float64:\n            total += step.(float64)\n        }\n    }\n    return total / float64(d)\n}\n",
    "    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var x, y, jumps float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n        if x >= d {\n            break\n        }\n        y = d - x\n        jumps += y / x\n        x = y\n    }\n    return jumps\n}\n",
    "    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        dp [][][]float64 = make([][][]float64, n)\n        res float64 = 0\n    )\n\n    for i = 0; i < n; i++ {\n        dp[i] = make([][]float64, n)\n        for j = 0; j < n; j++ {\n            dp[i][j] = make([]float64, n)\n            for k = 0; k < n; k++ {\n                dp[i][j][k] = -1\n            }\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            for k = 0; k < n; k++ {\n                if i == 0 && j == 0 && k == 0 {\n                    dp[i][j][k] = 0\n                } else {\n                    x = i - steps[0].(int)\n                    y = j - steps[1].(int)\n                    z = k - steps[2].(int)\n                    if x >= 0 && y >= 0 && z >= 0 {\n                        dp[i][j][k] = dp[x][y][z] + 1\n                    }\n                    if i > 0 {\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                    }\n                    if j > 0 {\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k])\n                    }\n                    if k > 0 {\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j][k - 1])\n                    }\n                }\n            }\n        }\n    }\n\n    res = dp",
    "    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        l int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        m1 int = 0\n        l1 int = 0\n        r1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        m2 int = 0\n        l2 int = 0\n        r2 int = 0\n        s2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        m3 int = 0\n        l3 int = 0\n        r3 int = 0\n        s3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        m4 int = 0\n        l4 int = 0\n        r4 int = 0\n        s4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0\n        w4 int = 0\n        x5 int",
    "    var (\n        i, j int\n        count float64\n    )\n    for i = 0; i < len(steps); i++ {\n        if steps[i] == \"D\" {\n            count++\n        } else if steps[i] == \"U\" {\n            count--\n        } else {\n            j = i\n            for j < len(steps) && steps[j] == \"U\" {\n                count--\n                j++\n            }\n            if count < 0 {\n                return -1\n            }\n        }\n        if count == float64(d) {\n            return float64(i + 1)\n        }\n    }\n    return -1\n}\n",
    "    if len(steps) == 0 {\n        return 0\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            sum += float64(v.(int))\n        case float64:\n            sum += v.(float64)\n        }\n    }\n    return sum / float64(d)\n}\n",
    "    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        if step == \"up\" {\n            y++\n        } else if step == \"down\" {\n            y--\n        } else if step == \"left\" {\n            x--\n        } else if step == \"right\" {\n            x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n",
    "    var count int\n    var x int\n    var y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n    }\n    return float64(count)\n}\n"
  ]
}