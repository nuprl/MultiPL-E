{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "go_test.go",
  "prompt": "package next_smallest_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\nfunc next_smallest_palindrome(num int) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "reworded",
  "tests": "func TestNext_Smallest_Palindrome(t *testing.T) {\n  candidate := next_smallest_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(99), expected: 101 },\n     { actual: candidate(1221), expected: 1331 },\n     { actual: candidate(120), expected: 121 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if num < 10 {\n        return num\n    }\n\n    digits := []int{}\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n\n    // fmt.Println(digits)\n\n    // find the first digit that is not 9\n    i := 0\n    for i < len(digits) && digits[i] == 9 {\n        i++\n    }\n\n    // fmt.Println(i)\n\n    // if all digits are 9, then add 1 to the most significant digit\n    if i == len(digits) {\n        digits[i-1] = 1\n        digits = append(digits, 0)\n    } else {\n        digits[i]++\n    }\n\n    // fmt.Println(digits)\n\n    // copy the first half of the digits to the second half\n    for i = 0; i < len(digits) / 2; i++ {\n        digits[len(digits) - 1 - i] = digits[i]\n    }\n\n    // fmt.Println(digits)\n\n    // convert the digits back to an integer\n    num = 0\n    for i = 0; i < len(digits); i++ {\n        num = num * 10 + digits[i]\n    }\n\n    return num\n}\n",
    "    var num_str = fmt.Sprintf(\"%d\", num)\n    var num_len = len(num_str)\n    var num_half = num_len / 2\n    var num_half_str = num_str[0:num_half]\n    var num_half_str_rev = reverse(num_half_str)\n    var num_half_str_rev_int, _ = str_to_int(num_half_str_rev)\n    var num_half_str_int, _ = str_to_int(num_half_str)\n    var num_half_str_rev_int_next = num_half_str_rev_int + 1\n    var num_half_str_rev_int_next_str = fmt.Sprintf(\"%d\", num_half_str_rev_int_next)\n    var num_half_str_rev_int_next_str_rev = reverse(num_half_str_rev_int_next_str)\n    var num_half_str_rev_int_next_str_rev_int, _ = str_to_int(num_half_str_rev_int_next_str_rev)\n    var num_half_str_rev_int_next_str_rev_int_next = num_half_str_rev_int_next_str_rev_int + 1\n    var num_half_str_rev_int_next_str_rev_int_next_str = fmt.Sprintf(\"%d\", num_half_str_rev_int_next_str_rev_int_next)\n    var num_half_str_rev_int_next_str_rev_int_next_str_rev = reverse(num_half_str_rev_int_next_str_rev_int_next_str)\n    var num_half_str_rev_int_next_str_rev_int_next_str_rev_int, _ = str_to_int(num_half_str_rev_int_next_str_rev_int_next_str_rev)\n    var num_half_str_rev_int_next_str_rev_int_next_str_rev_int",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    if num < 100 {\n        if num % 11 == 0 {\n            return num + 2\n        }\n        return num + 1\n    }\n\n    digits := []int{}\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n\n    // fmt.Println(digits)\n\n    // find the first digit that is not 9\n    i := 0\n    for i < len(digits) && digits[i] == 9 {\n        i++\n    }\n\n    // fmt.Println(i)\n\n    if i == len(digits) {\n        // all digits are 9\n        digits = append(digits, 0)\n        for i = 0; i < len(digits) / 2; i++ {\n            digits[i] = 0\n        }\n        digits[0] = 1\n        digits[len(digits) - 1] = 1\n        return to_int(digits)\n    }\n\n    // fmt.Println(digits)\n\n    if i == 0 {\n        // no digit is 9\n        digits[i]++\n        for i = 0; i < len(digits) / 2; i++ {\n            digits[len(digits) - 1 - i] = digits[i]\n        }\n        return to_int(digits)\n    }\n\n    // fmt.Println(digits)\n\n    // some digits are 9\n    digits[i]++\n    for i = 0; i < len(digits) / 2; i++ {\n        digits[len(digits) - 1 - i] = digits[i]\n    }\n    return to_int(digits)\n}\n",
    "    // convert to string\n    str := fmt.Sprintf(\"%d\", num)\n    // get length\n    length := len(str)\n    // get middle index\n    mid := length / 2\n    // get left and right\n    left := str[:mid]\n    right := str[mid+1:]\n    // reverse right\n    for i, j := 0, len(right)-1; i < j; i, j = i+1, j-1 {\n        right[i], right[j] = right[j], right[i]\n    }\n    // compare left and right\n    if left > right {\n        // left > right, return left + right\n        return num\n    } else {\n        // left < right, return left + right + 1\n        return num + 1\n    }\n}\n",
    "    if num < 10 {\n        return num\n    }\n    digits := make([]int, 0)\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n    for i := 0; i < len(digits) / 2; i++ {\n        digits[len(digits) - i - 1] = digits[i]\n    }\n    for i := 0; i < len(digits); i++ {\n        if digits[i] != 9 {\n            digits[i]++\n            break\n        } else {\n            digits[i] = 0\n        }\n    }\n    if digits[0] == 0 {\n        digits = append([]int{1}, digits...)\n    }\n    result := 0\n    for i := 0; i < len(digits); i++ {\n        result = result * 10 + digits[i]\n    }\n    return result\n}\n",
    "    // convert to string\n    str := fmt.Sprintf(\"%d\", num)\n    // get length\n    length := len(str)\n    // get half length\n    half := length / 2\n    // get left half\n    left := str[:half]\n    // get right half\n    right := str[half:]\n    // get left half as int\n    left_int, _ := strconv.Atoi(left)\n    // get right half as int\n    right_int, _ := strconv.Atoi(right)\n    // if left half is greater than right half\n    if left_int > right_int {\n        // return num\n        return num\n    }\n    // increment left half\n    left_int++\n    // convert left half to string\n    left = fmt.Sprintf(\"%d\", left_int)\n    // if length is odd\n    if length % 2 == 1 {\n        // return left + middle + left\n        return fmt.Sprintf(\"%s%s%s\", left, str[half], left)\n    }\n    // return left + left\n    return fmt.Sprintf(\"%s%s\", left, left)\n}\n",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    if num < 100 {\n        if num % 11 == 0 {\n            return num + 2\n        }\n        return num + 1\n    }\n    if num < 1000 {\n        if num % 101 == 0 {\n            return num + 202\n        }\n        if num % 11 == 0 {\n            return num + 22\n        }\n        return num + 11\n    }\n    if num < 10000 {\n        if num % 1001 == 0 {\n            return num + 2002\n        }\n        if num % 101 == 0 {\n            return num + 220\n        }\n        if num % 11 == 0 {\n            return num + 24\n        }\n        return num + 13\n    }\n    if num < 100000 {\n        if num % 10001 == 0 {\n            return num + 20002\n        }\n        if num % 1001 == 0 {\n            return num + 2200\n        }\n        if num % 101 == 0 {\n            return num + 240\n        }\n        if num % 11 == 0 {\n            return num + 26\n        }\n        return num + 15\n    }\n    if num < 1000000 {\n        if num % 100001 == 0 {\n            return num + 200002\n        }\n        if num % 10001 == 0 {\n            return num + 22000\n        }\n        if num % 1001 == 0 {\n            return num + 2400\n        }\n        if num % 101 == 0 {\n            return num + 260\n        }\n        if num % 11 == 0 {\n            return num + 28\n        }\n        return num + 17\n    }\n    if num < 10000000 {\n        if num % 1000001 == 0 {\n            return num + 2000002\n        }\n        if num % 100001 == 0 {\n            return num + 22000\n        }\n        if num % 10001 == 0 {\n            return num + 24000\n        }\n        if num % 1001 == 0 {\n            return num + 26000\n        }\n        if num % 101 == 0 {\n            return num + 280\n        }\n        if num % 11 == 0 {\n            return num + 30",
    "    if num < 0 {\n        return -1\n    }\n\n    if num < 10 {\n        return num\n    }\n\n    num_str := fmt.Sprintf(\"%d\", num)\n    num_len := len(num_str)\n\n    if num_len % 2 == 0 {\n        // even\n        left := num_str[:(num_len / 2)]\n        right := num_str[(num_len / 2):]\n        left_int, _ := strconv.Atoi(left)\n        right_int, _ := strconv.Atoi(right)\n\n        if left_int == right_int {\n            return num\n        }\n\n        if left_int > right_int {\n            return num\n        }\n\n        left_int += 1\n        left = fmt.Sprintf(\"%d\", left_int)\n        right = left\n        return strconv.Atoi(left + right)\n    } else {\n        // odd\n        left := num_str[:(num_len / 2)]\n        mid := num_str[(num_len / 2):(num_len / 2 + 1)]\n        right := num_str[(num_len / 2 + 1):]\n        left_int, _ := strconv.Atoi(left)\n        mid_int, _ := strconv.Atoi(mid)\n        right_int, _ := strconv.Atoi(right)\n\n        if left_int == right_int {\n            return num\n        }\n\n        if left_int > right_int {\n            return num\n        }\n\n        left_int += 1\n        left = fmt.Sprintf(\"%d\", left_int)\n        right = left\n        return strconv.Atoi(left + mid + right)\n    }\n}\n",
    "    if num < 0 {\n        return -1\n    }\n\n    if num < 10 {\n        return num\n    }\n\n    digits := []int{}\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n\n    // fmt.Println(digits)\n\n    // reverse the digits\n    for i, j := 0, len(digits) - 1; i < j; i, j = i + 1, j - 1 {\n        digits[i], digits[j] = digits[j], digits[i]\n    }\n\n    // fmt.Println(digits)\n\n    // find the first digit that is smaller than the digit to its right\n    // if there is no such digit, the number is already the largest palindrome\n    // that can be formed by the digits, so return the current number\n    var i int\n    for i = 0; i < len(digits) - 1; i++ {\n        if digits[i] < digits[i + 1] {\n            break\n        }\n    }\n\n    if i == len(digits) - 1 {\n        return num\n    }\n\n    // fmt.Println(i)\n\n    // find the smallest digit on the right side of (i - 1)'th digit that is\n    // greater than digits[i - 1]\n    var j int\n    for j = i + 1; j < len(digits); j++ {\n        if digits[j] < digits[i] {\n            break\n        }\n    }\n\n    // fmt.Println(j)\n\n    // swap the above found digits\n    digits[i], digits[j] = digits[j], digits[i]\n\n    // fmt.Println(digits)\n\n    // reverse the digits on the right side of (i - 1)'th digit\n    for k, l := i + 1, len(digits) - 1; k < l; k, l = k + 1, l - 1 {\n        digits[k], digits[l] = digits[l], digits[k]\n    }\n\n    // fmt.Println(digits)\n\n    // form the number and return it\n    var next_palindrome int\n    for",
    "    if num < 0 {\n        return -1\n    }\n\n    if num < 10 {\n        return num\n    }\n\n    digits := []int{}\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n\n    // fmt.Println(digits)\n\n    // reverse digits\n    for i, j := 0, len(digits) - 1; i < j; i, j = i + 1, j - 1 {\n        digits[i], digits[j] = digits[j], digits[i]\n    }\n\n    // fmt.Println(digits)\n\n    // find the first digit that is not 9\n    i := 0\n    for i < len(digits) && digits[i] == 9 {\n        i++\n    }\n\n    // fmt.Println(i)\n\n    if i == len(digits) {\n        // all digits are 9\n        digits = append(digits, 0)\n        for i := 0; i < len(digits) / 2; i++ {\n            digits[i] = 1\n        }\n        return to_int(digits)\n    }\n\n    // fmt.Println(digits)\n\n    // increase the first digit that is not 9\n    digits[i]++\n    for i--; i >= 0; i-- {\n        digits[i] = 0\n    }\n\n    // fmt.Println(digits)\n\n    return to_int(digits)\n}\n",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    digits := make([]int, 0)\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n    l := len(digits)\n    for i := 0; i < l / 2; i++ {\n        digits[l - 1 - i] = digits[i]\n    }\n    for i := 0; i < l; i++ {\n        if digits[i] != 9 {\n            break\n        }\n        digits[i] = 0\n        if i == l - 1 {\n            digits = append(digits, 0)\n            l++\n        }\n    }\n    if l % 2 == 0 {\n        digits[l / 2 - 1]++\n        digits[l / 2] = digits[l / 2 - 1]\n    } else {\n        digits[l / 2]++\n    }\n    for i := 0; i < l / 2; i++ {\n        digits[l - 1 - i] = digits[i]\n    }\n    res := 0\n    for i := 0; i < l; i++ {\n        res = res * 10 + digits[i]\n    }\n    return res\n}\n",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    digits := make([]int, 0)\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n    n := len(digits)\n    for i := 0; i < n / 2; i++ {\n        digits[n - i - 1] = digits[i]\n    }\n    for i := 0; i < n; i++ {\n        if digits[i] != 9 {\n            break\n        }\n        digits[i] = 0\n        if i == n - 1 {\n            digits = append(digits, 0)\n            n++\n        }\n    }\n    if n % 2 == 0 {\n        digits[n / 2]++\n        digits[n / 2 - 1] = digits[n / 2]\n    } else {\n        digits[n / 2]++\n    }\n    for i := 0; i < n / 2; i++ {\n        digits[n - i - 1] = digits[i]\n    }\n    num = 0\n    for i := 0; i < n; i++ {\n        num = num * 10 + digits[i]\n    }\n    return num\n}\n",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    digits := make([]int, 0)\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n    digits_len := len(digits)\n    if digits_len == 1 {\n        return digits[0]\n    }\n    if digits_len % 2 == 0 {\n        // even\n        for i := 0; i < digits_len / 2; i++ {\n            if digits[i] > digits[digits_len - 1 - i] {\n                digits[digits_len - 1 - i] = digits[i]\n            } else if digits[i] < digits[digits_len - 1 - i] {\n                digits[i] = digits[digits_len - 1 - i]\n                for j := i - 1; j >= 0; j-- {\n                    if digits[j] < 9 {\n                        digits[j]++\n                        break\n                    } else {\n                        digits[j] = 0\n                    }\n                }\n                if digits[0] == 0 {\n                    digits = append([]int{1}, digits...)\n                }\n            }\n        }\n    } else {\n        // odd\n        for i := 0; i < digits_len / 2; i++ {\n            if digits[i] > digits[digits_len - 1 - i] {\n                digits[digits_len - 1 - i] = digits[i]\n            } else if digits[i] < digits[digits_len - 1 - i] {\n                digits[i] = digits[digits_len - 1 - i]\n                for j := i - 1; j >= 0; j-- {\n                    if digits[j] < 9 {\n                        digits[j]++\n                        break\n                    } else {\n                        digits[j] = 0\n                    }\n                }\n                if digits[0] == 0 {\n                    digits = append([]int{1}, digits...)\n                }\n            }\n        }\n    }\n    // fmt.Println(digits)\n    result := 0\n    for i",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    if num < 100 {\n        if num % 11 == 0 {\n            return num + 2\n        }\n        return num + 1\n    }\n    if num < 1000 {\n        if num % 101 == 0 {\n            return num + 202\n        }\n        if num % 111 == 0 {\n            return num + 22\n        }\n        return num + 11\n    }\n    if num < 10000 {\n        if num % 1001 == 0 {\n            return num + 2002\n        }\n        if num % 1111 == 0 {\n            return num + 222\n        }\n        return num + 111\n    }\n    if num < 100000 {\n        if num % 10001 == 0 {\n            return num + 20002\n        }\n        if num % 11111 == 0 {\n            return num + 2222\n        }\n        return num + 1111\n    }\n    if num < 1000000 {\n        if num % 100001 == 0 {\n            return num + 200002\n        }\n        if num % 111111 == 0 {\n            return num + 22222\n        }\n        return num + 11111\n    }\n    if num < 10000000 {\n        if num % 1000001 == 0 {\n            return num + 2000002\n        }\n        if num % 1111111 == 0 {\n            return num + 222222\n        }\n        return num + 111111\n    }\n    if num < 100000000 {\n        if num % 10000001 == 0 {\n            return num + 20000002\n        }\n        if num % 11111111 == 0 {\n            return num + 2222222\n        }\n        return num + 1111111\n    }\n    if num < 1000000000 {\n        if num % 100000001 == 0 {\n            return num + 200000002\n        }\n        if num % 111111111 == 0 {\n            return num + 22222222\n        }\n        return num + 11111111\n    }\n    if num < 10000000000 {\n        if num % 1000000001 == 0 {\n            return num + 2000000002\n        }\n        if num % 1111111111 == 0 {\n            return",
    "    var i, j int\n    var str string\n    var is_palindrome bool\n    var num_str string = fmt.Sprintf(\"%d\", num)\n    var num_len int = len(num_str)\n    var num_half_len int = num_len / 2\n    var num_half_len_plus_one int = num_half_len + 1\n    var num_half_len_minus_one int = num_half_len - 1\n    var num_half_len_plus_one_str string = num_str[:num_half_len_plus_one]\n    var num_half_len_minus_one_str string = num_str[:num_half_len_minus_one]\n    var num_half_len_plus_one_int int = 0\n    var num_half_len_minus_one_int int = 0\n    var num_half_len_plus_one_int_plus_one int = 0\n    var num_half_len_minus_one_int_plus_one int = 0\n    var num_half_len_plus_one_int_plus_one_str string = \"\"\n    var num_half_len_minus_one_int_plus_one_str string = \"\"\n    var num_half_len_plus_one_int_plus_one_str_rev string = \"\"\n    var num_half_len_minus_one_int_plus_one_str_rev string = \"\"\n    var num_half_len_plus_one_int_plus_one_str_rev_int int = 0\n    var num_half_len_minus_one_int_plus_one_str_rev_int int = 0\n    var num_half_len_plus_one_int_plus_one_str_rev_int_str string = \"\"\n    var num_half_len_minus_one_int_plus_one_str_rev_int_str string = \"\"\n\n    if num_len == 1 {\n        return num\n    }\n\n    for {\n        is_palindrome = true\n        num_half_len_plus_one_int, _ = strconv.Atoi(num_half_",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    digits := []int{}\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n    for i := 0; i < len(digits) / 2; i++ {\n        if digits[i] < digits[len(digits) - 1 - i] {\n            digits[i] = digits[len(digits) - 1 - i]\n        } else if digits[i] > digits[len(digits) - 1 - i] {\n            digits[i] = digits[len(digits) - 1 - i]\n            for j := i + 1; j < len(digits) / 2; j++ {\n                digits[j] = 9\n            }\n            if len(digits) % 2 == 0 {\n                digits[len(digits) / 2] += 1\n            } else {\n                digits[len(digits) / 2] = 0\n                digits[len(digits) / 2 - 1] += 1\n            }\n            for k := len(digits) / 2 - 1; k >= 0; k-- {\n                if digits[k] > 9 {\n                    digits[k] = 0\n                    digits[k - 1] += 1\n                }\n            }\n        }\n    }\n    result := 0\n    for i := len(digits) - 1; i >= 0; i-- {\n        result = result * 10 + digits[i]\n    }\n    return result\n}\n",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    if num < 100 {\n        if num % 11 == 0 {\n            return num + 2\n        }\n        return num + 1\n    }\n    if num < 1000 {\n        if num % 101 == 0 {\n            return num + 202\n        }\n        if num % 111 == 0 {\n            return num + 22\n        }\n        return num + 11\n    }\n    if num < 10000 {\n        if num % 1001 == 0 {\n            return num + 2002\n        }\n        if num % 1111 == 0 {\n            return num + 222\n        }\n        if num % 1101 == 0 {\n            return num + 202\n        }\n        return num + 101\n    }\n    if num < 100000 {\n        if num % 10001 == 0 {\n            return num + 20002\n        }\n        if num % 11111 == 0 {\n            return num + 2222\n        }\n        if num % 11011 == 0 {\n            return num + 2022\n        }\n        if num % 10101 == 0 {\n            return num + 2002\n        }\n        return num + 1001\n    }\n    if num < 1000000 {\n        if num % 100001 == 0 {\n            return num + 200002\n        }\n        if num % 111111 == 0 {\n            return num + 22222\n        }\n        if num % 110011 == 0 {\n            return num + 20202\n        }\n        if num % 101101 == 0 {\n            return num + 20202\n        }\n        if num % 100101 == 0 {\n            return num + 20002\n        }\n        return num + 10001\n    }\n    if num < 10000000 {\n        if num % 1000001 == 0 {\n            return num + 2000002\n        }\n        if num % 1111111 == 0 {\n            return num + 222222\n        }\n        if num % 1100011 == 0 {\n            return num + 202002\n        }\n        if num % 1011001 == 0 {\n            return num + 20202\n        }\n        if num % 1001101 == 0 {\n            return num + 20002\n        }",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    if num < 100 {\n        if num % 11 == 0 {\n            return num + 11\n        }\n        return num + 1\n    }\n    if num < 1000 {\n        if num % 111 == 0 {\n            return num + 111\n        }\n        return num + 1\n    }\n    if num < 10000 {\n        if num % 1111 == 0 {\n            return num + 1111\n        }\n        return num + 1\n    }\n    if num < 100000 {\n        if num % 11111 == 0 {\n            return num + 11111\n        }\n        return num + 1\n    }\n    if num < 1000000 {\n        if num % 111111 == 0 {\n            return num + 111111\n        }\n        return num + 1\n    }\n    if num < 10000000 {\n        if num % 1111111 == 0 {\n            return num + 1111111\n        }\n        return num + 1\n    }\n    if num < 100000000 {\n        if num % 11111111 == 0 {\n            return num + 11111111\n        }\n        return num + 1\n    }\n    if num < 1000000000 {\n        if num % 111111111 == 0 {\n            return num + 111111111\n        }\n        return num + 1\n    }\n    if num < 10000000000 {\n        if num % 1111111111 == 0 {\n            return num + 1111111111\n        }\n        return num + 1\n    }\n    if num < 100000000000 {\n        if num % 11111111111 == 0 {\n            return num + 11111111111\n        }\n        return num + 1\n    }\n    if num < 1000000000000 {\n        if num % 111111111111 == 0 {\n            return num + 111111111111\n        }\n        return num + 1\n    }\n    if num < 10000000000000 {\n        if num % 1111111111111 == 0 {\n            return num + 1111111111111\n        }\n        return num + 1\n    }\n    if num < 100000000000000 {\n        if num % 11111111111111 == 0 {\n            return num + 111",
    "    // convert to string\n    str := fmt.Sprintf(\"%d\", num)\n    // get length\n    length := len(str)\n    // get half length\n    half := length / 2\n    // get left half\n    left := str[:half]\n    // get right half\n    right := str[length-half:]\n    // reverse right half\n    for i, j := 0, len(right)-1; i < j; i, j = i+1, j-1 {\n        right[i], right[j] = right[j], right[i]\n    }\n    // compare left half and right half\n    if left < right {\n        // left half is smaller, so return the palindrome\n        return num\n    } else {\n        // left half is bigger, so increase the left half by 1\n        // and return the palindrome\n        return next_smallest_palindrome(num + 1)\n    }\n}\n",
    "    if num < 0 {\n        return -1\n    }\n    if num < 10 {\n        return num\n    }\n    digits := []int{}\n    for num > 0 {\n        digits = append(digits, num % 10)\n        num /= 10\n    }\n    n := len(digits)\n    i := 0\n    for i < n / 2 && digits[i] == digits[n - 1 - i] {\n        i++\n    }\n    if i == n / 2 {\n        if n % 2 == 0 {\n            digits[n / 2 - 1]++\n            digits[n / 2] = digits[n / 2 - 1]\n        } else {\n            digits[n / 2]++\n        }\n        i = n / 2 - 1\n        for i >= 0 && digits[i] > 9 {\n            digits[i] = 0\n            digits[n - 1 - i] = 0\n            i--\n        }\n        if i < 0 {\n            digits = append([]int{1}, digits...)\n        } else {\n            digits[i]++\n            digits[n - 1 - i] = digits[i]\n        }\n    } else {\n        if n % 2 == 0 {\n            digits[n / 2] = digits[n / 2 - 1]\n        }\n        for i >= 0 {\n            digits[n - 1 - i] = digits[i]\n            i--\n        }\n    }\n    num = 0\n    for i = 0; i < n; i++ {\n        num = num * 10 + digits[i]\n    }\n    return num\n}\n"
  ]
}