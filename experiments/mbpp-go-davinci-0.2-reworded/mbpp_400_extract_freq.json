{
  "name": "mbpp_400_extract_freq",
  "language": "go_test.go",
  "prompt": "package extract_freq_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract the number of unique lists in the given list.\nfunc extract_freq(test_list [][]interface{}) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py",
  "prompt_terminology": "reworded",
  "tests": "func TestExtract_Freq(t *testing.T) {\n  candidate := extract_freq\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{3, 4}, []interface{}{1, 2}, []interface{}{4, 3}, []interface{}{5, 6}}), expected: 3 },\n     { actual: candidate([][]int{[]interface{}{4, 15}, []interface{}{2, 3}, []interface{}{5, 4}, []interface{}{6, 7}}), expected: 4 },\n     { actual: candidate([][]int{[]interface{}{5, 16}, []interface{}{2, 3}, []interface{}{6, 5}, []interface{}{6, 9}}), expected: 4 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Create a map to store the unique lists.\n    unique_lists := make(map[string]bool)\n\n    // Iterate over the list and store the unique lists in the map.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_str := fmt.Sprintf(\"%v\", list)\n\n        // Store the list in the map.\n        unique_lists[list_str] = true\n    }\n\n    // Return the number of unique lists.\n    return len(unique_lists)\n}\n",
    "    var unique_lists []interface{}\n    for _, list := range test_list {\n        unique_lists = append(unique_lists, list)\n    }\n    return len(unique_lists)\n}\n",
    "    // Create a map to store the unique lists.\n    unique_lists := make(map[string]int)\n\n    // Loop through the list.\n    for _, list := range test_list {\n        // Create a string to store the list.\n        list_string := \"\"\n\n        // Loop through the list.\n        for _, element := range list {\n            // Add the element to the string.\n            list_string += fmt.Sprintf(\"%v\", element)\n        }\n\n        // Add the list to the map.\n        unique_lists[list_string] = 1\n    }\n\n    // Return the length of the map.\n    return len(unique_lists)\n}\n",
    "    var unique_list []interface{}\n    for _, list := range test_list {\n        if !contains(unique_list, list) {\n            unique_list = append(unique_list, list)\n        }\n    }\n    return len(unique_list)\n}\n",
    "    // Create a map to store the unique lists.\n    unique_lists := make(map[string]bool)\n\n    // Iterate through the list.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_string := fmt.Sprintf(\"%v\", list)\n\n        // Check if the list is already in the map.\n        if _, ok := unique_lists[list_string]; !ok {\n            // If not, add it to the map.\n            unique_lists[list_string] = true\n        }\n    }\n\n    // Return the length of the map.\n    return len(unique_lists)\n}\n",
    "    // Create a map to store the unique lists.\n    unique_lists := make(map[string]int)\n\n    // Iterate through the list and store the unique lists in the map.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_string := fmt.Sprintf(\"%v\", list)\n\n        // Add the list to the map.\n        unique_lists[list_string] = 1\n    }\n\n    // Return the number of unique lists.\n    return len(unique_lists)\n}\n",
    "    var unique_lists []interface{}\n    for _, sublist := range test_list {\n        if !contains(unique_lists, sublist) {\n            unique_lists = append(unique_lists, sublist)\n        }\n    }\n    return len(unique_lists)\n}\n",
    "    // Create a map to hold the unique lists.\n    unique_lists := make(map[string]bool)\n\n    // Loop through the list and add the unique lists to the map.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_string := fmt.Sprintf(\"%v\", list)\n\n        // Add the list to the map.\n        unique_lists[list_string] = true\n    }\n\n    // Return the length of the map.\n    return len(unique_lists)\n}\n",
    "    var unique_lists []interface{}\n    for _, sub_list := range test_list {\n        if !contains(unique_lists, sub_list) {\n            unique_lists = append(unique_lists, sub_list)\n        }\n    }\n    return len(unique_lists)\n}\n",
    "    // Create a map to hold the unique lists.\n    unique_lists := make(map[string]bool)\n\n    // Loop through the list.\n    for _, list := range test_list {\n        // Create a string from the list.\n        list_string := fmt.Sprint(list)\n\n        // Add the list to the map.\n        unique_lists[list_string] = true\n    }\n\n    // Return the length of the map.\n    return len(unique_lists)\n}\n",
    "    // Create a map to store the frequency of each list.\n    freq_map := make(map[string]int)\n\n    // Iterate over the list and store the frequency of each list.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_str := fmt.Sprint(list)\n\n        // Increment the frequency of the list.\n        freq_map[list_str]++\n    }\n\n    // Return the number of unique lists.\n    return len(freq_map)\n}\n",
    "    var unique_lists []interface{}\n    for _, list := range test_list {\n        var unique_list []interface{}\n        for _, item := range list {\n            if !contains(unique_list, item) {\n                unique_list = append(unique_list, item)\n            }\n        }\n        unique_lists = append(unique_lists, unique_list)\n    }\n    return len(unique_lists)\n}\n",
    "    // Create a map to store the unique lists\n    unique_lists := make(map[string]bool)\n\n    // Loop through the list of lists\n    for _, list := range test_list {\n        // Create a string to store the list as a string\n        list_string := \"\"\n\n        // Loop through the list\n        for _, item := range list {\n            // Add the item to the list string\n            list_string += fmt.Sprintf(\"%v\", item)\n        }\n\n        // Add the list string to the map\n        unique_lists[list_string] = true\n    }\n\n    // Return the length of the map\n    return len(unique_lists)\n}\n",
    "    unique_list := make(map[string]int)\n    for _, list := range test_list {\n        unique_list[fmt.Sprint(list)] += 1\n    }\n    return len(unique_list)\n}\n",
    "    var unique_list_count int = 0\n    var unique_lists [][]interface{}\n    for _, list := range test_list {\n        var is_unique bool = true\n        for _, unique_list := range unique_lists {\n            if len(list) == len(unique_list) {\n                for i := 0; i < len(list); i++ {\n                    if list[i] != unique_list[i] {\n                        is_unique = false\n                        break\n                    }\n                }\n                if is_unique {\n                    break\n                }\n            }\n        }\n        if is_unique {\n            unique_lists = append(unique_lists, list)\n            unique_list_count++\n        }\n    }\n    return unique_list_count\n}\n",
    "    // Create a map to store the unique lists.\n    unique_lists := make(map[string]bool)\n\n    // Iterate over the lists in the given list.\n    for _, list := range test_list {\n        // Create a string to store the list as a string.\n        list_string := \"\"\n\n        // Iterate over the elements in the list.\n        for _, element := range list {\n            // Add the element to the string.\n            list_string += fmt.Sprintf(\"%v\", element)\n        }\n\n        // Add the list to the map.\n        unique_lists[list_string] = true\n    }\n\n    // Return the length of the map.\n    return len(unique_lists)\n}\n",
    "    var unique_list_count int\n    unique_list_count = 0\n    for i := 0; i < len(test_list); i++ {\n        var unique_list bool\n        unique_list = true\n        for j := 0; j < len(test_list); j++ {\n            if i != j {\n                if len(test_list[i]) == len(test_list[j]) {\n                    for k := 0; k < len(test_list[i]); k++ {\n                        if test_list[i][k] != test_list[j][k] {\n                            unique_list = false\n                        }\n                    }\n                }\n            }\n        }\n        if unique_list == true {\n            unique_list_count += 1\n        }\n    }\n    return unique_list_count\n}\n",
    "    // Create a map to store the frequency of each list.\n    freq_map := make(map[string]int)\n\n    // Iterate over the list.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_str := fmt.Sprintf(\"%v\", list)\n\n        // Increment the frequency of the list.\n        freq_map[list_str]++\n    }\n\n    // Return the number of unique lists.\n    return len(freq_map)\n}\n",
    "    // Create a map to store the frequency of each list.\n    freq_map := make(map[string]int)\n    // Iterate over the list.\n    for _, list := range test_list {\n        // Convert the list to a string.\n        list_string := fmt.Sprint(list)\n        // Check if the list is already in the map.\n        if _, ok := freq_map[list_string]; ok {\n            // If it is, increment the frequency.\n            freq_map[list_string] += 1\n        } else {\n            // If it isn't, add it to the map with a frequency of 1.\n            freq_map[list_string] = 1\n        }\n    }\n    // Return the length of the map.\n    return len(freq_map)\n}\n",
    "    var unique_lists []interface{}\n    for _, list := range test_list {\n        if !contains(unique_lists, list) {\n            unique_lists = append(unique_lists, list)\n        }\n    }\n    return len(unique_lists)\n}\n"
  ]
}