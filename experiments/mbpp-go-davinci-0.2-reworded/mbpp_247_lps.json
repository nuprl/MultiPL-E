{
  "name": "mbpp_247_lps",
  "language": "go_test.go",
  "prompt": "package lps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nfunc lps(str string) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "reworded",
  "tests": "func TestLps(t *testing.T) {\n  candidate := lps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TENS FOR TENS\"), expected: 5 },\n     { actual: candidate(\"CARDIO FOR CARDS\"), expected: 7 },\n     { actual: candidate(\"PART OF THE JOURNEY IS PART\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(str) == 0 {\n        return 0\n    }\n\n    var max int\n    for i := 0; i < len(str); i++ {\n        for j := i + 1; j <= len(str); j++ {\n            if isPalindrome(str[i:j]) && j - i > max {\n                max = j - i\n            }\n        }\n    }\n\n    return max\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    // dp[i][j] = length of longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := range dp {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if str == \"\" {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    var lpsLength int\n    for i := 0; i < len(str); i++ {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                if j - i == 1 {\n                    lpsLength = 2\n                } else {\n                    lpsLength = 2 + lps(str[i+1:j])\n                }\n            }\n        }\n    }\n    return lpsLength\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    // dp[i][j] = the length of the longest palindromic subsequence in the string str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    var max int\n    for i := 0; i < len(str); i++ {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                if j - i == 1 {\n                    max = 2\n                } else {\n                    max = 2 + lps(str[i+1:j])\n                }\n            }\n        }\n    }\n    return max\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence of str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][n-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    // dp[i][j] = longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][n-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    var dp [][]int = make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][len(str) - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    // dp[i][j] is the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := range dp {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[0:len(str) - 1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    // dp[i][j] = length of longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := range dp {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := 0; i < len(str); i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= len(str); l++ {\n        for i := 0; i < len(str) - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n        dp[i][i] = 1\n    }\n    for i := len(str) - 2; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][len(str) - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) <= 1 {\n        return len(str)\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    dp := make([][]int, n)\n    for i := range dp {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    // dp[i][j] = length of the longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    dp := make([][]int, len(str))\n    for i := range dp {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := 0; i < len(str); i++ {\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][len(str) - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    // dp[i][j] means the longest palindromic subsequence of str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][n-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    // dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    // if str[i] == str[j] {\n    //     dp[i][j] = dp[i+1][j-1] + 2\n    // }\n    dp := make([][]int, len(str))\n    for i := range dp {\n        dp[i] = make([]int, len(str))\n    }\n    for i := len(str) - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][len(str)-1]\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    // dp[i][j] is the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := 0; i < len(str); i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= len(str); l++ {\n        for i := 0; i < len(str) - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    // dp[i][j] is the length of the longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, n)\n    for i := range dp {\n        dp[i] = make([]int, n)\n    }\n\n    // base case\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    // dp[i][j] = dp[i+1][j-1] + 2 if str[i] == str[j]\n    // dp[i][j] = max(dp[i+1][j], dp[i][j-1]) if str[i] != str[j]\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][n-1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[0:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 2; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][len(str) - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := 0; i < len(str); i++ {\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][len(str) - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[n-1] {\n        return 2 + lps(str[1:n-1])\n    }\n    return max(lps(str[1:]), lps(str[:n-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in substring(i, j)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    // dp[i][j] is the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[n-1] {\n        return 2 + lps(str[1:n-1])\n    }\n    return max(lps(str[1:]), lps(str[:n-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    var dp [][]int\n    for i := 0; i < len(str); i++ {\n        dp = append(dp, make([]int, len(str)))\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 2; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][len(str) - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[n-1] {\n        return 2 + lps(str[1:n-1])\n    }\n    return max(lps(str[1:]), lps(str[:n-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[0:len(str)-1]))\n}\n",
    "    // dp[i][j] means the longest palindromic subsequence of str[i:j+1]\n    // dp[i][j] = dp[i+1][j-1] + 2 if str[i] == str[j]\n    // dp[i][j] = max(dp[i+1][j], dp[i][j-1]) if str[i] != str[j]\n    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := n - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][n-1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n    }\n\n    // Initialize dp[i][i]\n    for i := 0; i < len(str); i++ {\n        dp[i][i] = 1\n    }\n\n    // dp[i][j] = dp[i+1][j-1] + 2 if str[i] == str[j]\n    // dp[i][j] = max(dp[i+1][j], dp[i][j-1]) otherwise\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[0:len(str) - 1]), lps(str[1:len(str)]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) <= 1 {\n        return len(str)\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    // dp[i][j] is the length of the longest palindromic subsequence in the substring str[i:j]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    // Initialize dp[i][i]\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    // Fill dp[i][j] from bottom-right to top-left\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    // dp[i][j] is the length of the longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[0:len(str) - 1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[0:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    // base case\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][n-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    // Initialize the dp table\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    // dp[i][j] = length of longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := 0; i < len(str); i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= len(str); l++ {\n        for i := 0; i < len(str)-l+1; i++ {\n            j := i+l-1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[0:len(str) - 1]), lps(str[1:len(str)]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[0:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := 0; i < n - 1; i++ {\n        if str[i] == str[i + 1] {\n            dp[i][i + 1] = 2\n        } else {\n            dp[i][i + 1] = 1\n        }\n    }\n    for l := 3; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    return lps_recursive(str, 0, len(str) - 1)\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    var dp [][]int\n    for i := 0; i < n; i++ {\n        dp = append(dp, make([]int, n))\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    // dp[i][j] means the length of the longest palindromic subsequence in the given string from i to j\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    l := len(str)\n    if l <= 1 {\n        return l\n    }\n\n    dp := make([][]int, l)\n    for i := 0; i < l; i++ {\n        dp[i] = make([]int, l)\n        dp[i][i] = 1\n    }\n\n    for i := l - 2; i >= 0; i-- {\n        for j := i + 1; j < l; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][l - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n"
  ]
}