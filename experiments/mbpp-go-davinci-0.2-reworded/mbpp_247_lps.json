{
  "name": "mbpp_247_lps",
  "language": "go_test.go",
  "prompt": "package lps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nfunc lps(str string) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "reworded",
  "tests": "func TestLps(t *testing.T) {\n  candidate := lps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TENS FOR TENS\"), expected: 5 },\n     { actual: candidate(\"CARDIO FOR CARDS\"), expected: 7 },\n     { actual: candidate(\"PART OF THE JOURNEY IS PART\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(str) == 0 {\n        return 0\n    }\n\n    var max int\n    for i := 0; i < len(str); i++ {\n        for j := i + 1; j <= len(str); j++ {\n            if isPalindrome(str[i:j]) && j - i > max {\n                max = j - i\n            }\n        }\n    }\n\n    return max\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str) - 1]))\n    }\n}\n",
    "    // dp[i][j] = length of longest palindromic subsequence in str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := range dp {\n        dp[i] = make([]int, len(str))\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        dp[i][i] = 1\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if str == \"\" {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    var lpsLength int\n    for i := 0; i < len(str); i++ {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                if j - i == 1 {\n                    lpsLength = 2\n                } else {\n                    lpsLength = 2 + lps(str[i+1:j])\n                }\n            }\n        }\n    }\n    return lpsLength\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    // dp[i][j] = the length of the longest palindromic subsequence in the string str[i:j+1]\n    dp := make([][]int, len(str))\n    for i := 0; i < len(str); i++ {\n        dp[i] = make([]int, len(str))\n        dp[i][i] = 1\n    }\n\n    for i := len(str) - 1; i >= 0; i-- {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][len(str)-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i < n - l + 1; i++ {\n            j := i + l - 1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str)-1] {\n        return 2 + lps(str[1:len(str)-1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str)-1]))\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n\n    var max int\n    for i := 0; i < len(str); i++ {\n        for j := i + 1; j < len(str); j++ {\n            if str[i] == str[j] {\n                if j - i == 1 {\n                    max = 2\n                } else {\n                    max = 2 + lps(str[i+1:j])\n                }\n            }\n        }\n    }\n    return max\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        }\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return 2 + lps(str[1:len(str) - 1])\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n\n    if len(str) == 1 {\n        return 1\n    }\n\n    if str[0] == str[len(str) - 1] {\n        return lps(str[1:len(str) - 1]) + 2\n    }\n\n    return max(lps(str[1:]), lps(str[:len(str) - 1]))\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence of str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n\n    return dp[0][n-1]\n}\n",
    "    if len(str) == 0 {\n        return 0\n    }\n    if len(str) == 1 {\n        return 1\n    }\n    if len(str) == 2 {\n        if str[0] == str[1] {\n            return 2\n        } else {\n            return 1\n        }\n    }\n    if str[0] == str[len(str)-1] {\n        return lps(str[1:len(str)-1]) + 2\n    } else {\n        return max(lps(str[1:]), lps(str[:len(str)-1]))\n    }\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n\n    // dp[i][j] means the length of the longest palindromic subsequence in the substring str[i:j+1]\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n",
    "    n := len(str)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < n; i++ {\n        dp[i][i] = 1\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := i + 1; j < n; j++ {\n            if str[i] == str[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    return dp[0][n - 1]\n}\n"
  ]
}