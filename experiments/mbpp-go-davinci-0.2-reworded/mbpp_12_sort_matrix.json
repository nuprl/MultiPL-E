{
  "name": "mbpp_12_sort_matrix",
  "language": "go_test.go",
  "prompt": "package sort_matrix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a given matrix in ascending order according to the sum of its rows.\nfunc sort_matrix(M [][]int) [][]int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "reworded",
  "tests": "func TestSort_Matrix(t *testing.T) {\n  candidate := sort_matrix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{1, 1, 1}}), expected: [][]int{[]int{1, 1, 1}, []int{1, 2, 3}, []int{2, 4, 5}} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{-2, 4, -5}, []int{1, -1, 1}}), expected: [][]int{[]int{-2, 4, -5}, []int{1, -1, 1}, []int{1, 2, 3}} },\n     { actual: candidate([][]int{[]int{5, 8, 9}, []int{6, 4, 3}, []int{2, 1, 4}}), expected: [][]int{[]int{2, 1, 4}, []int{6, 4, 3}, []int{5, 8, 9}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // sort by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    // sort by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by sum of rows\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[0]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(sums); i++ {\n        for j := i + 1; j < len(sums); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // TODO: implement\n    return [][]int{}\n}\n",
    "    // sort the rows by sum\n    sums := make([]int, len(M))\n    for i, row := range M {\n        for _, v := range row {\n            sums[i] += v\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // calculate the sum of each row\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    // sort the sums\n    for i := 0; i < len(sums); i++ {\n        for j := i + 1; j < len(sums); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    if len(M) == 0 {\n        return M\n    }\n    if len(M[0]) == 0 {\n        return M\n    }\n    rows := len(M)\n    cols := len(M[0])\n    sums := make([]int, rows)\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < rows; i++ {\n        for j := i + 1; j < rows; j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    if len(M) == 0 {\n        return M\n    }\n    if len(M[0]) == 0 {\n        return M\n    }\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        sums[i] = 0\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    row_sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        row_sums[i] = 0\n        for j := 0; j < len(M[i]); j++ {\n            row_sums[i] += M[i][j]\n        }\n    }\n    // sort row_sums\n    for i := 0; i < len(row_sums); i++ {\n        for j := i + 1; j < len(row_sums); j++ {\n            if row_sums[i] > row_sums[j] {\n                row_sums[i], row_sums[j] = row_sums[j], row_sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // TODO: implement\n    return M\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    // sort rows by sum\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(sums); i++ {\n        for j := i + 1; j < len(sums); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i; j < len(M); j++ {\n            if sum_row(M[i]) > sum_row(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    rows := len(M)\n    cols := len(M[0])\n    sums := make([]int, rows)\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < rows; i++ {\n        for j := i + 1; j < rows; j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                for k := 0; k < cols; k++ {\n                    M[i][k], M[j][k] = M[j][k], M[i][k]\n                }\n            }\n        }\n    }\n    return M\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    n := len(M)\n    sums := make([]int, n)\n    for i := 0; i < n; i++ {\n        sums[i] = 0\n        for j := 0; j < n; j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort rows by sum\n    sums := make([]int, len(M))\n    for i, row := range M {\n        for _, v := range row {\n            sums[i] += v\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n"
  ]
}