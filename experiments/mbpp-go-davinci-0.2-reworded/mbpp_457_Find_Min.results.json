{
  "name": "mbpp_457_Find_Min",
  "language": "go_test.go",
  "prompt": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py",
  "prompt_terminology": "reworded",
  "tests": "func TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdkitxg47_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb61t6gfx_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbov0p5qy_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7lzzwsm7_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(\"Not a list\")\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptwkpbpgg_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := lst[0]\n            for _, item := range lst {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa155duzg_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_len := len(lst.([]interface{}))\n        min_lst := lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = Find_Min(v).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt88bkog9_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if v < min_string {\n                min_string = v\n            }\n        }\n        return min_string\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1rgqkkis_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return []int{}\n        } else {\n            min_lst := lst_int[0]\n            for _, v := range lst_int {\n                if len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return []string{}\n        } else {\n            min_lst := lst_str[0]\n            for _, v := range lst_str {\n                if len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphtpumy6y_test.go:18:23: invalid argument v (type int) for len\n/tmp/tmphtpumy6y_test.go:18:32: invalid argument min_lst (type int) for len\n/tmp/tmphtpumy6y_test.go:51:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        if len(lst_lst) == 0 {\n            return lst\n        }\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst[1:] {\n            min_lst = Find_Min([]interface{}{min_lst, lst}).([]interface{})\n        }\n        return min_lst\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_76qkilv_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    default:\n        fmt.Println(\"Invalid type\")\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphxp5hjnu_test.go:53:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, l := range lst.([]interface{}) {\n            if l_len := len(l.([]interface{})); l_len < min_len {\n                min_len = l_len\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmkr5447w_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp539ynmkf_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            } else {\n                min_lst := lst.([]interface{})[0]\n                for i := 1; i < lst_len; i++ {\n                    if len(lst.([]interface{})[i].([]interface{})) < len(min_lst.([]interface{})) {\n                        min_lst = lst.([]interface{})[i]\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mzbau10_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfabj06kh_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdhms3i9i_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxhgb1nkf_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1kvlvpz0_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgnwx8tzy_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprp359g2y_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4t81k7xw_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        } else if len(lst_) == 1 {\n            return lst_[0]\n        } else {\n            return Find_Min(lst_[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprl0sslpl_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9r58cjkn_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbrocuext_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpbrocuext_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpbrocuext_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw60n667a_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoxpbyuh4_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjywxce2w_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoxpbyuh4_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjertllbf_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, e := range lst.([]interface{}) {\n            if len(e.([]interface{})) < len(min.([]interface{})) {\n                min = e\n            }\n        }\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjbwl3c4_test.go:32:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw60n667a_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            min := Find_Min(lst[0])\n            for _, v := range lst[1:] {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplvp95buu_test.go:39:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min.([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyl4wzt6o_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcaaofjel_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgtrx6oq8_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, e := range lst {\n            if len(e.([]interface{})) < len(min.([]interface{})) {\n                min = e\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ztahdjb_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_uvzfhwb_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, v := range lst_l {\n            min_l = Find_Min([]interface{}{min_l, v}).(interface{})\n        }\n        return min_l\n    case int:\n        return lst\n    case string:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphv4cqpu8_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{})[1:] {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7z7w5g7u_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_uvzfhwb_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps7web4i0_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ol2odzi_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    var min_len int\n    switch lst.(type) {\n    case []int:\n        for _, v := range lst.([]int) {\n            if min_len == 0 || min_len > len(v) {\n                min = v\n                min_len = len(v)\n            }\n        }\n    case []string:\n        for _, v := range lst.([]string) {\n            if min_len == 0 || min_len > len(v) {\n                min = v\n                min_len = len(v)\n            }\n        }\n    case []float64:\n        for _, v := range lst.([]float64) {\n            if min_len == 0 || min_len > len(v) {\n                min = v\n                min_len = len(v)\n            }\n        }\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3v7pkq6x_test.go:15:45: invalid argument v (type int) for len\n/tmp/tmp3v7pkq6x_test.go:17:30: invalid argument v (type int) for len\n/tmp/tmp3v7pkq6x_test.go:29:45: invalid argument v (type float64) for len\n/tmp/tmp3v7pkq6x_test.go:31:30: invalid argument v (type float64) for len\n/tmp/tmp3v7pkq6x_test.go:47:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            }\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpse3ps3tm_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        } else {\n            min_ := lst_[0]\n            for _, v := range lst_[1:] {\n                if len(v.([]interface{})) < len(min_.([]interface{})) {\n                    min_ = v\n                }\n            }\n            return min_\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_rb2t_7e_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7lzzwsm7_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, i := range lst_int {\n            if i < min_int {\n                min_int = i\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, i := range lst_str {\n            if len(i) < len(min_str) {\n                min_str = i\n            }\n        }\n        return min_str\n    default:\n        return \"Invalid input type\"\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqnvemp3__test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := Find_Min(lst[0]).([]interface{})\n            for _, item := range lst[1:] {\n                if len(Find_Min(item).([]interface{})) < len(min) {\n                    min = Find_Min(item).([]interface{})\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6_760bid_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_len := len(lst.([]interface{}))\n        min_lst := lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2a9jicz_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        panic(fmt.Sprintf(\"Find_Min: %v is not a list\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyvcgkht__test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp77cfk384_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, i := range lst {\n            if len(i.([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptxe28rpz_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    default:\n        min = lst\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdq4s7j9i_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            min := Find_Min(lst[0])\n            for _, v := range lst[1:] {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplvp95buu_test.go:39:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt135hsp8_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppgg3ck4i_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprp359g2y_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3qz7ir0e_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxhgb1nkf_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            } else if lst_len == 1 {\n                return lst.([]interface{})[0]\n            } else {\n                min_len := len(lst.([]interface{})[0].([]interface{}))\n                min_lst := lst.([]interface{})[0]\n                for _, item := range lst.([]interface{})[1:] {\n                    if len(item.([]interface{})) < min_len {\n                        min_len = len(item.([]interface{}))\n                        min_lst = item\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphpmgg26s_test.go:42:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                } else {\n                    if len(v.([]interface{})) < len(min.([]interface{})) {\n                        min = v\n                    }\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8144zphm_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppgg3ck4i_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbw2j05ml_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if len(v) < len(min_str) {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqksiq9u2_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4v3ia_pb_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdo8rxxmt_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        } else {\n            min := Find_Min(lst[0]).([]interface{})\n            for _, v := range lst[1:] {\n                if len(v.([]interface{})) < len(min) {\n                    min = v.([]interface{})\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqa1l52ut_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := Find_Min(lst.([]interface{})[0])\n        for _, v := range lst.([]interface{})[1:] {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = Find_Min(v)\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig07nrmo_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        } else {\n            min := lst[0]\n            for _, e := range lst {\n                if len(e.([]interface{})) < len(min.([]interface{})) {\n                    min = e\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpze4jj_a6_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{})[1:] {\n                if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx001vmkp_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbw2j05ml_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyp6fd95b_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        if len(lst_l) == 0 {\n            return lst\n        } else {\n            min_l := lst_l[0]\n            for _, l := range lst_l {\n                if len(l.([]interface{})) < len(min_l.([]interface{})) {\n                    min_l = l\n                }\n            }\n            return min_l\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpra8on08s_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            } else {\n                return lst\n            }\n        case []int:\n            if len(lst.([]int)) == 0 {\n                return nil\n            } else {\n                return lst\n            }\n        case []string:\n            if len(lst.([]string)) == 0 {\n                return nil\n            } else {\n                return lst\n            }\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc1hq_7ax_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbw2j05ml_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{}) != nil {\n                if len(min.([]interface{})) > len(v.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkjb11_o8_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_len := len(lst.([]interface{})[0].([]interface{}))\n            min_lst := lst.([]interface{})[0]\n            for _, sublst := range lst.([]interface{})[1:] {\n                sublst_len := len(sublst.([]interface{}))\n                if sublst_len < min_len {\n                    min_len = sublst_len\n                    min_lst = sublst\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6394ogl1_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                min := Find_Min(lst.([]interface{})[0])\n                for _, v := range lst.([]interface{})[1:] {\n                    if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                        min = Find_Min(v)\n                    }\n                }\n                return min\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp000vm88b_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            sub_lst := lst.([]interface{})\n            min_lst := sub_lst[0]\n            for _, sub_lst := range sub_lst {\n                if len(Find_Min(sub_lst).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = sub_lst\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld9iwts6_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch v := lst.(type) {\n    case []interface{}:\n        if len(v) == 0 {\n            return nil\n        }\n        min := v[0]\n        for _, item := range v {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbugo9ei8_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                } else {\n                    if len(v.([]interface{})) < len(min.([]interface{})) {\n                        min = v\n                    }\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8144zphm_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpypuqk7pm_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, i := range lst_int {\n            if i < min_int {\n                min_int = i\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, s := range lst_str {\n            if len(s) < len(min_str) {\n                min_str = s\n            }\n        }\n        return min_str\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2iwfn4le_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min_len := len(lst.([]interface{})[0].([]interface{}))\n        min_lst := lst.([]interface{})[0]\n        for _, l := range lst.([]interface{}) {\n            if len(l.([]interface{})) < min_len {\n                min_len = len(l.([]interface{}))\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp01dw3xd0_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return []interface{}{}\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        case [][]interface{}:\n            if len(lst.([][]interface{})) == 0 {\n                return []interface{}{}\n            } else {\n                return Find_Min(lst.([][]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc5vtn3m8_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnq6irfbq_test.go:12:20: undefined: Find_Min_int\n/tmp/tmpnq6irfbq_test.go:14:20: undefined: Find_Min_string\n/tmp/tmpnq6irfbq_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdkitxg47_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min_lst := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsnluytol_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7lzzwsm7_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            } else {\n                min := lst.([]interface{})[0]\n                for _, v := range lst.([]interface{}) {\n                    if len(v.([]interface{})) < len(min.([]interface{})) {\n                        min = v\n                    }\n                }\n                return min\n            }\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn9inr92g_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_len := lst_len\n            min_lst := lst\n            for _, item := range lst.([]interface{}) {\n                if item_len := len(item.([]interface{})); item_len < min_len {\n                    min_len = item_len\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj_74vo_9_test.go:42:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{})[1:] {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpin6wh3i0_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        for _, v := range lst.([]int) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        for _, v := range lst.([]string) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []float64:\n        var min_lst []float64\n        for _, v := range lst.([]float64) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppoie30xh_test.go:16:41: invalid argument v (type int) for len\n/tmp/tmppoie30xh_test.go:17:25: cannot use v (type int) as type []int in assignment\n/tmp/tmppoie30xh_test.go:27:25: cannot use v (type string) as type []string in assignment\n/tmp/tmppoie30xh_test.go:36:41: invalid argument v (type float64) for len\n/tmp/tmppoie30xh_test.go:37:25: cannot use v (type float64) as type []float64 in assignment\n/tmp/tmppoie30xh_test.go:55:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, i := range lst.([]interface{}) {\n            if len(Find_Min(i).([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjrztgles_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, e := range lst.([]interface{})[1:] {\n            if len(Find_Min(e).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = e\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn6h5v9qm_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, i := range lst_int {\n            if i < min_int {\n                min_int = i\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, s := range lst_str {\n            if s < min_str {\n                min_str = s\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, f := range lst_float {\n            if f < min_float {\n                min_float = f\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvksrj581_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return lst\n        } else {\n            min_lst := lst_[0]\n            for _, v := range lst_ {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb2430eic_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk2j4csla_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        } else {\n            min := lst[0]\n            for _, v := range lst {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiq9pb0eq_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min := lst_[0]\n        for _, e := range lst_[1:] {\n            if len(Find_Min(e).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = e\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp51jef_hr_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []float64:\n            return Find_Min_float64(lst.([]float64))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpknme4xsd_test.go:12:20: undefined: Find_Min_int\n/tmp/tmpknme4xsd_test.go:14:20: undefined: Find_Min_float64\n/tmp/tmpknme4xsd_test.go:16:20: undefined: Find_Min_string\n/tmp/tmpknme4xsd_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl5h01075_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw60n667a_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min_len int = len(lst.([]interface{}))\n            var min_lst interface{} = lst\n            for _, v := range lst.([]interface{}) {\n                if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                    min_len = v_len\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9p7sewt5_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        case int:\n            return lst\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1emo4_mr_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, i := range lst.([]interface{}) {\n            if len(Find_Min(i).([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7fds93uu_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgt8_5q1u_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_lst = sub_lst\n                min_len = len(sub_lst.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwgtklm3n_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm4ihfzfu_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := Find_Min(lst_[0])\n        for _, item := range lst_[1:] {\n            min_ = Min(min_, Find_Min(item))\n        }\n        return min_\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpng5dhkuv_test.go:18:20: undefined: Min\n/tmp/tmpng5dhkuv_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_l := lst.([]interface{})\n            if len(lst_l) == 0 {\n                return lst\n            } else {\n                min_lst := lst_l[0]\n                for _, sub_lst := range lst_l[1:] {\n                    if len(Find_Min(sub_lst).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                        min_lst = sub_lst\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphpx61m_1_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        fmt.Println(\"Unsupported type.\")\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp174g_3xn_test.go:12:16: undefined: Find_Min_int\n/tmp/tmp174g_3xn_test.go:14:16: undefined: Find_Min_string\n/tmp/tmp174g_3xn_test.go:16:16: undefined: Find_Min_float64\n/tmp/tmp174g_3xn_test.go:32:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_lst = sub_lst\n                min_len = len(sub_lst.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwgtklm3n_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpab0vbphi_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpof4lnq_k_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbrocuext_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpbrocuext_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpbrocuext_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp80qprl3n_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min_len = len(item.([]interface{}))\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mrkjy_w_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    // Your code here\n    return nil\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7842ii8m_test.go:23:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := lst_[0]\n        for _, v := range lst_[1:] {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_).([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbajr9bv7_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyhd8cn0q_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfabj06kh_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    // Your code goes here\n    return nil\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxa9v14ft_test.go:23:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbw2j05ml_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return nil\n        }\n        min := lst_int[0]\n        for _, v := range lst_int {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return nil\n        }\n        min := lst_str[0]\n        for _, v := range lst_str {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst_lst := lst.([][]int)\n        if len(lst_lst) == 0 {\n            return nil\n        }\n        min := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8gg881q2_test.go:61:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min_sublist := lst[0]\n        for _, sublist := range lst[1:] {\n            if len(sublist.([]interface{})) < len(min_sublist.([]interface{})) {\n                min_sublist = sublist\n            }\n        }\n        return min_sublist\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx8e9_iiu_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7lzzwsm7_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoxpbyuh4_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, sub := range lst.([]interface{}) {\n            if len(sub.([]interface{})) < len(min.([]interface{})) {\n                min = sub\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3ayu26hl_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            return Find_Min(lst[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmf66hyu4_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min_len = len(item.([]interface{}))\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7y87128i_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, i := range lst.([]interface{}) {\n            if len(i.([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplf1l03aa_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgbyxa5lb_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpgbyxa5lb_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpgbyxa5lb_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpgbyxa5lb_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpgbyxa5lb_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbrocuext_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpbrocuext_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpbrocuext_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len = len(lst.([]interface{}))\n        var min_lst = lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if v_lst, ok := v.([]interface{}); ok {\n                if v_len := len(v_lst); v_len < min_len {\n                    min_len = v_len\n                    min_lst = v_lst\n                }\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvp4jpj74_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnk5_dq4q_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, elem := range lst {\n            if len(elem.([]interface{})) < len(min.([]interface{})) {\n                min = elem\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpywzubqh2_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            return find_min_list(lst.([]interface{}))\n        case []int:\n            return find_min_list(lst.([]int))\n        case []string:\n            return find_min_list(lst.([]string))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi9cc91kp_test.go:12:20: undefined: find_min_list\n/tmp/tmpi9cc91kp_test.go:14:20: undefined: find_min_list\n/tmp/tmpi9cc91kp_test.go:16:20: undefined: find_min_list\n/tmp/tmpi9cc91kp_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return nil\n            } else if len(lst) == 1 {\n                return lst[0]\n            } else {\n                min := Find_Min(lst[0])\n                for i := 1; i < len(lst); i++ {\n                    if len(Find_Min(lst[i]).([]interface{})) < len(min.([]interface{})) {\n                        min = lst[i]\n                    }\n                }\n                return min\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcg59xnhh_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpflbxue7c_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpof4lnq_k_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps7web4i0_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_l := lst.([]interface{})\n            if len(lst_l) == 0 {\n                return lst\n            } else {\n                min_l := lst_l[0]\n                for _, l := range lst_l {\n                    min_l = Find_Min([]interface{}{min_l, l}).([]interface{})[0]\n                }\n                return min_l\n            }\n        case int:\n            return lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxtp2t64q_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case [][]int:\n            return Find_Min_int_slice(lst.([][]int))\n        case [][]string:\n            return Find_Min_string_slice(lst.([][]string))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpux4yrhhs_test.go:12:20: undefined: Find_Min_int\n/tmp/tmpux4yrhhs_test.go:14:20: undefined: Find_Min_string\n/tmp/tmpux4yrhhs_test.go:16:20: undefined: Find_Min_int_slice\n/tmp/tmpux4yrhhs_test.go:18:20: undefined: Find_Min_string_slice\n/tmp/tmpux4yrhhs_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuxj17kao_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfabj06kh_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf1w0dnbk_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp99hi2b1w_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, item := range lst.([]interface{}) {\n            if min == nil {\n                min = item\n                min_len = len(item.([]interface{}))\n            } else {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4b8ujwns_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        } else if len(lst) == 1 {\n            return lst[0]\n        } else {\n            min := Find_Min(lst[0])\n            for _, v := range lst[1:] {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplstkmkqz_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch v := lst.(type) {\n    case []interface{}:\n        min := v[0]\n        for _, x := range v {\n            if len(x.([]interface{})) < len(min.([]interface{})) {\n                min = x\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx_swkmtb_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if len(v) < len(min_str) {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqksiq9u2_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbw2j05ml_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgznzjw7p_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl5h01075_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbrocuext_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpbrocuext_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpbrocuext_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, sub := range lst.([]interface{}) {\n            if len(sub.([]interface{})) < len(min.([]interface{})) {\n                min = sub\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz1hghdt7_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst\n        } else {\n            min_len := lst_len\n            min_lst := lst\n            for _, sub_lst := range lst.([]interface{}) {\n                sub_lst_len := len(sub_lst.([]interface{}))\n                if sub_lst_len < min_len {\n                    min_len = sub_lst_len\n                    min_lst = sub_lst\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5xi7f8_o_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        min := l[0]\n        for _, v := range l {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi0m6og62_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnk5_dq4q_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, e := range lst.([]interface{}) {\n            if len(e.([]interface{})) < len(min.([]interface{})) {\n                min = e\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptc6rf5ra_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, item := range lst.([]interface{}) {\n            if min == nil {\n                min = item\n                min_len = len(item.([]interface{}))\n            } else {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4b8ujwns_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return lst\n            } else {\n                min_lst := lst[0]\n                for _, l := range lst {\n                    if len(l.([]interface{})) < len(min_lst.([]interface{})) {\n                        min_lst = l\n                    }\n                }\n                return min_lst\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppj0mos1a_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_len := lst_len\n            min_lst := lst\n            for _, elem := range lst.([]interface{}) {\n                if elem_len := len(Find_Min(elem).([]interface{})); elem_len < min_len {\n                    min_len = elem_len\n                    min_lst = elem\n                }\n            }\n            return min_lst\n        }\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiw2r0gri_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(min_lst.([]interface{})) > len(v.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123690,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp42x8w5jt_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_lst = sub_lst\n                min_len = len(sub_lst.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwgtklm3n_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyxo38fl5_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min_lst := lst[0]\n        for _, v := range lst {\n            min_lst = Find_Min([]interface{}{min_lst, v}).([]interface{})\n        }\n        return min_lst\n    case int:\n        return []interface{}{lst}\n    default:\n        panic(\"Invalid type\")\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphkf44hii_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123684,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl5h01075_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for i := 1; i < lst_len; i++ {\n                if len(Find_Min(lst.([]interface{})[i]).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = lst.([]interface{})[i]\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5glf4rwt_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                } else if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjr7ln3hw_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, elem := range lst_l {\n            min_l = Find_Min([]interface{}{min_l, elem}).([]interface{})\n        }\n        return min_l\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Find_Min: unexpected type %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl6nyqxnt_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_cac3oms_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_len := len(lst.([]interface{}))\n        min_lst := lst.([]interface{})\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v.([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi8x0wln8_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            }\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{})[1:] {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        default:\n            return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprcwmlluo_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            switch sub_lst.(type) {\n            case []interface{}:\n                if len(sub_lst.([]interface{})) < min_len {\n                    min_lst = sub_lst\n                    min_len = len(sub_lst.([]interface{}))\n                }\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6kpcxkdf_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []int:\n        if len(lst.([]int)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []float64:\n        if len(lst.([]float64)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    case []string:\n        if len(lst.([]string)) == 0 {\n            return nil\n        } else {\n            return lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqcbksthr_test.go:49:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        } else if lst_len == 1 {\n            return lst.([]interface{})[0]\n        } else {\n            min_len := len(lst.([]interface{})[0].([]interface{}))\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{})[1:] {\n                if len(v.([]interface{})) < min_len {\n                    min_len = len(v.([]interface{}))\n                    min_lst = v\n                }\n            }\n            return min_lst\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp50hqdy39_test.go:42:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    case int:\n        return []interface{}{}\n    default:\n        panic(\"Unknown type\")\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgs77y487_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []float64:\n        lst := lst.([]float64)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := len(lst[0])\n        for _, v := range lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        for _, v := range lst {\n            if len(v) == min {\n                return v\n            }\n        }\n        return nil\n    case [][]string:\n        lst := lst.([][]string)\n        if len(lst) == 0 {\n            return lst\n        }\n        min := len(lst[0])\n        for _, v := range lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        for _, v := range lst {\n            if len(v) == min {\n                return v\n            }\n        }\n        return nil\n    case [][]float64:\n        lst := lst.([][]float64)\n       \nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123691,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpun64sbri_test.go:84:6: expected '(', found TestFind_Min\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        } else {\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9r58cjkn_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123687,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyhd8cn0q_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxnj3ishj_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        if len(lst_int) == 0 {\n            return []int{}\n        }\n        min_lst := lst_int[0]\n        for _, item := range lst_int {\n            if len(item) < len(min_lst) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    case []string:\n        lst_str := lst.([]string)\n        if len(lst_str) == 0 {\n            return []string{}\n        }\n        min_lst := lst_str[0]\n        for _, item := range lst_str {\n            if len(item) < len(min_lst) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj7upqr4i_test.go:18:19: invalid argument item (type int) for len\n/tmp/tmpj7upqr4i_test.go:18:31: invalid argument min_lst (type int) for len\n/tmp/tmpj7upqr4i_test.go:49:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{}\n        } else {\n            min := l[0]\n            for _, e := range l {\n                if len(e.([]interface{})) < len(min.([]interface{})) {\n                    min = e\n                }\n            }\n            return min\n        }\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps19c_bv8_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqi7ccrqb_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return lst.([]interface{})[0]\n        }\n    case [][]interface{}:\n        if len(lst.([][]interface{})) == 0 {\n            return []interface{}{}\n        } else {\n            return lst.([][]interface{})[0]\n        }\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsm6t9vj9_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123678,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbrocuext_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpbrocuext_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpbrocuext_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpavezf3lz_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppgg3ck4i_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[1:])\n        }\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"Unknown type: %T\", lst))\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510636,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfabj06kh_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, v := range lst_l {\n            if len(v.([]interface{})) < len(min_l.([]interface{})) {\n                min_l = v\n            }\n        }\n        return min_l\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq4usbe0b_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]interface{})[1:])\n            }\n        case []int:\n            if len(lst.([]int)) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]int)[1:])\n            }\n        case []string:\n            if len(lst.([]string)) == 0 {\n                return lst\n            } else {\n                return Find_Min(lst.([]string)[1:])\n            }\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplt_2o6jc_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptcxzt3a8_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123681,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdo8rxxmt_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for i := 1; i < lst_len; i++ {\n            if len(Find_Min(lst.([]interface{})[i]).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = lst.([]interface{})[i]\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123692,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr6zrbil2_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, sub_lst := range lst.([]interface{}) {\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        panic(\"Invalid input\")\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123693,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw3f8_ic4_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123693,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6yd1aw1r_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var lst_len = len(lst.([]interface{}))\n        var min_len = lst_len\n        var min_lst = lst\n        for i := 0; i < lst_len; i++ {\n            var sub_lst = Find_Min(lst.([]interface{})[i])\n            if len(sub_lst.([]interface{})) < min_len {\n                min_len = len(sub_lst.([]interface{}))\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123693,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpncaetaln_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        min_lst := lst[0]\n        for _, item := range lst {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123693,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp8cvk22__test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}