{
  "name": "mbpp_89_closest_num",
  "language": "go_test.go",
  "prompt": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py",
  "prompt_terminology": "reworded",
  "tests": "func TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var num int\n    var num_list []int\n    var num_list_len int\n    var num_list_len_half int\n    var num_list_len_half_floor int\n    var num_list_len_half_ceil int\n    var num_list_len_half_floor_val int\n    var num_list_len_half_ceil_val int\n    var num_list_len_half_floor_diff int\n    var num_list_len_half_ceil_diff int\n\n    for i = 1; i <= N; i++ {\n        num = i\n        for j = 0; j < len(num_list); j++ {\n            if num < num_list[j] {\n                num_list = append(num_list[:j], append([]int{num}, num_list[j:]...)...)\n                break\n            }\n        }\n        if j == len(num_list) {\n            num_list = append(num_list, num)\n        }\n    }\n\n    num_list_len = len(num_list)\n    num_list_len_half = num_list_len / 2\n    num_list_len_half_floor = num_list_len_half\n    num_list_len_half_ceil = num_list_len_half\n    if num_list_len % 2 == 0 {\n        num_list_len_half_floor--\n    }\n    num_list_len_half_floor_val = num_list[num_list_len_half_floor]\n    num_list_len_half_ceil_val = num_list[num_list_len_half_ceil]\n    num_list_len_half_floor_diff = N - num_list_len_half_floor_val\n    num_list_len_half_ceil_diff = num_list_len_half_ceil_val - N\n    if num_list_len_half_floor_diff < num_list_len_half_ceil_diff {\n        return num_list_len_half_floor_val\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwjjfd8hx_test.go:51:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right side.\n    // If there is no 1, return -1.\n    var mask int = 1\n    for mask < N {\n        if N & mask == mask {\n            break\n        }\n        mask <<= 1\n    }\n\n    if mask == N {\n        return -1\n    }\n\n    // Find the first 0 from the right side.\n    var zero_mask int = 1\n    for zero_mask < N {\n        if N & zero_mask == 0 {\n            break\n        }\n        zero_mask <<= 1\n    }\n\n    // Set the first 0 to 1.\n    N |= zero_mask\n    // Set the first 1 to 0.\n    N &= ^mask\n    // Set the first 0 from the right side to 1.\n    N |= (mask >> 1)\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpgeiptt5l_test.go:58: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpgeiptt5l_test.go:58: expected '%!s(int=6)', got '%!s(int=14)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\n    var s3 int\n    var t\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5mrueo1q_test.go:99:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var num int\n    var res int\n\n    for i = 0; i < N; i++ {\n        num = i\n        for j = 0; j < N; j++ {\n            if num == N {\n                break\n            }\n            num = num * 2\n        }\n        if num == N {\n            break\n        }\n    }\n\n    if i == N {\n        return -1\n    }\n\n    res = i\n\n    for k = i + 1; k < N; k++ {\n        num = k\n        for j = 0; j < N; j++ {\n            if num == N {\n                break\n            }\n            num = num * 2\n        }\n        if num == N {\n            break\n        }\n    }\n\n    if k == N {\n        return res\n    }\n\n    if k - N < N - res {\n        return k\n    } else {\n        return res\n    }\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpqxweb59x_test.go:72: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpqxweb59x_test.go:72: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpqxweb59x_test.go:72: expected '%!s(int=11)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmptj890pn4_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmptj890pn4_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmptj890pn4_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var num int\n    var count int\n    var count_max int\n    var num_max int\n    var num_min int\n    var num_max_min int\n    var num_min_max int\n    var num_max_min_count int\n    var num_min_max_count int\n    var num_max_count int\n    var num_min_count int\n    var num_max_min_count_max int\n    var num_min_max_count_max int\n    var num_max_count_max int\n    var num_min_count_max int\n    var num_max_min_count_max_num int\n    var num_min_max_count_max_num int\n    var num_max_count_max_num int\n    var num_min_count_max_num int\n    var num_max_min_count_max_num_min int\n    var num_min_max_count_max_num_min int\n    var num_max_count_max_num_min int\n    var num_min_count_max_num_min int\n\n    for i = 1; i < N; i++ {\n        num = N - i\n        count = 0\n        for num > 0 {\n            count += num % 2\n            num /= 2\n        }\n        if count > count_max {\n            count_max = count\n            num_max = N - i\n        }\n    }\n    num_min = N - 1\n    for num_min > 0 {\n        count_max += num_min % 2\n        num_min /= 2\n    }\n    for i = 1; i < N; i++ {\n        num = N - i\n        count = 0\n        for num > 0 {\n            count += num % 2\n            num /= 2\n        }\n        if count == count_max {\n            num_max_min = N - i\n            break\n        }\n    }\n    for i = 1; i < N; i++ {\n        num = N - i\n        count = 0\n        for num > 0 {\n            count += num % 2\n            num /= 2\n        }\n        if\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwclozxmr_test.go:72:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    // find the first 1 from right to left\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    // find the first 0 from right to left\n    var j uint\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n\n    // swap i and j\n    N = N | (1 << i)\n    N = N & ^(1 << j)\n    N = N | (1 << j)\n    N = N & ^(1 << i)\n\n    // set all bits after j to 1\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbhwlg64f_test.go:56: expected '%!s(int=10)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbhwlg64f_test.go:56: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbhwlg64f_test.go:56: expected '%!s(int=11)', got '%!s(int=25)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    for i := N - 1; i > 0; i-- {\n        if i % 10 != 9 {\n            num = i\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    for i < N {\n        if N & i == 0 {\n            return i\n        }\n        i = i << 1\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpa6fcyyjv_test.go:35: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpa6fcyyjv_test.go:35: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpa6fcyyjv_test.go:35: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    for i := 0; i < N; i++ {\n        if i * i > N {\n            num = i - 1\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpe01d7i31_test.go:35: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpe01d7i31_test.go:35: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpe01d7i31_test.go:35: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (N & i) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if (i & (i+1)) == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpk1u_4pfb_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpk1u_4pfb_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpk1u_4pfb_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var bit_1_pos int\n    var bit_0_pos int\n    var bit_1_pos_found bool\n    var bit_0_pos_found bool\n    var bit_1_pos_prev int\n    var bit_0_pos_prev int\n    var bit_1_pos_prev_found bool\n    var bit_0_pos_prev_found bool\n    var bit_1_pos_next int\n    var bit_0_pos_next int\n    var bit_1_pos_next_found bool\n    var bit_0_pos_next_found bool\n    var bit_1_pos_next_next int\n    var bit_0_pos_next_next int\n    var bit_1_pos_next_next_found bool\n    var bit_0_pos_next_next_found bool\n    var bit_1_pos_next_next_next int\n    var bit_0_pos_next_next_next int\n    var bit_1_pos_next_next_next_found bool\n    var bit_0_pos_next_next_next_found bool\n    var bit_1_pos_next_next_next_next int\n    var bit_0_pos_next_next_next_next int\n    var bit_1_pos_next_next_next_next_found bool\n    var bit_0_pos_next_next_next_next_found bool\n    var bit_1_pos_next_next_next_next_next int\n    var bit_0_pos_next_next_next_next_next int\n    var bit_1_pos_next_next_next_next_next_found bool\n    var bit_0_pos_next_next_next_next_next_found bool\n    var bit_1_pos_next_next_next_next_next_next int\n    var bit_0_pos_next_next_next_next_next_next int\n    var bit_1_pos_next_next_next_next_next_next_found bool\n    var bit_0_pos_next_next_next_next_next_next_found bool\n    var bit_1_pos_\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfcneo60y_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = 0; i < N; i++ {\n        if (N & (1 << i)) == 0 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp03v3eu3f_test.go:34: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp03v3eu3f_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp03v3eu3f_test.go:34: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9fd88dae_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprtu0muol_test.go:99:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpv7bfpa2y_test.go:37: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpv7bfpa2y_test.go:37: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpv7bfpa2y_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp39rtkz8y_test.go:100:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var a, b, c int\n    var d int\n\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            a = i * i\n            b = j * j\n            c = (i + j) * (i + j)\n            d = c - (a + b)\n            if d == N {\n                return i + j\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp8pttxeuo_test.go:43: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp8pttxeuo_test.go:43: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8pttxeuo_test.go:43: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var num int\n    var arr []int\n    var arr_len int\n    var arr_max int\n    var arr_min int\n\n    if N < 0 {\n        return 0\n    }\n\n    for i = 0; i < N; i++ {\n        num = i\n        arr = []int{}\n        for j = 0; j < 10; j++ {\n            arr = append(arr, num % 10)\n            num = num / 10\n        }\n        arr_len = len(arr)\n        arr_max = arr[0]\n        arr_min = arr[0]\n        for k = 1; k < arr_len; k++ {\n            if arr[k] > arr_max {\n                arr_max = arr[k]\n            }\n            if arr[k] < arr_min {\n                arr_min = arr[k]\n            }\n        }\n        if arr_max - arr_min == 1 {\n            return i\n        }\n    }\n\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpua5iz9m3_test.go:62: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpua5iz9m3_test.go:62: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpua5iz9m3_test.go:62: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpzrcf4431_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpzrcf4431_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpzrcf4431_test.go:43: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var aa int = 0\n    var bb int = 0\n    var cc int = 0\n    var dd int = 0\n    var ee int = 0\n    var ff int = 0\n    var gg int = 0\n    var hh int = 0\n    var ii int = 0\n    var jj int = 0\n    var kk int = 0\n    var ll int = 0\n    var mm int = 0\n    var nn int = 0\n    var oo int = 0\n    var pp int = 0\n    var qq int = 0\n    var rr int = 0\n    var ss int = 0\n    var tt int = 0\n    var uu int = 0\n    var vv int = 0\n    var ww int = 0\n    var xx int = 0\n    var yy int = 0\n    var zz int = 0\n    var aaa int = 0\n    var bbb int = 0\n    var ccc int = 0\n    var ddd int = 0\n    var eee int = 0\n    var fff int = 0\n    var ggg int = 0\n    var hhh int = 0\n    var iii int = 0\n    var jjj int = 0\n    var kkk int = 0\n    var lll int = 0\n    var mmm int = 0\n    var nnn int = 0\n    var ooo int = 0\n    var ppp int = 0\n    var qqq int = 0\n    var rrr int = 0\n    var sss int = 0\n    var ttt int = 0\n    var uuu int = 0\n    var vvv int = 0\n    var www int = 0\n    var xxx\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnmnmr5st_test.go:77:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n    // find the closest number with the same number of 1s\n    for N < (1 << 31) {\n        if count == 0 {\n            break\n        }\n        if N & 1 == 1 {\n            count--\n        }\n        N++\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmprn6wmo3f_test.go:49: expected '%!s(int=10)', got '%!s(int=6)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmprn6wmo3f_test.go:49: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n\n    if N == 0 {\n        return 0\n    }\n\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & (N - 1)\n    j = N & (N + 1)\n    k = N & (N - 2)\n    l = N & (N + 2)\n    m = N & (N - 4)\n    n = N & (N + 4)\n    o = N & (N - 8)\n    p = N & (N + 8)\n    q = N & (N - 16)\n    r = N & (N + 16)\n    s = N & (N - 32)\n    t = N & (N + 32)\n    u = N & (N - 64)\n    v = N & (N + 64)\n    w = N & (N - 128)\n    x = N & (N + 128)\n    y = N & (N - 256)\n    z = N & (N + 256)\n\n    if i != 0 {\n        return i\n    }\n\n    if j != 0 {\n        return j\n    }\n\n    if k != 0 {\n        return k\n    }\n\n    if l != 0 {\n        return l\n    }\n\n    if m != 0 {\n        return m\n    }\n\n    if n != 0 {\n        return n\n    }\n\n    if o != 0 {\n        return o\n    }\n\n    if p != 0 {\n        return p\n    }\n\n    if q != 0 {\n        return q\n    }\n\n    if r != 0 {\n        return r\n    }\n\n    if s != 0 {\n        return s\n    }\n\n    if t != 0 {\n        return t\n    }\n\n    if u != 0 {\n        return u\n    }\n\n    if v != 0 {\n        return v\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpej3qvves_test.go:111:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var cnt int\n    var num int\n    var tmp int\n    var res int\n    var res_cnt int\n\n    for i = 0; i < N; i++ {\n        num = i\n        cnt = 0\n        for j = 0; j < 32; j++ {\n            tmp = num & 1\n            if tmp == 1 {\n                cnt++\n            }\n            num = num >> 1\n        }\n        if cnt == 1 {\n            res = i\n            res_cnt = cnt\n            break\n        } else if cnt < res_cnt {\n            res = i\n            res_cnt = cnt\n        }\n    }\n\n    return res\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr1_i3f_a_test.go:55: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr1_i3f_a_test.go:55: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr1_i3f_a_test.go:55: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 1.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // If i is 0, then there is no smaller number.\n    if i == 0 {\n        return -1\n    }\n    // Clear the bit at i.\n    N &= ^(1 << i)\n    // Set the bit at i - 1.\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_sn4euv4_test.go:43: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_sn4euv4_test.go:43: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_sn4euv4_test.go:43: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 31; i >= 0; i-- {\n        if (N >> uint(i)) & 1 == 1 {\n            break\n        }\n    }\n    fmt.Println(i)\n    return N - (1 << uint(i))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "3\n2\n3\n--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmptdxtzc4w_test.go:38: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmptdxtzc4w_test.go:38: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmptdxtzc4w_test.go:38: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphp5zypny_test.go:119:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbq4d3zkf_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbq4d3zkf_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbq4d3zkf_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp0n5lp4im_test.go:37: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp0n5lp4im_test.go:37: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp0n5lp4im_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // set the first 1 to 0\n    N &= ^(1 << i)\n    // set the first 0 to 1\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpwf83xnz1_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var n int\n    var num int\n    var count int\n    var result int\n    var temp int\n    var temp_count int\n    var temp_num int\n    var temp_result int\n    var temp_n int\n    var temp_i int\n    var temp_j int\n    var temp_temp int\n\n    for i = 1; i <= N; i++ {\n        n = N\n        num = i\n        count = 0\n        result = 0\n        temp = 0\n        temp_count = 0\n        temp_num = 0\n        temp_result = 0\n        temp_n = 0\n        temp_i = 0\n        temp_j = 0\n        temp_temp = 0\n\n        for j = 1; j <= N; j++ {\n            if num == 0 {\n                break\n            }\n            if n == 0 {\n                break\n            }\n            if num == 1 {\n                result += n\n                n--\n                count++\n                continue\n            }\n            if n == 1 {\n                result += num\n                num--\n                count++\n                continue\n            }\n            if num > n {\n                result += n\n                num -= n\n                count++\n                continue\n            }\n            if num < n {\n                result += num\n                n -= num\n                count++\n                continue\n            }\n        }\n        if temp_count == 0 {\n            temp_count = count\n            temp_num = i\n            temp_result = result\n            temp_n = N\n            temp_i = i\n            temp_j = j\n            temp_temp = temp\n        }\n        if temp_count > count {\n            temp_count = count\n            temp_num = i\n            temp_result = result\n            temp_n = N\n            temp_i = i\n            temp_j = j\n            temp_temp = temp\n        }\n    }\n    fmt.Printf(\"%d %d %d %d %d %d %d\\n\", temp_count, temp_num, temp_result, temp_n, temp_i, temp_j, temp_temp)\n    return temp_num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "0 11 0 11 11 12 0\n0 7 0 7 7 8 0\n0 12 0 12 12 13 0\n--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpzpojkjmw_test.go:108: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpzpojkjmw_test.go:108: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpzpojkjmw_test.go:108: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // convert to binary\n    b := fmt.Sprintf(\"%b\", N)\n    //fmt.Println(b)\n\n    // find the first 1 from the right\n    i := len(b) - 1\n    for ; i >= 0; i-- {\n        if b[i] == '1' {\n            break\n        }\n    }\n\n    // if the first 1 is at the right most, return 0\n    if i == 0 {\n        return 0\n    }\n\n    // flip the bit at i\n    b = b[:i] + \"0\" + b[i+1:]\n    //fmt.Println(b)\n\n    // find the first 0 from the right\n    j := len(b) - 1\n    for ; j >= 0; j-- {\n        if b[j] == '0' {\n            break\n        }\n    }\n\n    // flip the bit at j\n    b = b[:j] + \"1\" + b[j+1:]\n    //fmt.Println(b)\n\n    // convert back to int\n    n, _ := strconv.Atoi(b)\n    return n\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6si5dbsp_test.go:44:13: undefined: strconv\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) > 0 {\n            break\n        }\n    }\n    if i == 32 {\n        return -1\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j) | (1 << (j - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmphmp33sjf_test.go:50: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmphmp33sjf_test.go:50: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmphmp33sjf_test.go:50: expected '%!s(int=11)', got '%!s(int=28)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var c int\n\n    c = 0\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            c++\n        }\n    }\n\n    for j = 0; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            c--\n        }\n        if c == 0 {\n            break\n        }\n    }\n\n    for k = 0; k < j; k++ {\n        N |= (1 << k)\n    }\n\n    N &= ^(1 << j)\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpfrfx0qpj_test.go:55: expected '%!s(int=10)', got '%!s(int=31)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpfrfx0qpj_test.go:55: expected '%!s(int=6)', got '%!s(int=31)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpfrfx0qpj_test.go:55: expected '%!s(int=11)', got '%!s(int=13)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n\n    // count number of 1s in N\n    count := 0\n    for N > 0 {\n        N = N & (N - 1)\n        count++\n    }\n\n    // find closest number with same number of 1s\n    return (1 << uint(count)) - 1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp0iqws1hh_test.go:40: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp0iqws1hh_test.go:40: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp0iqws1hh_test.go:40: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i + 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // N = 10011011100\n    // N - 1 = 10011011011\n    // N & (N - 1) = 10011011000\n    // N - (N & (N - 1)) = 1100\n    return N - (N & (N - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9g12t4je_test.go:32: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9g12t4je_test.go:32: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9g12t4je_test.go:32: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) > 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N ^ (1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4u2km76d_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4u2km76d_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4u2km76d_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n\n    if N == 0 {\n        return 0\n    }\n\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n\n    if i == 32 {\n        return -1\n    }\n\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpcr_ivsoc_test.go:47: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpcr_ivsoc_test.go:47: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpcr_ivsoc_test.go:47: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint = 0\n    for ; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return N - 1\n    }\n    return N - (1 << i) + (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9xy1lg14_test.go:40: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var bit_num int\n    var bit_mask int\n    var bit_mask_1 int\n    var bit_mask_2 int\n    var bit_mask_3 int\n    var bit_mask_4 int\n    var bit_mask_5 int\n    var bit_mask_6 int\n    var bit_mask_7 int\n    var bit_mask_8 int\n    var bit_mask_9 int\n    var bit_mask_10 int\n    var bit_mask_11 int\n    var bit_mask_12 int\n    var bit_mask_13 int\n    var bit_mask_14 int\n    var bit_mask_15 int\n    var bit_mask_16 int\n    var bit_mask_17 int\n    var bit_mask_18 int\n    var bit_mask_19 int\n    var bit_mask_20 int\n    var bit_mask_21 int\n    var bit_mask_22 int\n    var bit_mask_23 int\n    var bit_mask_24 int\n    var bit_mask_25 int\n    var bit_mask_26 int\n    var bit_mask_27 int\n    var bit_mask_28 int\n    var bit_mask_29 int\n    var bit_mask_30 int\n    var bit_mask_31 int\n    var bit_mask_32 int\n\n    bit_mask_1 = 1 << 0\n    bit_mask_2 = 1 << 1\n    bit_mask_3 = 1 << 2\n    bit_mask_4 = 1 << 3\n    bit_mask_5 = 1 << 4\n    bit_mask_6 = 1 << 5\n    bit_mask_7 = 1 << 6\n    bit_mask_8 = 1 << 7\n    bit_mask_9 = 1 << 8\n    bit_mask_10 = 1 << 9\n    bit_mask_11 = 1 << 10\n    bit_mask_12 = 1 << 11\n    bit_mask_13 = 1 << 12\n    bit_mask_14 = 1 << 13\n    bit_mask_15 = 1 << 14\n    bit_mask_16 = 1 << 15\n    bit_mask_17 = 1 << 16\n    bit_mask_18 = 1\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123243,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplrn3azz__test.go:67:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvq8yar3w_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            return i\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp0qprw2b9_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp0qprw2b9_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp0qprw2b9_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var n int = N\n    for n > 0 {\n        i++\n        n = n >> 1\n    }\n\n    for j = i - 1; j >= 0; j-- {\n        if (N >> j) & 1 == 1 {\n            break\n        }\n    }\n\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyyrwr4_e_test.go:16:9: k declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpu3b22o87_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpu3b22o87_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpu3b22o87_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return -1\n    }\n    // find the first 0 from right to left\n    for j := i - 1; j >= 0; j-- {\n        if (N & (1 << j)) == 0 {\n            N = N | (1 << j)\n            N = N & ^((1 << j) - 1)\n            break\n        }\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmptp__rcio_test.go:46: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmptp__rcio_test.go:46: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmptp__rcio_test.go:46: expected '%!s(int=11)', got '%!s(int=14)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N >> j) & 1 == 0 {\n            break\n        }\n    }\n    return N ^ ((1 << i) | (1 << j))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpcurx0ple_test.go:39: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpcurx0ple_test.go:39: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpcurx0ple_test.go:39: expected '%!s(int=11)', got '%!s(int=24)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var nums []int\n    for i = 1; i < N; i++ {\n        if N % i == 0 {\n            nums = append(nums, i)\n        }\n    }\n    for j = 0; j < len(nums); j++ {\n        for k = j + 1; k < len(nums); k++ {\n            if nums[j] + nums[k] == N {\n                return nums[j]\n            }\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpz0f9k8kg_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpz0f9k8kg_test.go:42: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpz0f9k8kg_test.go:42: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int = 0\n    for i := 0; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            num |= (1 << i)\n        } else {\n            num |= (1 << i)\n            num &= ^(1 << (i + 1))\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvq7jfhf7_test.go:38: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvq7jfhf7_test.go:38: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvq7jfhf7_test.go:38: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if (i & (i-1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpq9whoh2p_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpq9whoh2p_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpq9whoh2p_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var num_array []int\n    var num_array_len int\n\n    for i = 0; i < N; i++ {\n        num = i\n        num_array = []int{}\n        for j = 0; j < len(fmt.Sprintf(\"%d\", num)); j++ {\n            num_array = append(num_array, num % 10)\n            num = num / 10\n        }\n        num_array_len = len(num_array)\n        if num_array_len > 1 {\n            for j = 0; j < num_array_len - 1; j++ {\n                if num_array[j] < num_array[j + 1] {\n                    num_array[j], num_array[j + 1] = num_array[j + 1], num_array[j]\n                }\n            }\n        }\n        num = 0\n        for j = 0; j < num_array_len; j++ {\n            num = num * 10 + num_array[j]\n        }\n        if num < N {\n            return num\n        }\n    }\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpzczfune6_test.go:56: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpzczfune6_test.go:56: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpzczfune6_test.go:56: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    // find the first 0 from right to left\n    // swap them\n    // move all 1s to the right\n    // move all 0s to the left\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = 0; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if i == 32 || j == 32 {\n        return -1\n    }\n    N = N ^ (1 << i)\n    N = N ^ (1 << j)\n    for i = i - 1; i >= 0; i-- {\n        N = N | (1 << i)\n    }\n    for j = j + 1; j < 32; j++ {\n        N = N & (^(1 << j))\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbmjlqqje_test.go:55: expected '%!s(int=10)', got '%!s(int=6)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbmjlqqje_test.go:55: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbmjlqqje_test.go:55: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    for i := 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            return N ^ (1 << i)\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpdzzchgqf_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var num int\n    for i = 0; i < N; i++ {\n        num = i\n        for j = 0; j < N; j++ {\n            if num & (1 << j) != 0 {\n                break\n            }\n        }\n        for k = j + 1; k < N; k++ {\n            if num & (1 << k) == 0 {\n                num |= (1 << k)\n                num &= ^(1 << j)\n                break\n            }\n        }\n        if k == N {\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpa4yrcrkl_test.go:48: expected '%!s(int=10)', got '%!s(int=12)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpa4yrcrkl_test.go:48: expected '%!s(int=6)', got '%!s(int=12)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpa4yrcrkl_test.go:48: expected '%!s(int=11)', got '%!s(int=14)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // N = 1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123243,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwob5dah9_test.go:11:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i+1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpmkbntvnf_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpmkbntvnf_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpmkbntvnf_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i - 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp03gw52pp_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp03gw52pp_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp03gw52pp_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var num int = N\n    var bit_num int = 0\n    var bit_num_1 int = 0\n    var bit_num_0 int = 0\n    var bit_num_0_pos int = 0\n    var bit_num_1_pos int = 0\n    var bit_num_0_pos_1 int = 0\n    var bit_num_1_pos_1 int = 0\n    var bit_num_0_pos_2 int = 0\n    var bit_num_1_pos_2 int = 0\n    var bit_num_0_pos_3 int = 0\n    var bit_num_1_pos_3 int = 0\n    var bit_num_0_pos_4 int = 0\n    var bit_num_1_pos_4 int = 0\n    var bit_num_0_pos_5 int = 0\n    var bit_num_1_pos_5 int = 0\n    var bit_num_0_pos_6 int = 0\n    var bit_num_1_pos_6 int = 0\n    var bit_num_0_pos_7 int = 0\n    var bit_num_1_pos_7 int = 0\n    var bit_num_0_pos_8 int = 0\n    var bit_num_1_pos_8 int = 0\n    var bit_num_0_pos_9 int = 0\n    var bit_num_1_pos_9 int = 0\n    var bit_num_0_pos_10 int = 0\n    var bit_num_1_pos_10 int = 0\n    var bit_num_0_pos_11 int = 0\n    var bit_num_1_pos_11 int = 0\n    var bit_num_0_pos_12 int = 0\n    var bit_num_1_pos_12 int = 0\n    var bit_num_0_pos_13 int = 0\n    var bit_num_1_pos_13 int = 0\n    var bit_num_0_pos_14 int = 0\n    var bit_num_1_pos_14 int = 0\n    var bit_num_0_pos_15 int = 0\n    var bit\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5cy5sjlv_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (N & i) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the number of bits in N\n    num_bits := 0\n    for N > 0 {\n        N >>= 1\n        num_bits++\n    }\n    // Flip the rightmost non-trailing zero\n    return ((1 << uint(num_bits)) - 1) ^ (1 << (uint(num_bits) - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_3wv6a0z_test.go:35: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_3wv6a0z_test.go:35: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_3wv6a0z_test.go:35: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j) | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpcu7ebzp5_test.go:47: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpcu7ebzp5_test.go:47: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpcu7ebzp5_test.go:47: expected '%!s(int=11)', got '%!s(int=29)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var result int\n    var num_list []int\n    var num_list_len int\n    var num_list_mid int\n    var num_list_mid_value int\n    var num_list_mid_left_value int\n    var num_list_mid_right_value int\n    var num_list_mid_left int\n    var num_list_mid_right int\n    var num_list_mid_left_diff int\n    var num_list_mid_right_diff int\n    var num_list_mid_left_diff_abs int\n    var num_list_mid_right_diff_abs int\n\n    for i = 1; i <= N; i++ {\n        num_list = append(num_list, i)\n    }\n\n    num_list_len = len(num_list)\n    num_list_mid = num_list_len / 2\n\n    num_list_mid_value = num_list[num_list_mid]\n    num_list_mid_left = num_list_mid - 1\n    num_list_mid_right = num_list_mid + 1\n\n    num_list_mid_left_value = num_list[num_list_mid_left]\n    num_list_mid_right_value = num_list[num_list_mid_right]\n\n    num_list_mid_left_diff = num_list_mid_value - num_list_mid_left_value\n    num_list_mid_right_diff = num_list_mid_right_value - num_list_mid_value\n\n    num_list_mid_left_diff_abs = num_list_mid_left_diff\n    num_list_mid_right_diff_abs = num_list_mid_right_diff\n\n    if num_list_mid_left_diff < 0 {\n        num_list_mid_left_diff_abs = num_list_mid_left_diff * -1\n    }\n\n    if num_list_mid_right_diff < 0 {\n        num_list_mid_right_diff_abs = num_list_mid_right_diff * -1\n    }\n\n    if num_\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4wp4t9uu_test.go:54:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var a int = 0\n    var b int = 0\n    var c int = 0\n    var d int = 0\n    var e int = 0\n    var f int = 0\n    var g int = 0\n    var h int = 0\n    var i1 int = 0\n    var j1 int = 0\n    var k1 int = 0\n    var l1 int = 0\n    var m1 int = 0\n    var n1 int = 0\n    var o1 int = 0\n    var p1 int = 0\n    var q1 int = 0\n    var r1 int = 0\n    var s1 int = 0\n    var t1 int = 0\n    var u1 int = 0\n    var v1 int = 0\n    var w1 int = 0\n    var x1 int = 0\n    var y1 int = 0\n    var z1 int = 0\n    var a1 int = 0\n    var b1 int = 0\n    var c1 int = 0\n    var d1 int = 0\n    var e1 int = 0\n    var f1 int = 0\n    var g1 int = 0\n    var h1 int = 0\n    var i2 int = 0\n    var j2 int = 0\n    var k2 int = 0\n    var l2 int = 0\n    var m2 int = 0\n    var n2 int = 0\n    var o2 int = 0\n    var p2 int = 0\n    var q2 int = 0\n    var r2 int = 0\n    var s2 int = 0\n    var t2 int = 0\n    var u2 int = 0\n    var v2 int = 0\n    var w2 int = 0\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprot9via1_test.go:78:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var n int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n1 int\n    var n2 int\n    var n3 int\n    var n4 int\n    var n5 int\n    var n6 int\n    var n7 int\n    var n8 int\n    var n9 int\n    var n10 int\n    var n11 int\n    var n12 int\n    var n13 int\n    var n14 int\n    var n15 int\n    var n16 int\n    var n17 int\n    var n18 int\n    var n19 int\n    var n20 int\n    var n21 int\n    var n22 int\n    var n23 int\n    var n24 int\n    var n25 int\n    var n26 int\n    var n27 int\n    var n28 int\n    var n29 int\n    var n30 int\n    var n31 int\n    var n32 int\n    var n33 int\n    var n34 int\n    var n35 int\n    var n36 int\n    var n37 int\n    var n38 int\n    var n39 int\n    var n40 int\n    var n41 int\n    var n42 int\n    var n43 int\n    var n44 int\n    var n45 int\n    var n46 int\n    var n47 int\n    var n48 int\n    var n49 int\n    var n50 int\n    var n51 int\n    var n52 int\n    var n53 int\n    var n54 int\n    var n55 int\n    var n56 int\n    var n57 int\n    var n58 int\n    var n59 int\n    var n60 int\n    var n61 int\n    var n62 int\n    var n63 int\n    var n64 int\n    var n65 int\n    var n66 int\n    var n67 int\n    var n68 int\n    var n69 int\n    var n70 int\n    var n71 int\n    var n72 int\n    var n73 int\n    var n74 int\n    var n75 int\n    var n76 int\n    var n77 int\n    var n78 int\n    var n79 int\n    var n80 int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppepo_atq_test.go:97:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    var num int = N\n    var count int = 0\n    for num > 0 {\n        if num & 1 == 1 {\n            count++\n        }\n        num >>= 1\n    }\n    return N - (1 << uint(count - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpy0rxnbcn_test.go:42: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpy0rxnbcn_test.go:42: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpy0rxnbcn_test.go:42: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123246,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdgdxc474_test.go:100:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpoaofnmuw_test.go:37: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpoaofnmuw_test.go:37: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpoaofnmuw_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    if N == 0 {\n        return 0\n    }\n\n    if N == 1 {\n        return 0\n    }\n\n    if N == 2 {\n        return 1\n    }\n\n    if N == 3 {\n        return 2\n    }\n\n    if N == 4 {\n        return 3\n    }\n\n    if N == 5 {\n        return 4\n    }\n\n    if N == 6 {\n        return 5\n    }\n\n    if N == 7 {\n        return 6\n    }\n\n    if N == 8 {\n        return 7\n    }\n\n    if N == 9 {\n        return 8\n    }\n\n    if N == 10 {\n        return 9\n    }\n\n    if N == 11 {\n        return 9\n    }\n\n    if N == 12 {\n        return 9\n    }\n\n    if N == 13 {\n        return 9\n    }\n\n    if N == 14 {\n        return 9\n    }\n\n    if N == 15 {\n        return 9\n    }\n\n    if N == 16 {\n        return 9\n    }\n\n    if N == 17 {\n        return 9\n    }\n\n    if N == 18 {\n        return 9\n    }\n\n    if N == 19 {\n        return 9\n    }\n\n    if N == 20 {\n        return 9\n    }\n\n    if N == 21 {\n        return 9\n    }\n\n    if N == 22 {\n        return 9\n    }\n\n    if N == 23 {\n        return 9\n    }\n\n    if N == 24 {\n        return 9\n    }\n\n    if N == 25 {\n        return 9\n    }\n\n    if N == 26 {\n        return 9\n    }\n\n    if N == 27 {\n        return 9\n    }\n\n    if N == 28 {\n        return 9\n    }\n\n    if N == 29 {\n        return 9\n    }\n\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123246,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphs8skous_test.go:150:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var sssss int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123246,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp21dpf9ps_test.go:100:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count number of 1s in N\n    var count int\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n\n    // find the closest number with same number of 1s\n    var result int\n    for i := 0; i < count; i++ {\n        result |= 1 << i\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3j07cery_test.go:42: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3j07cery_test.go:42: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3j07cery_test.go:42: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 32 {\n        return -1\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpf4jbbxhu_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpf4jbbxhu_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpf4jbbxhu_test.go:43: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n\n    var i int = 1\n    for i < N {\n        if i * 2 > N {\n            return i\n        }\n        i = i * 2\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpfl42k3fx_test.go:42: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpfl42k3fx_test.go:42: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpfl42k3fx_test.go:42: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & 0x55555555\n    j = N & 0xAAAAAAAA\n    k = i | (j >> 1)\n    l = k & 0x33333333\n    m = k & 0xCCCCCCCC\n    n = l | (m >> 2)\n    o = n & 0x0F0F0F0F\n    p = n & 0xF0F0F0F0\n    q = o | (p >> 4)\n    r = q & 0x00FF00FF\n    s = q & 0xFF00FF00\n    t = r | (s >> 8)\n    u = t & 0x0000FFFF\n    v = t & 0xFFFF0000\n    w = u | (v >> 16)\n\n    x = N & 0x55555555\n    y = N & 0xAAAAAAAA\n    z = x | (y >> 1)\n\n    return w & z\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpls04z72a_test.go:67: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpls04z72a_test.go:67: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpls04z72a_test.go:67: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i int = 1\n    for i < N {\n        if (N & i) > 0 {\n            return N & (i-1)\n        }\n        i = i << 1\n    }\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyt5yw8l9_test.go:41: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyt5yw8l9_test.go:41: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyt5yw8l9_test.go:41: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var aa int = 0\n    var bb int = 0\n    var cc int = 0\n    var dd int = 0\n    var ee int = 0\n    var ff int = 0\n    var gg int = 0\n    var hh int = 0\n    var ii int = 0\n    var jj int = 0\n    var kk int = 0\n    var ll int = 0\n    var mm int = 0\n    var nn int = 0\n    var oo int = 0\n    var pp int = 0\n    var qq int = 0\n    var rr int = 0\n    var ss int = 0\n    var tt int = 0\n    var uu int = 0\n    var vv int = 0\n    var ww int = 0\n    var xx int = 0\n    var yy int = 0\n    var zz int = 0\n    var aaa int = 0\n    var bbb int = 0\n    var ccc int = 0\n    var ddd int = 0\n    var eee int = 0\n    var fff int = 0\n    var ggg int = 0\n    var hhh int = 0\n    var iii int = 0\n    var jjj int = 0\n    var kkk int = 0\n    var lll int = 0\n    var mmm int = 0\n    var nnn int = 0\n    var ooo int = 0\n    var ppp int = 0\n    var qqq int = 0\n    var rrr int = 0\n    var sss int = 0\n    var ttt int = 0\n    var uuu int = 0\n    var vvv int\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123246,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc5ehjy24_test.go:79:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    var j int = 1\n    var k int = 1\n    var n int = N\n    var result int = 0\n    for n > 0 {\n        if n & 1 == 1 {\n            result += i\n        }\n        i <<= 1\n        n >>= 1\n    }\n    for j < N {\n        j <<= 1\n    }\n    for k < N {\n        k <<= 1\n    }\n    k >>= 1\n    if result > k {\n        result = k\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpno_dgpuw_test.go:50: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpno_dgpuw_test.go:50: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpno_dgpuw_test.go:50: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n\n    // Flip the first 1 from the right.\n    N = N & ^(1 << i)\n\n    // Set the first 0 from the right to 1.\n    N = N | (1 << (i - 1))\n\n    // Set all the bits to the right of the first 0 from the right to 1.\n    N = N | ((1 << (i - 1)) - 1)\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpk74eu50p_test.go:45: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpk74eu50p_test.go:45: expected '%!s(int=6)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    // i\n    i = N - 1\n    if i > 0 {\n        return i\n    }\n\n    // j\n    j = N - 2\n    if j > 0 {\n        return j\n    }\n\n    // k\n    k = N - 3\n    if k > 0 {\n        return k\n    }\n\n    // l\n    l = N - 4\n    if l > 0 {\n        return l\n    }\n\n    // m\n    m = N - 5\n    if m > 0 {\n        return m\n    }\n\n    // n\n    n = N - 6\n    if n > 0 {\n        return n\n    }\n\n    // o\n    o = N - 7\n    if o > 0 {\n        return o\n    }\n\n    // p\n    p = N - 8\n    if p > 0 {\n        return p\n    }\n\n    // q\n    q = N - 9\n    if q > 0 {\n        return q\n    }\n\n    // r\n    r = N - 10\n    if r > 0 {\n        return r\n    }\n\n    // s\n    s = N - 11\n    if s > 0 {\n        return s\n    }\n\n    // t\n    t = N - 12\n    if t > 0 {\n        return t\n    }\n\n    // u\n    u = N - 13\n    if u > 0 {\n        return u\n    }\n\n    // v\n    v = N - 14\n    if v > 0 {\n        return v\n    }\n\n    // w\n    w = N - 15\n    if w > 0 {\n        return w\n    }\n\n    // x\n    x = N - 16\n    if x > 0 {\n        return x\n    }\n\n    // y\n    y = N - 17\n    if y > 0 {\n        return y\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123246,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpuy9dkphe_test.go:129:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if is_prime(i) {\n            return i\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7r64gp5i_test.go:12:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var count int\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N = N >> 1\n    }\n    return count\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9uocph5w_test.go:35: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9uocph5w_test.go:35: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9uocph5w_test.go:35: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpdc6jn_qu_test.go:39: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpdc6jn_qu_test.go:39: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpdc6jn_qu_test.go:39: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n\n    var (\n        num int\n        i   int\n    )\n\n    for i = 0; i < 32; i++ {\n        num = N ^ (1 << i)\n        if num < N {\n            return num\n        }\n    }\n\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpim75297i_test.go:44: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123248,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmphpcod24d_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmphpcod24d_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmphpcod24d_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123248,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpg7ycu42y_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpg7ycu42y_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpg7ycu42y_test.go:43: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var n int\n    var m int\n    var l int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp66y5vpfw_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if is_prime(i) {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2_5_ws7k_test.go:12:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123248,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpa09wiaie_test.go:48: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpa09wiaie_test.go:48: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpa09wiaie_test.go:48: expected '%!s(int=11)', got '%!s(int=29)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var count int\n    var result int\n    for i = 0; i < N; i++ {\n        if i & N == i {\n            count++\n            result = i\n        }\n    }\n    if count == 1 {\n        return result\n    } else {\n        return -1\n    }\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123248,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpdh720epw_test.go:41: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpdh720epw_test.go:41: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpdh720epw_test.go:41: expected '%!s(int=11)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var s string\n\n    s = fmt.Sprintf(\"%b\", N)\n\n    for i = len(s) - 1; i >= 0; i-- {\n        if s[i] == '1' {\n            break\n        }\n    }\n\n    for j = i - 1; j >= 0; j-- {\n        if s[j] == '0' {\n            break\n        }\n    }\n\n    s = s[:j] + \"1\" + s[j+1:]\n    for k = j + 1; k < i; k++ {\n        s = s[:k] + \"0\" + s[k+1:]\n    }\n\n    fmt.Println(s)\n\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123249,
      "stdout": "1101\n--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(0x7, 0x0)\n\t/tmp/tmp5xkudcy5_test.go:27 +0x26d\ncommand-line-arguments_test.TestClosest_Num(0xc000102600)\n\t/tmp/tmp5xkudcy5_test.go:45 +0x69\ntesting.tRunner(0xc000102600, 0x54f1e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // 1. find the first bit that is 1 from right to left\n    // 2. flip the bit\n    // 3. set all the bits to the right of the flipped bit to 1\n    // 4. set all the bits to the left of the flipped bit to 0\n    // 5. return the number\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    N = N & ((1 << i) - 1)\n    N = N | (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123249,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpz59qshb8_test.go:44: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpz59qshb8_test.go:44: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpz59qshb8_test.go:44: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 2 {\n        return 0\n    }\n\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n\n    // find the closest number with the same number of 1s\n    for N < (1 << uint(count)) - 1 {\n        N++\n        count_temp := 0\n        for N > 0 {\n            if N & 1 == 1 {\n                count_temp++\n            }\n            N >>= 1\n        }\n        if count_temp == count {\n            return N\n        }\n    }\n\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123276,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Count the number of 1s in N.\n    count := 0\n    for N != 0 {\n        N &= N - 1\n        count++\n    }\n\n    // Find the closest number with the same number of 1s.\n    for N < 1 << count {\n        N |= N >> 1\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123276,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123249,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp1pc2itxl_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp1pc2itxl_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp1pc2itxl_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // Flip the first 0 after the first 1.\n    for ; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            N |= (1 << i)\n            break\n        }\n    }\n    // Flip the first 1 after the first 0.\n    N &= ^(1 << i)\n    // Flip all the bits to the right of the first 1.\n    N |= (1 << i) - 1\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123249,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpq3eimidr_test.go:46: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpq3eimidr_test.go:46: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpq3eimidr_test.go:46: expected '%!s(int=11)', got '%!s(int=15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int = N\n    var count int = 0\n    for num != 0 {\n        if num & 1 == 1 {\n            count++\n        }\n        num >>= 1\n    }\n    return count\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123249,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpet2llsu__test.go:36: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpet2llsu__test.go:36: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpet2llsu__test.go:36: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var aa int = 0\n    var ab int = 0\n    var ac int = 0\n    var ad int = 0\n    var ae int = 0\n    var af int = 0\n    var ag int = 0\n    var ah int = 0\n    var ai int = 0\n    var aj int = 0\n    var ak int = 0\n    var al int = 0\n    var am int = 0\n    var an int = 0\n    var ao int = 0\n    var ap int = 0\n    var aq int = 0\n    var ar int = 0\n    var as int = 0\n    var at int = 0\n    var au int = 0\n    var av int = 0\n    var aw int = 0\n    var ax int = 0\n    var ay int = 0\n    var az int = 0\n    var ba int = 0\n    var bb int = 0\n    var bc int = 0\n    var bd int = 0\n    var be int = 0\n    var bf int = 0\n    var bg int = 0\n    var bh int = 0\n    var bi int = 0\n    var bj int = 0\n    var bk int = 0\n    var bl int = 0\n    var bm int = 0\n    var bn int = 0\n    var bo int = 0\n    var bp int = 0\n    var bq int = 0\n    var br int = 0\n    var bs int = 0\n    var bt int = 0\n    var bu int = 0\n    var bv int = 0\n    var bw int = 0\n    var bx int = 0\n    var by int = 0\n    var bz int =\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123249,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxpm2ikw1_test.go:80:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var result int\n    for i := N - 1; i > 0; i-- {\n        if i & N == 0 {\n            result = i\n            break\n        }\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpt2mccziq_test.go:35: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpt2mccziq_test.go:35: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpt2mccziq_test.go:35: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n\n    var i int = 1\n    for i <= N {\n        i = i << 1\n    }\n\n    return i >> 1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp8b4zadv1_test.go:37: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp8b4zadv1_test.go:37: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8b4zadv1_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n\n    var i, j, k int\n    var num int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            num = N & ((1 << i) - 1)\n            for j = i - 1; j >= 0; j-- {\n                if (N & (1 << j)) == 0 {\n                    num |= (1 << j)\n                    break\n                }\n            }\n            for k = i - 1; k >= 0; k-- {\n                if (N & (1 << k)) != 0 {\n                    num |= (1 << k)\n                }\n            }\n            return num\n        }\n    }\n\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpgt16_lyv_test.go:52: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpgt16_lyv_test.go:52: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpgt16_lyv_test.go:52: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n    // find the closest number with the same number of 1s\n    for N < 1 << 31 {\n        if count == 0 {\n            break\n        }\n        if N & 1 == 1 {\n            count--\n        }\n        N++\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpcst89wz2_test.go:46: expected '%!s(int=10)', got '%!s(int=6)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpcst89wz2_test.go:46: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 1 from the right.\n    // This is the bit that will be flipped.\n    var first_one_bit int\n    for i := 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            first_one_bit = i\n            break\n        }\n    }\n\n    // Flip the bit.\n    N = N ^ (1 << first_one_bit)\n\n    // Set all bits to the right of the flipped bit to 1.\n    for i := first_one_bit + 1; i < 32; i++ {\n        N = N | (1 << i)\n    }\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpqfzj769q_test.go:46: expected '%!s(int=10)', got '%!s(int=4294967294)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpqfzj769q_test.go:46: expected '%!s(int=6)', got '%!s(int=4294967294)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpqfzj769q_test.go:46: expected '%!s(int=11)', got '%!s(int=4294967288)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpr93s65v__test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N - (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpsguwo8ut_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpsguwo8ut_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpsguwo8ut_test.go:43: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first digit that is not 0.\n    for i := 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            // Find the first digit that is 1.\n            for j := i + 1; j < 32; j++ {\n                if N & (1 << j) == 0 {\n                    // Flip the bit.\n                    N = N ^ (1 << j)\n                    // Clear all the bits after j.\n                    N = N & ((1 << j) - 1)\n                    // Set all the bits after i.\n                    N = N | ((1 << (j - i - 1)) - 1) << (i + 1)\n                    return N\n                }\n            }\n            return -1\n        }\n    }\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpowkes8is_test.go:46: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpowkes8is_test.go:46: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpowkes8is_test.go:46: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // 1. find the first 1 from right to left\n    // 2. find the first 0 from right to left\n    // 3. swap 1 and 0\n    // 4. move all 1s to the right\n    // 5. move all 0s to the left\n    // 6. return the number\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N >> j) & 1 == 0 {\n            break\n        }\n    }\n    N = N & ^(1 << i)\n    N = N | (1 << j)\n    N = N & ((1 << j) - 1)\n    N = N | ((1 << (i - j - 1)) - 1) << (j + 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: negative shift amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523060, 0x616a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523060, 0x616a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(0xb, 0x5fa0c0)\n\t/tmp/tmpp0o_kgbx_test.go:30 +0x125\ncommand-line-arguments_test.TestClosest_Num(0xc000001380)\n\t/tmp/tmpp0o_kgbx_test.go:41 +0x47\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var res int\n    var count int\n    var flag bool\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            count++\n        }\n    }\n    if count == 1 {\n        return 0\n    }\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            for j = i + 1; j < 32; j++ {\n                if (N & (1 << j)) == 0 {\n                    flag = true\n                    break\n                }\n            }\n            if flag {\n                break\n            }\n        }\n    }\n    res = N & (^(1 << i))\n    res = res | (1 << j)\n    return res\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4drrgqeg_test.go:55: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4drrgqeg_test.go:55: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4drrgqeg_test.go:55: expected '%!s(int=11)', got '%!s(int=24)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int = 1\n    for i < N {\n        if (N & i) == 0 {\n            return i\n        }\n        i = i << 1\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpktt91dk1_test.go:38: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpktt91dk1_test.go:38: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpktt91dk1_test.go:38: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmppuk2v0s6_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmppuk2v0s6_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmppuk2v0s6_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var (\n        i int\n        j int\n        k int\n        l int\n    )\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            for k = 0; k < N; k++ {\n                for l = 0; l < N; l++ {\n                    if i + j + k + l == N {\n                        return i\n                    }\n                }\n            }\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmph1aqi6b7_test.go:45: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmph1aqi6b7_test.go:45: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmph1aqi6b7_test.go:45: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n    return count\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3ije1eke_test.go:36: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3ije1eke_test.go:36: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3ije1eke_test.go:36: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // convert to binary\n    var binary_str string\n    for N > 0 {\n        binary_str = fmt.Sprintf(\"%d%s\", N % 2, binary_str)\n        N = N / 2\n    }\n\n    // find the first 1 and 0 pair\n    var i int\n    for i = 0; i < len(binary_str); i++ {\n        if binary_str[i] == '1' {\n            break\n        }\n    }\n\n    // swap 1 and 0\n    binary_str = binary_str[:i] + \"0\" + binary_str[i+1:]\n    binary_str = binary_str[:i+1] + \"1\" + binary_str[i+2:]\n\n    // convert to int\n    var result int\n    for i = len(binary_str) - 1; i >= 0; i-- {\n        result = result * 2 + int(binary_str[i] - '0')\n    }\n\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpj4k0i8ek_test.go:53: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpj4k0i8ek_test.go:53: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 32 {\n        return -1\n    }\n    // Find the first 0 from the right.\n    for j := i + 1; j < 32; j++ {\n        if N & (1 << j) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    // Set the bit at j to 1.\n    N |= (1 << j)\n    // Set the bits from j + 1 to i to 0.\n    N &= ^((1 << (j + 1)) - 1)\n    // Set the bits from 0 to i - 1 to 1.\n    N |= ((1 << i) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1m3_qpze_test.go:26:8: undefined: j\n/tmp/tmp1m3_qpze_test.go:30:16: undefined: j\n/tmp/tmp1m3_qpze_test.go:32:19: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n\n    i = N & 0x55555555\n    j = N & 0xAAAAAAAA\n    k = i | j\n    l = k & 0x33333333\n    m = k & 0xCCCCCCCC\n    n = l | m\n    o = n & 0x0F0F0F0F\n    p = n & 0xF0F0F0F0\n    q = o | p\n    r = q & 0x00FF00FF\n    s = q & 0xFF00FF00\n    t = r | s\n    u = t & 0x0000FFFF\n    v = t & 0xFFFF0000\n    w = u | v\n    x = w & 0x00000001\n    y = w & 0x00000002\n    z = w & 0x00000004\n    a = w & 0x00000008\n    b = w & 0x00000010\n    c = w & 0x00000020\n    d = w & 0x00000040\n    e = w & 0x00000080\n    f = w & 0x00000100\n    g = w & 0x00000200\n    h = w & 0x00000400\n\n    return x | y | z | a | b | c | d | e | f | g | h\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpoxbjdkgd_test.go:82: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpoxbjdkgd_test.go:82: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpoxbjdkgd_test.go:82: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpo1x5w2w__test.go:37: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpo1x5w2w__test.go:37: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpo1x5w2w__test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var tmp int\n    var min int\n    var min_num int\n    var max int\n    var max_num int\n\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            num++\n        }\n    }\n\n    min = N\n    min_num = num\n    max = N\n    max_num = num\n\n    for i = 0; i < 32; i++ {\n        tmp = N & (1 << i)\n        if tmp != 0 {\n            N = N & ^(1 << i)\n            num--\n            if num < min_num {\n                min = N\n                min_num = num\n            }\n            if num > max_num {\n                max = N\n                max_num = num\n            }\n            N = N | (1 << i)\n            num++\n        }\n    }\n\n    if min_num == max_num {\n        return min\n    }\n\n    if min_num < max_num {\n        return min\n    } else {\n        return max\n    }\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcpqkhik8_test.go:10:12: j declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var num_array []int\n    var num_array_len int\n    var num_array_last_index int\n    var num_array_last_index_value int\n    var num_array_last_index_value_next int\n    var num_array_last_index_value_prev int\n    var num_array_last_index_value_next_diff int\n    var num_array_last_index_value_prev_diff int\n\n    for i = 1; i <= N; i++ {\n        num = i\n        for j = 2; j <= num; j++ {\n            if num % j == 0 {\n                num_array = append(num_array, j)\n                num /= j\n                j = 1\n            }\n        }\n    }\n\n    num_array_len = len(num_array)\n    num_array_last_index = num_array_len - 1\n    num_array_last_index_value = num_array[num_array_last_index]\n    num_array_last_index_value_next = num_array_last_index_value + 1\n    num_array_last_index_value_prev = num_array_last_index_value - 1\n\n    num_array_last_index_value_next_diff = num_array_last_index_value_next - N\n    num_array_last_index_value_prev_diff = N - num_array_last_index_value_prev\n\n    if num_array_last_index_value_next_diff < num_array_last_index_value_prev_diff {\n        return num_array_last_index_value_next\n    } else {\n        return num_array_last_index_value_prev\n    }\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpa5m5wqtu_test.go:63: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpiqqf0v3__test.go:119:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int = 0\n    var j int = 0\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return 0\n    }\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpn34xnzzi_test.go:49: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpn34xnzzi_test.go:49: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpn34xnzzi_test.go:49: expected '%!s(int=11)', got '%!s(int=29)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var aa int = 0\n    var bb int = 0\n    var cc int = 0\n    var dd int = 0\n    var ee int = 0\n    var ff int = 0\n    var gg int = 0\n    var hh int = 0\n    var ii int = 0\n    var jj int = 0\n    var kk int = 0\n    var ll int = 0\n    var mm int = 0\n    var nn int = 0\n    var oo int = 0\n    var pp int = 0\n    var qq int = 0\n    var rr int = 0\n    var ss int = 0\n    var tt int = 0\n    var uu int = 0\n    var vv int = 0\n    var ww int = 0\n    var xx int = 0\n    var yy int = 0\n    var zz int = 0\n    var aaa int = 0\n    var bbb int = 0\n    var ccc int = 0\n    var ddd int = 0\n    var eee int = 0\n    var fff int = 0\n    var ggg int = 0\n    var hhh int = 0\n    var iii int = 0\n    var jjj int = 0\n    var kkk int = 0\n    var lll int = 0\n    var mmm int = 0\n    var nnn int = 0\n    var ooo int = 0\n    var ppp int = 0\n    var qqq int = 0\n    var rrr int = 0\n    var sss int = 0\n    var ttt int = 0\n    var uuu int = 0\n    var vvv int = 0\n    var www int = 0\n    var xxx\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnmnmr5st_test.go:77:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n\n    if i == 32 {\n        return -1\n    }\n\n    for j = i + 1; j < 32; j++ {\n        if (N >> j) & 1 == 0 {\n            break\n        }\n    }\n\n    if j == 32 {\n        return -1\n    }\n\n    return N & ^(1 << j) | (1 << j) - 1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_a78xww5_test.go:53: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_a78xww5_test.go:53: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_a78xww5_test.go:53: expected '%!s(int=11)', got '%!s(int=27)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpu6t9g9si_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit from the right that is 1.\n    // Find the first bit from the right that is 0.\n    // Swap the two bits.\n    // Clear all bits to the right of the first 1.\n    // Set all bits to the right of the first 1 to 1.\n    // Return the number.\n    var i, j, k int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N ^= (1 << i) | (1 << j)\n    for k = i; k < j; k++ {\n        N |= (1 << k)\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpjgt_l3vy_test.go:52: expected '%!s(int=10)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpjgt_l3vy_test.go:52: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpjgt_l3vy_test.go:52: expected '%!s(int=11)', got '%!s(int=28)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    // Clear the bit that is 1.\n    N = N & ^(1 << i)\n\n    // Set the bit that is 0 to 1.\n    N = N | (1 << (i - 1))\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp0wuis35z_test.go:42: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return N - 1\n    }\n\n    if i == 32 {\n        return N - 1\n    }\n\n    if (N & (1 << (i - 1))) == 0 {\n        return N - (1 << i)\n    }\n\n    return N - (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpuhwxkcyq_test.go:51: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprtu0muol_test.go:99:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprtu0muol_test.go:99:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if (i & (i+1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp5odq60az_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp5odq60az_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp5odq60az_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpzvbd0zo2_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpzvbd0zo2_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpzvbd0zo2_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & (^(1 << i))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmprxwsd852_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmprxwsd852_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmprxwsd852_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int = 1\n    var j int = N\n    for i < j {\n        var m int = (i + j) / 2\n        if m * m < N {\n            i = m + 1\n        } else {\n            j = m\n        }\n    }\n    return i - 1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9xwzlquu_test.go:41: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9xwzlquu_test.go:41: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9xwzlquu_test.go:41: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return N - 1\n    }\n\n    return N - (1 << i) + (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpg9gupzqg_test.go:43: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmptj890pn4_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmptj890pn4_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmptj890pn4_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    if i == 32 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpifa1ptpn_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpifa1ptpn_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpifa1ptpn_test.go:40: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    // flip it to 0\n    // find the first 0 from right to left\n    // flip it to 1\n    // swap the two bits\n    // flip all the bits to the right of the first 1\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if N & (1 << j) == 0 {\n            break\n        }\n    }\n    N = N & ^(1 << j) | (1 << i)\n    N = N & ^((1 << i) - 1)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpw9m2gsxt_test.go:48: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpw9m2gsxt_test.go:48: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpw9m2gsxt_test.go:48: expected '%!s(int=11)', got '%!s(int=13)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num, tmp int\n    var flag bool\n    for i = N; i > 0; i-- {\n        num = i\n        tmp = num\n        flag = true\n        for j = 0; j < len(fmt.Sprintf(\"%d\", num)); j++ {\n            if tmp % 10 == 0 {\n                flag = false\n                break\n            }\n            tmp = tmp / 10\n        }\n        if flag {\n            return num\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nxc_bdg_test.go:46: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nxc_bdg_test.go:46: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nxc_bdg_test.go:46: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var result int\n    var count int\n    for i := N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            result = i\n            count++\n        }\n    }\n    if count > 1 {\n        return 0\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpzo1s_ix__test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpzo1s_ix__test.go:42: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpzo1s_ix__test.go:42: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num, num_1, num_2 int\n    var num_1_count, num_2_count int\n    var num_1_flag, num_2_flag bool\n    var num_1_index, num_2_index int\n    var num_1_index_flag, num_2_index_flag bool\n    var num_1_index_count, num_2_index_count int\n    var num_1_index_count_flag, num_2_index_count_flag bool\n    var num_1_index_count_flag_count, num_2_index_count_flag_count int\n    var num_1_index_count_flag_count_flag, num_2_index_count_flag_count_flag bool\n    var num_1_index_count_flag_count_flag_count, num_2_index_count_flag_count_flag_count int\n    var num_1_index_count_flag_count_flag_count_flag, num_2_index_count_flag_count_flag_count_flag bool\n    var num_1_index_count_flag_count_flag_count_flag_count, num_2_index_count_flag_count_flag_count_flag_count int\n    var num_1_index_count_flag_count_flag_count_flag_count_flag, num_2_index_count_flag_count_flag_count_flag_count_flag bool\n    var num_1_index_count_flag_count_flag_count_flag_count_flag_count, num_2_index_count_flag_count_flag_count_flag_count_flag_count int\n    var num_1_index_count_flag_count_flag_count_flag_count_flag_count_flag, num_2_index_count_flag_count_flag_count_flag_count_flag_count_flag bool\n    var num_1_index_count_flag_count_flag_count_flag_count_flag_count_flag_count, num_2_index_count_flag_count_flag_count_flag_count_flag_count_flag_count\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4x4tm3mj_test.go:26:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpufdkidem_test.go:37: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpufdkidem_test.go:37: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpufdkidem_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) > 0 {\n            break\n        }\n    }\n    // Flip the bit to 0.\n    N &= ^(1 << i)\n    // Set the bit to 1.\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpo0x_uctq_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i + 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // Find the first 0 from the right.\n    for i = i + 1; i < 32; i++ {\n        if N & (1 << i) == 0 {\n            break\n        }\n    }\n    // Set the first 0 to 1.\n    N |= (1 << i)\n    // Set the first 1 to 0.\n    N &= ^(1 << (i - 1))\n    // Set the first 0 to 1.\n    N |= (1 << (i - 1))\n    // Set the first 1 to 0.\n    N &= ^(1 << (i - 2))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbmocg83k_test.go:49: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbmocg83k_test.go:49: expected '%!s(int=6)', got '%!s(int=13)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbmocg83k_test.go:49: expected '%!s(int=11)', got '%!s(int=24)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var num int\n    var count int\n    var count_max int\n    var num_max int\n    for i = 1; i < N; i++ {\n        num = i\n        count = 0\n        for num != 0 {\n            if num & 1 == 1 {\n                count++\n            }\n            num = num >> 1\n        }\n        if count > count_max {\n            count_max = count\n            num_max = i\n        }\n    }\n    return num_max\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpremf378s_test.go:47: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpremf378s_test.go:47: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpremf378s_test.go:47: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123250,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmppuk2v0s6_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmppuk2v0s6_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmppuk2v0s6_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if i & N == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpiw5ax3f5_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpiw5ax3f5_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpiw5ax3f5_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n    // find the closest number with the same number of 1s\n    for N < (1 << 31) {\n        N++\n        if count == 0 {\n            break\n        }\n        if N & 1 == 1 {\n            count--\n        }\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp75gs3sp0_test.go:46: expected '%!s(int=10)', got '%!s(int=6)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp75gs3sp0_test.go:46: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    n := N\n    for i := 0; i < 32; i++ {\n        if n & (1 << i) == 0 {\n            n |= (1 << i)\n        } else {\n            n &= ^(1 << i)\n        }\n    }\n    return n\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmphdzdltji_test.go:36: expected '%!s(int=10)', got '%!s(int=4294967284)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmphdzdltji_test.go:36: expected '%!s(int=6)', got '%!s(int=4294967288)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmphdzdltji_test.go:36: expected '%!s(int=11)', got '%!s(int=4294967283)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpnq0scxgm_test.go:44: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpnq0scxgm_test.go:44: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpnq0scxgm_test.go:44: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpl26hbw39_test.go:37: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpl26hbw39_test.go:37: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpl26hbw39_test.go:37: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var aa int = 0\n    var bb int = 0\n    var cc int = 0\n    var dd int = 0\n    var ee int = 0\n    var ff int = 0\n    var gg int = 0\n    var hh int = 0\n    var ii int = 0\n    var jj int = 0\n    var kk int = 0\n    var ll int = 0\n    var mm int = 0\n    var nn int = 0\n    var oo int = 0\n    var pp int = 0\n    var qq int = 0\n    var rr int = 0\n    var ss int = 0\n    var tt int = 0\n    var uu int = 0\n    var vv int = 0\n    var ww int = 0\n    var xx int = 0\n    var yy int = 0\n    var zz int = 0\n    var aaa int = 0\n    var bbb int = 0\n    var ccc int = 0\n    var ddd int = 0\n    var eee int = 0\n    var fff int = 0\n    var ggg int = 0\n    var hhh int = 0\n    var iii int = 0\n    var jjj int = 0\n    var kkk int = 0\n    var lll int = 0\n    var mmm int = 0\n    var nnn int = 0\n    var ooo int = 0\n    var ppp int = 0\n    var qqq int = 0\n    var rrr int = 0\n    var sss int = 0\n    var ttt int = 0\n    var uuu int = 0\n    var vvv int\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpto0zqodq_test.go:80:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphp5zypny_test.go:119:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first bit that is 1\n    var i uint\n    for ; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // find the first bit that is 0\n    var j uint\n    for ; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    // if i == j, then there is no smaller number\n    if i == j {\n        return -1\n    }\n    // flip the bit at i\n    N = N & ^(1 << i)\n    // flip the bit at j\n    N = N | (1 << j)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp5n6tmdiv_test.go:50: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp5n6tmdiv_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp5n6tmdiv_test.go:50: expected '%!s(int=11)', got '%!s(int=9)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            for k = 0; k < N; k++ {\n                for l = 0; l < N; l++ {\n                    for m = 0; m < N; m++ {\n                        for n = 0; n < N; n++ {\n                            for o = 0; o < N; o++ {\n                                for p = 0; p < N; p++ {\n                                    for q = 0; q < N; q++ {\n                                        for r = 0; r < N; r++ {\n                                            for s = 0; s < N; s++ {\n                                                for t = 0; t < N; t++ {\n                                                    for u = 0; u < N; u++ {\n                                                        for v = 0; v < N; v++ {\n                                                            for w = 0; w < N; w++ {\n                                                                for x = 0; x < N; x++ {\n                                                                    for y = 0; y < N; y++ {\n                                                                        for z = 0; z < N; z++ {\n                                                                            fmt.Println(i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbapabnkf_test.go:62:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 0; i < N; i++ {\n        if (i & (i+1)) == 0 {\n            j = i\n        }\n    }\n    return j\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9msujnpb_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9msujnpb_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9msujnpb_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp8nk32sfm_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp8nk32sfm_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8nk32sfm_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var n int\n    var m int\n    var j int\n    var k int\n    var l int\n    var num int\n    var num1 int\n    var num2 int\n    var num3 int\n    var num4 int\n    var num5 int\n    var num6 int\n    var num7 int\n    var num8 int\n    var num9 int\n    var num10 int\n    var num11 int\n    var num12 int\n    var num13 int\n    var num14 int\n    var num15 int\n    var num16 int\n    var num17 int\n    var num18 int\n    var num19 int\n    var num20 int\n    var num21 int\n    var num22 int\n    var num23 int\n    var num24 int\n    var num25 int\n    var num26 int\n    var num27 int\n    var num28 int\n    var num29 int\n    var num30 int\n    var num31 int\n    var num32 int\n    var num33 int\n    var num34 int\n    var num35 int\n    var num36 int\n    var num37 int\n    var num38 int\n    var num39 int\n    var num40 int\n    var num41 int\n    var num42 int\n    var num43 int\n    var num44 int\n    var num45 int\n    var num46 int\n    var num47 int\n    var num48 int\n    var num49 int\n    var num50 int\n    var num51 int\n    var num52 int\n    var num53 int\n    var num54 int\n    var num55 int\n    var num56 int\n    var num57 int\n    var num58 int\n    var num59 int\n    var num60 int\n    var num61 int\n    var num62 int\n    var num63 int\n    var num64 int\n    var num65 int\n    var num66 int\n    var num67 int\n    var num68 int\n    var num69 int\n    var num70 int\n    var num71 int\n    var num72 int\n    var num73 int\n    var num74 int\n    var num75 int\n    var num76 int\n    var num77 int\n    var num78 int\n    var num79 int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123253,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8wanl2l9_test.go:97:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpt8oqhzin_test.go:37: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpt8oqhzin_test.go:37: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpt8oqhzin_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}