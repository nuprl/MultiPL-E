{
  "name": "mbpp_239_get_total_number_of_sequences",
  "language": "go_test.go",
  "prompt": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py",
  "prompt_terminology": "reworded",
  "tests": "func TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    } else {\n        return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n    }\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx0izsq1a_test.go:32: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx0izsq1a_test.go:32: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx0izsq1a_test.go:32: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_knwiau4_test.go:34: expected '%!s(int=4)', got '%!s(int=3025)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_knwiau4_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_knwiau4_test.go:34: expected '%!s(int=84)', got '%!s(int=2176)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n\n    return m * (m + 1) / 2 * (m + 2) / 3\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpav1ff345_test.go:36: expected '%!s(int=4)', got '%!s(int=220)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpav1ff345_test.go:36: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpav1ff345_test.go:36: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * (get_total_number_of_sequences(m - 1, n - 1) + get_total_number_of_sequences(m - 2, n - 1))\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpt6j4pmgv_test.go:34: expected '%!s(int=4)', got '%!s(int=11592)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpt6j4pmgv_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpt6j4pmgv_test.go:34: expected '%!s(int=84)', got '%!s(int=5880)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m - 1 + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmppd1puy0p_test.go:31: expected '%!s(int=4)', got '%!s(int=31)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmppd1puy0p_test.go:31: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmppd1puy0p_test.go:31: expected '%!s(int=84)', got '%!s(int=43)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    } else {\n        return (m - 2) * get_total_number_of_sequences(m, n - 1)\n    }\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpwftfuphw_test.go:32: expected '%!s(int=4)', got '%!s(int=5120)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpwftfuphw_test.go:32: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpwftfuphw_test.go:32: expected '%!s(int=84)', got '%!s(int=3136)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - (n - 1))\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpxgnvttvx_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpxgnvttvx_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpxgnvttvx_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m < 2 * n {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy8r0uwjz_test.go:34: expected '%!s(int=4)', got '%!s(int=90)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy8r0uwjz_test.go:34: expected '%!s(int=6)', got '%!s(int=5)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy8r0uwjz_test.go:34: expected '%!s(int=84)', got '%!s(int=440)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * get_total_number_of_sequences(m - 1, n - 1) + (m - 1) * get_total_number_of_sequences(m - 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp0x84s3if_test.go:34: expected '%!s(int=4)', got '%!s(int=11592)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp0x84s3if_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp0x84s3if_test.go:34: expected '%!s(int=84)', got '%!s(int=5880)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m < 2 || n < 1 {\n        return 0\n    }\n\n    if n == 1 {\n        return m\n    }\n\n    if n == 2 {\n        return m * (m - 1) / 2\n    }\n\n    return m * (m - 1) * (m - 2) / 6\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp41qf7dbm_test.go:40: expected '%!s(int=4)', got '%!s(int=120)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp41qf7dbm_test.go:40: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp41qf7dbm_test.go:40: expected '%!s(int=84)', got '%!s(int=560)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * get_total_number_of_sequences(m - 1, n - 1) + get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpfv3t9e14_test.go:34: expected '%!s(int=4)', got '%!s(int=4176)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpfv3t9e14_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpfv3t9e14_test.go:34: expected '%!s(int=84)', got '%!s(int=3165)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if m == 1 {\n        return 1\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=84)', got '%!s(int=100)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - (n - 1))\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmprnjdopok_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmprnjdopok_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmprnjdopok_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m < 2 || n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=4)', got '%!s(int=31)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m == 0 || n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpvjl01vqr_test.go:34: expected '%!s(int=4)', got '%!s(int=32)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpvjl01vqr_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpvjl01vqr_test.go:34: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp1yyzywyw_test.go:34: expected '%!s(int=4)', got '%!s(int=362880)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp1yyzywyw_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp1yyzywyw_test.go:34: expected '%!s(int=84)', got '%!s(int=50400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m < 2 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmptt22a5e5_test.go:34: expected '%!s(int=4)', got '%!s(int=14)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmptt22a5e5_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmptt22a5e5_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * get_total_number_of_sequences(m - 1, n - 1) + (m - 1) * get_total_number_of_sequences(m - 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp0x84s3if_test.go:34: expected '%!s(int=4)', got '%!s(int=11592)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp0x84s3if_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp0x84s3if_test.go:34: expected '%!s(int=84)', got '%!s(int=5880)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpcaa_3zmr_test.go:34: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpcaa_3zmr_test.go:34: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpcaa_3zmr_test.go:34: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170380 stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmp8_ykhhc4_test.go:9 +0xb6 fp=0xc020170390 sp=0xc020170388 pc=0x50a6b6\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x5c fp=0xc0201703c0 sp=0xc020170390 pc=0x50a65c\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc0201703f0 sp=0xc0201703c0 pc=0x50a685\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc020170420 sp=0xc0201703f0 pc=0x50a685\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc020170450 sp=0xc020170420 pc=0x50a685\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc020170480 sp=0xc020170450 pc=0x50a685\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc0201704b0 sp=0xc020170480 pc=0x50a685\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc0201704e0 sp=0xc0201704b0 pc=0x50a685\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmp8_ykhhc4_test.go:16 +0x85 fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * (m - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp4zrd4xci_test.go:34: expected '%!s(int=4)', got '%!s(int=720)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp4zrd4xci_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp4zrd4xci_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    total := 0\n    for i := 2; i <= m; i++ {\n        total += get_total_number_of_sequences(i, n - 1)\n    }\n    return total\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpczmy52e7_test.go:35: expected '%!s(int=4)', got '%!s(int=495)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpczmy52e7_test.go:35: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpczmy52e7_test.go:35: expected '%!s(int=84)', got '%!s(int=680)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    if n == 2 {\n        return m * (m - 1)\n    }\n\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c7gln3z_test.go:36: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c7gln3z_test.go:36: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c7gln3z_test.go:36: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    var total int = 0\n    for i := 2; i <= m; i++ {\n        total += get_total_number_of_sequences(i - 1, n - 1)\n    }\n    return total\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpffjrjd6g_test.go:35: expected '%!s(int=4)', got '%!s(int=210)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpffjrjd6g_test.go:35: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpffjrjd6g_test.go:35: expected '%!s(int=84)', got '%!s(int=560)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m == 0 || n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmphh6jcv4n_test.go:34: expected '%!s(int=4)', got '%!s(int=32)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmphh6jcv4n_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmphh6jcv4n_test.go:34: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if m == 1 {\n        return 1\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpcneko7wb_test.go:34: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpcneko7wb_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpcneko7wb_test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    if n == 3 {\n        return m * (m + 1) * (m + 2) / 6\n    }\n    if n == 4 {\n        return m * (m + 1) * (m + 2) * (m + 3) / 24\n    }\n    if n == 5 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) / 120\n    }\n    if n == 6 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) * (m + 5) / 720\n    }\n    if n == 7 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) * (m + 5) * (m + 6) / 5040\n    }\n    if n == 8 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) * (m + 5) * (m + 6) * (m + 7) / 40320\n    }\n    if n == 9 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) * (m + 5) * (m + 6) * (m + 7) * (m + 8) / 362880\n    }\n    if n == 10 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) * (m + 5) * (m + 6) * (m + 7) * (m + 8) * (m + 9) / 3628800\n    }\n    if n == 11 {\n        return m * (m + 1) * (m + 2) * (m + 3) * (m + 4) * (m + 5) * (m + 6) * (m + 7) * (m + 8) * (m + 9) * (m + 10) / 39916800\n    }\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpphugsabi_test.go:43:6: expected '(', found TestGet_Total_Number_Of_Sequences\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if m == 1 {\n        return 1\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=84)', got '%!s(int=100)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) * (m + 2) / 6\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2i74hxjg_test.go:34: expected '%!s(int=4)', got '%!s(int=220)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2i74hxjg_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2i74hxjg_test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1) / 2\n    }\n    return (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7wgksc9y_test.go:34: expected '%!s(int=4)', got '%!s(int=2016)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7wgksc9y_test.go:34: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7wgksc9y_test.go:34: expected '%!s(int=84)', got '%!s(int=1575)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    var result int\n    for i := 2; i <= m; i++ {\n        result += get_total_number_of_sequences(i, n - 1)\n    }\n    return result\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp8ery3j0u_test.go:35: expected '%!s(int=4)', got '%!s(int=660)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp8ery3j0u_test.go:35: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp8ery3j0u_test.go:35: expected '%!s(int=84)', got '%!s(int=800)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpfpg53yzv_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpfpg53yzv_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpfpg53yzv_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp1yyzywyw_test.go:34: expected '%!s(int=4)', got '%!s(int=362880)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp1yyzywyw_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp1yyzywyw_test.go:34: expected '%!s(int=84)', got '%!s(int=50400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n\n    if m < 2 {\n        return 0\n    }\n\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp239qzqcm_test.go:36: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp239qzqcm_test.go:36: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp239qzqcm_test.go:36: expected '%!s(int=84)', got '%!s(int=35)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}