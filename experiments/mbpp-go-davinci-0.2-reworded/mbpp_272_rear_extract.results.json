{
  "name": "mbpp_272_rear_extract",
  "language": "go_test.go",
  "prompt": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py",
  "prompt_terminology": "reworded",
  "tests": "func TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    result := []int{}\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplczb4en7_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplczb4en7_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplczb4en7_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplczb4en7_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplczb4en7_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplczb4en7_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, v := range test_list {\n        result = append(result, v[len(v)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvv8gkwi7_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu11824ey_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, element := range test_list {\n        result = append(result, element[len(element)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpky1gqecw_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpky1gqecw_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpky1gqecw_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpky1gqecw_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpky1gqecw_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpky1gqecw_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, sublist := range test_list {\n        rear_list = append(rear_list, sublist[len(sublist)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0in14tcd_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0in14tcd_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0in14tcd_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0in14tcd_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0in14tcd_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0in14tcd_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9i43nw8l_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9i43nw8l_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9i43nw8l_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, i := range test_list {\n        result = append(result, i[len(i)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_e5fimt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0_e5fimt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0_e5fimt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0_e5fimt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0_e5fimt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0_e5fimt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu11824ey_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        if len(list) == 0 {\n            result = append(result, 0)\n        } else {\n            result = append(result, list[len(list)-1].(int))\n        }\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn0ethmu__test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn0ethmu__test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn0ethmu__test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn0ethmu__test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn0ethmu__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn0ethmu__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, v := range test_list {\n        result = append(result, v[len(v)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvv8gkwi7_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, element := range test_list {\n        result = append(result, element[len(element)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpky1gqecw_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpky1gqecw_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpky1gqecw_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpky1gqecw_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpky1gqecw_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpky1gqecw_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, sub_list := range test_list {\n        rear_list = append(rear_list, sub_list[len(sub_list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt876olr4_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt876olr4_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt876olr4_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt876olr4_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt876olr4_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt876olr4_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzo14dics_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzo14dics_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzo14dics_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzo14dics_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzo14dics_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzo14dics_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, v := range test_list {\n        result = append(result, v[len(v)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvv8gkwi7_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, v := range test_list {\n        result = append(result, v[len(v)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvv8gkwi7_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvv8gkwi7_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvv8gkwi7_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9i43nw8l_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9i43nw8l_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9i43nw8l_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9i43nw8l_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9i43nw8l_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9i43nw8l_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9i43nw8l_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu11824ey_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list) - 1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu11824ey_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu11824ey_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu11824ey_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    result := make([]int, len(test_list))\n    for i, _ := range test_list {\n        result[i] = test_list[i][len(test_list[i]) - 1].(int)\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1v1lupld_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1v1lupld_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1v1lupld_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1v1lupld_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1v1lupld_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1v1lupld_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        if len(list) > 0 {\n            result = append(result, list[len(list)-1].(int))\n        }\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt7chs5vj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt7chs5vj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt7chs5vj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt7chs5vj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt7chs5vj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt7chs5vj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var rear_list []int\n    for _, list := range test_list {\n        rear_list = append(rear_list, list[len(list)-1].(int))\n    }\n    return rear_list\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp788imwko_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp788imwko_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp788imwko_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, x := range test_list {\n        result = append(result, x[len(x)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb3jccis8_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb3jccis8_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb3jccis8_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb3jccis8_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb3jccis8_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb3jccis8_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sublist := range test_list {\n        result = append(result, sublist[len(sublist)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3qh573j_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx3qh573j_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx3qh573j_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    result := make([]int, len(test_list))\n    for i, v := range test_list {\n        result[i] = v[len(v)-1].(int)\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm7us8sgi_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm7us8sgi_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm7us8sgi_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm7us8sgi_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm7us8sgi_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm7us8sgi_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, sub_list := range test_list {\n        result = append(result, sub_list[len(sub_list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ju0zokt_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ju0zokt_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ju0zokt_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        result = append(result, list[len(list)-1].(int))\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517372,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_oqekcpj_test.go:24:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:24:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:25:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:25:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_oqekcpj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_oqekcpj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list of lists and returns a list containing the rear element of each list.\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        if len(list) > 0 {\n            result = append(result, list[len(list)-1].(int))\n        }\n    }\n    return result\n}\n\nfunc TestRear_Extract(t *testing.T) {\n  candidate := rear_extract\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },\n     { actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123256,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt7chs5vj_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt7chs5vj_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt7chs5vj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt7chs5vj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt7chs5vj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt7chs5vj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}