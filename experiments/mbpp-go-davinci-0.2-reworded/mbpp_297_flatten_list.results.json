{
  "name": "mbpp_297_flatten_list",
  "language": "go_test.go",
  "prompt": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py",
  "prompt_terminology": "reworded",
  "tests": "func TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch t := list1.(type) {\n    case []interface{}:\n        for _, v := range t {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, t)\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpyttemw78_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpyttemw78_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpyttemw78_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case int:\n        list = append(list, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []int:\n        for _, v := range list1.([]int) {\n            result = append(result, v)\n        }\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpyr9pftmo_test.go:39: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=20) %!s(int=30) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpyr9pftmo_test.go:39: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpyr9pftmo_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch v := list1.(type) {\n    case []interface{}:\n        for _, u := range v {\n            list = append(list, flatten_list(u)...)\n        }\n    case int:\n        list = append(list, v)\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsc2gfejt_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsc2gfejt_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsc2gfejt_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case []int:\n        list = list1.([]int)\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    default:\n        list = append(list, list1.(int))\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\npanic: interface conversion: interface {} is [][]int, not int [recovered]\n\tpanic: interface conversion: interface {} is [][]int, not int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523ae0, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523ae0, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.flatten_list(0x51a060, 0xc0000c2ee0, 0xc00003e200, 0xd, 0x10)\n\t/tmp/tmpo4235obb_test.go:19 +0x2cc\ncommand-line-arguments_test.TestFlatten_List(0xc000001380)\n\t/tmp/tmpo4235obb_test.go:32 +0x4a8\ntesting.tRunner(0xc000001380, 0x54f5a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch v := list1.(type) {\n    case int:\n        result = append(result, v)\n    case []interface{}:\n        for _, u := range v {\n            result = append(result, flatten_list(u)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp6bkk77m3_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp6bkk77m3_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp6bkk77m3_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []int:\n        for _, v := range list1.([]int) {\n            result = append(result, v)\n        }\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpyr9pftmo_test.go:39: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=20) %!s(int=30) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpyr9pftmo_test.go:39: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpyr9pftmo_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch v := list1.(type) {\n    case []interface{}:\n        for _, u := range v {\n            list2 = append(list2, flatten_list(u)...)\n        }\n    case int:\n        list2 = append(list2, v)\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpgbid56xx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpgbid56xx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpgbid56xx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        for _, v := range list {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpvth1p_bw_test.go:38: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpvth1p_bw_test.go:38: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpvth1p_bw_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpw0m_23y3_test.go:39: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpw0m_23y3_test.go:39: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpw0m_23y3_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch v := list1.(type) {\n    case []interface{}:\n        for _, val := range v {\n            result = append(result, flatten_list(val)...)\n        }\n    case int:\n        result = append(result, v)\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpo4hs04dm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpo4hs04dm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpo4hs04dm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch v := list1.(type) {\n    case []interface{}:\n        for _, v1 := range v {\n            result = append(result, flatten_list(v1)...)\n        }\n    case int:\n        result = append(result, v)\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmps78xg842_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmps78xg842_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmps78xg842_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n        case []interface{}:\n            for _, v := range list1.([]interface{}) {\n                result = append(result, flatten_list(v)...)\n            }\n        case int:\n            result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpa_013i1k_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpa_013i1k_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpa_013i1k_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case int:\n        list = append(list, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}