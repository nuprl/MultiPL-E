{
  "name": "mbpp_630_get_coordinates",
  "language": "go_test.go",
  "prompt": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py",
  "prompt_terminology": "reworded",
  "tests": "func TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, i := range tup_slice {\n            tup_int = append(tup_int, i.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int), v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, v := range tup.([]interface{}) {\n            tup_int = append(tup_int, v.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n",
    "    var result [][]int\n    var x, y int\n    for _, tup := range test_tup {\n        x = tup.([]interface{})[0].(int)\n        y = tup.([]interface{})[1].(int)\n        result = append(result, []int{x, y})\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        var temp []int\n        for _, v := range tup.([]interface{}) {\n            temp = append(temp, v.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    // Extract the coordinates from the test tuple.\n    test_coordinates := test_tup[0].([][]int)\n    // Extract the expected coordinates from the test tuple.\n    expected_coordinates := test_tup[1].([][]int)\n    // Extract the actual coordinates from the test tuple.\n    actual_coordinates := get_adjacent_coordinates(test_coordinates)\n    // Check if the actual coordinates are equal to the expected coordinates.\n    if !are_coordinates_equal(expected_coordinates, actual_coordinates) {\n        // If not, then return an error.\n        return [][]int{[]int{-1, -1}}\n    }\n    // If they are equal, then return the actual coordinates.\n    return actual_coordinates\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []int:\n            result = append(result, tup)\n        case []interface{}:\n            result = append(result, get_coordinates(tup)...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        tup_arr := tup.([]interface{})\n        var tup_int []int\n        for _, tup_elem := range tup_arr {\n            tup_int = append(tup_int, int(tup_elem.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n",
    "    var coordinates [][]int\n    for _, tup := range test_tup {\n        var tup_coordinates []int\n        for _, coord := range tup.([]interface{}) {\n            tup_coordinates = append(tup_coordinates, int(coord.(float64)))\n        }\n        coordinates = append(coordinates, tup_coordinates)\n    }\n    return coordinates\n}\n",
    "    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, val := range tup.([]interface{}) {\n            coordinate = append(coordinate, val.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n",
    "    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        case [][]int:\n            for _, v1 := range v.([][]int) {\n                result = append(result, v1)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, val := range tup_slice {\n            tup_int = append(tup_int, val.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n",
    "    var coordinates [][]int\n    for _, tup := range test_tup {\n        coordinates = append(coordinates, tup.([]int))\n    }\n    return coordinates\n}\n"
  ]
}