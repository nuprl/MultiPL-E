{
  "name": "mbpp_117_list_to_float",
  "language": "go_test.go",
  "prompt": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py",
  "prompt_terminology": "reworded",
  "tests": "func TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3d3xo5bw_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3d3xo5bw_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3d3xo5bw_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3d3xo5bw_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3d3xo5bw_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3d3xo5bw_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3d3xo5bw_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3d3xo5bw_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3d3xo5bw_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, inner_list := range test_list {\n        for i, element := range inner_list {\n            if value, ok := element.(int); ok {\n                inner_list[i] = float64(value)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2clsbmcd_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2clsbmcd_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2clsbmcd_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2clsbmcd_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2clsbmcd_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2clsbmcd_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2clsbmcd_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2clsbmcd_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2clsbmcd_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var new_list [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(item.(int)))\n            case string:\n                new_sublist = append(new_sublist, item.(string))\n            case float64:\n                new_sublist = append(new_sublist, item.(float64))\n            }\n        }\n        new_list = append(new_list, new_sublist)\n    }\n    return new_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8rrlb3ea_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8rrlb3ea_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8rrlb3ea_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8rrlb3ea_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8rrlb3ea_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8rrlb3ea_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8rrlb3ea_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8rrlb3ea_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8rrlb3ea_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplrl01rz__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrl01rz__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrl01rz__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrl01rz__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var new_list [][]interface{}\n    for _, list := range test_list {\n        var new_list_item []interface{}\n        for _, item := range list {\n            switch item.(type) {\n            case int:\n                new_list_item = append(new_list_item, float64(item.(int)))\n            case float64:\n                new_list_item = append(new_list_item, item.(float64))\n            case string:\n                new_list_item = append(new_list_item, item.(string))\n            }\n        }\n        new_list = append(new_list, new_list_item)\n    }\n    return new_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqw_rg_os_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqw_rg_os_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw_rg_os_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw_rg_os_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqw_rg_os_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw_rg_os_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw_rg_os_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqw_rg_os_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqw_rg_os_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa86yu58q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6q3sddpa_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6q3sddpa_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q3sddpa_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q3sddpa_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6q3sddpa_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q3sddpa_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q3sddpa_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6q3sddpa_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q3sddpa_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk8iv6jp__test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpk8iv6jp__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk8iv6jp__test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpk8iv6jp__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\", test_list[i][j])\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdr2mkbnj_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdr2mkbnj_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdr2mkbnj_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdr2mkbnj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdr2mkbnj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdr2mkbnj_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdr2mkbnj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdr2mkbnj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdr2mkbnj_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sub_list := range test_list {\n        var new_sub_list []interface{}\n        for _, item := range sub_list {\n            switch item.(type) {\n            case int:\n                new_sub_list = append(new_sub_list, float64(item.(int)))\n            case float64:\n                new_sub_list = append(new_sub_list, item.(float64))\n            case string:\n                new_sub_list = append(new_sub_list, item.(string))\n            }\n        }\n        result = append(result, new_sub_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr2l5_7gz_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr2l5_7gz_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr2l5_7gz_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr2l5_7gz_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr2l5_7gz_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr2l5_7gz_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr2l5_7gz_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr2l5_7gz_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr2l5_7gz_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = float64(test_list[i][j].(float64))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcsy0q4s__test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcsy0q4s__test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcsy0q4s__test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcsy0q4s__test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24an5ops_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24an5ops_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpurdxtj61_test.go:19:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpurdxtj61_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpurdxtj61_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurdxtj61_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurdxtj61_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpurdxtj61_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurdxtj61_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurdxtj61_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpurdxtj61_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurdxtj61_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurdxtj61_test.go:36:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa86yu58q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var new_list [][]interface{}\n    for _, sub_list := range test_list {\n        var new_sub_list []interface{}\n        for _, item := range sub_list {\n            switch item.(type) {\n            case int:\n                new_sub_list = append(new_sub_list, float64(item.(int)))\n            case string:\n                new_sub_list = append(new_sub_list, item)\n            case float64:\n                new_sub_list = append(new_sub_list, item)\n            default:\n                fmt.Println(\"Unsupported type\")\n            }\n        }\n        new_list = append(new_list, new_sub_list)\n    }\n    return new_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6q01f701_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6q01f701_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q01f701_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q01f701_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6q01f701_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q01f701_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q01f701_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6q01f701_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6q01f701_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, list := range test_list {\n        for j, element := range list {\n            if float_value, ok := element.(float64); ok {\n                test_list[i][j] = float_value\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp1_427nt_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp1_427nt_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp1_427nt_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp1_427nt_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp1_427nt_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp1_427nt_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp1_427nt_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp1_427nt_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp1_427nt_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphjpkonje_test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmphjpkonje_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch v := test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(v)\n            case string:\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzz9mcci3_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzz9mcci3_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz9mcci3_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz9mcci3_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzz9mcci3_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz9mcci3_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz9mcci3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzz9mcci3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz9mcci3_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                fmt.Println(\"Unknown type\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfewyo2om_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfewyo2om_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfewyo2om_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfewyo2om_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfewyo2om_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfewyo2om_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfewyo2om_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfewyo2om_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfewyo2om_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, list := range test_list {\n        for j, element := range list {\n            switch element.(type) {\n            case int:\n                test_list[i][j] = float64(element.(int))\n            case float64:\n                test_list[i][j] = element.(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb6yih7om_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb6yih7om_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6yih7om_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6yih7om_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb6yih7om_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6yih7om_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6yih7om_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb6yih7om_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6yih7om_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk8iv6jp__test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpk8iv6jp__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(len(test_list[i][j].(string)))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzkrsp_v5_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzkrsp_v5_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzkrsp_v5_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzkrsp_v5_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24an5ops_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimq0e8dz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpimq0e8dz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpimq0e8dz_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpimq0e8dz_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpimq0e8dz_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpimq0e8dz_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpimq0e8dz_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpimq0e8dz_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpimq0e8dz_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                if test_list[i][j] == \"NaN\" {\n                    test_list[i][j] = nil\n                } else {\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiqj_87kb_test.go:24:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpiqj_87kb_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqj_87kb_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqj_87kb_test.go:41:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqj_87kb_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqj_87kb_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqj_87kb_test.go:42:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqj_87kb_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqj_87kb_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqj_87kb_test.go:43:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqj_87kb_test.go:43:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpathhnetc_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, list := range test_list {\n        for i, element := range list {\n            if val, ok := element.(int); ok {\n                list[i] = float64(val)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ef8lhnz_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ef8lhnz_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ef8lhnz_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ef8lhnz_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ef8lhnz_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ef8lhnz_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ef8lhnz_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6ef8lhnz_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6ef8lhnz_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(v)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbv06aj4p_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sub_list := range test_list {\n        var sub_result []interface{}\n        for _, item := range sub_list {\n            switch item.(type) {\n            case int:\n                sub_result = append(sub_result, float64(item.(int)))\n            case float64:\n                sub_result = append(sub_result, item.(float64))\n            case string:\n                sub_result = append(sub_result, item.(string))\n            }\n        }\n        result = append(result, sub_result)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7jsor4aj_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jsor4aj_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jsor4aj_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jsor4aj_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jsor4aj_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jsor4aj_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jsor4aj_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7jsor4aj_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7jsor4aj_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); ok {\n                continue\n            } else if _, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(test_list[i][j].(int))\n            } else if _, ok := test_list[i][j].(string); ok {\n                test_list[i][j] = float64(test_list[i][j].(string))\n            } else {\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9zh11819_test.go:17:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp9zh11819_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9zh11819_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9zh11819_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9zh11819_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9zh11819_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9zh11819_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9zh11819_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9zh11819_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9zh11819_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9zh11819_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24an5ops_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp24an5ops_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp24an5ops_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, row := range test_list {\n        for j, col := range row {\n            switch col.(type) {\n            case int:\n                test_list[i][j] = float64(col.(int))\n            case float64:\n                test_list[i][j] = col.(float64)\n            default:\n                test_list[i][j] = col\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0bp_vos9_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0bp_vos9_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0bp_vos9_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0bp_vos9_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0bp_vos9_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0bp_vos9_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0bp_vos9_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0bp_vos9_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0bp_vos9_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, k := range v {\n            switch k.(type) {\n            case int:\n                test_list[i][j] = float64(k.(int))\n            case float64:\n                test_list[i][j] = k.(float64)\n            case string:\n                test_list[i][j] = float64(k.(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpngsjcef0_test.go:18:42: cannot convert k.(string) (type string) to type float64\n/tmp/tmpngsjcef0_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpngsjcef0_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpngsjcef0_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpngsjcef0_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpngsjcef0_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpngsjcef0_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpngsjcef0_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpngsjcef0_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpngsjcef0_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpngsjcef0_test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcjb4xf8d_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp41k9b7tg_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp41k9b7tg_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41k9b7tg_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41k9b7tg_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41k9b7tg_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            default:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpan8088tz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpan8088tz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpan8088tz_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpan8088tz_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpan8088tz_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpan8088tz_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpan8088tz_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpan8088tz_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpan8088tz_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                if test_list[i][j].(string) == \"\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnu40wivn_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnu40wivn_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnu40wivn_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnu40wivn_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnu40wivn_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnu40wivn_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnu40wivn_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnu40wivn_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnu40wivn_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sub_list := range test_list {\n        var result_sub_list []interface{}\n        for _, item := range sub_list {\n            switch item.(type) {\n            case int:\n                result_sub_list = append(result_sub_list, float64(item.(int)))\n            case float64:\n                result_sub_list = append(result_sub_list, item.(float64))\n            case string:\n                if item.(string) == \"NaN\" {\n                    result_sub_list = append(result_sub_list, item.(string))\n                } else {\n                    result_sub_list = append(result_sub_list, item.(string))\n                }\n            default:\n                result_sub_list = append(result_sub_list, item)\n            }\n        }\n        result = append(result, result_sub_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmputls7ncy_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmputls7ncy_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmputls7ncy_test.go:41:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmputls7ncy_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmputls7ncy_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmputls7ncy_test.go:42:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmputls7ncy_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmputls7ncy_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmputls7ncy_test.go:43:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpathhnetc_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa86yu58q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                if test_list[i][j] == \"NaN\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq0l1l0sy_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0l1l0sy_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0l1l0sy_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0l1l0sy_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0l1l0sy_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0l1l0sy_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0l1l0sy_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0l1l0sy_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0l1l0sy_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp261lel6d_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk8iv6jp__test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpk8iv6jp__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element.(float64))\n            case string:\n                new_list = append(new_list, element.(string))\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgq91ql9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx93fdhpi_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpx93fdhpi_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx93fdhpi_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx93fdhpi_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx93fdhpi_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123991,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_wba2c8y_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_wba2c8y_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_wba2c8y_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_wba2c8y_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                if test_list[i][j].(string) == \"NaN\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph3aigu2__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph3aigu2__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph3aigu2__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph3aigu2__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxsevv5fk_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxsevv5fk_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxsevv5fk_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxsevv5fk_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt196is5v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element)\n            default:\n                new_list = append(new_list, element)\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123991,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0itm1i2_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl0itm1i2_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0itm1i2_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0itm1i2_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl0itm1i2_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0itm1i2_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0itm1i2_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl0itm1i2_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0itm1i2_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt196is5v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\", &test_list[i][j])\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123991,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa_5kjk6b_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa_5kjk6b_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_5kjk6b_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_5kjk6b_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa_5kjk6b_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_5kjk6b_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_5kjk6b_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa_5kjk6b_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_5kjk6b_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                default:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp20qzzdzl_test.go:19:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp20qzzdzl_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp20qzzdzl_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp20qzzdzl_test.go:36:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp20qzzdzl_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp20qzzdzl_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp20qzzdzl_test.go:37:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp20qzzdzl_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp20qzzdzl_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp20qzzdzl_test.go:38:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp20qzzdzl_test.go:38:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element.(float64))\n            case string:\n                new_list = append(new_list, element.(string))\n            default:\n                fmt.Println(\"Unsupported type\")\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5ikkvsz_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5ikkvsz_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5ikkvsz_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5ikkvsz_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5ikkvsz_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5ikkvsz_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5ikkvsz_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr5ikkvsz_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr5ikkvsz_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeam47yva_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeam47yva_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeam47yva_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeam47yva_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeam47yva_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeam47yva_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeam47yva_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeam47yva_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeam47yva_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, w := range v {\n            switch w.(type) {\n            case int:\n                test_list[i][j] = float64(w.(int))\n            case float64:\n                test_list[i][j] = w.(float64)\n            case string:\n                test_list[i][j] = 0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3nebh06f_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3nebh06f_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3nebh06f_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3nebh06f_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3nebh06f_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3nebh06f_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3nebh06f_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3nebh06f_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3nebh06f_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6jd2o12r_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6jd2o12r_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:53:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6jd2o12r_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:54:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:55:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6jd2o12r_test.go:55:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:55:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, list := range test_list {\n        for j, element := range list {\n            if element, ok := element.(int); ok {\n                test_list[i][j] = float64(element)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp76i_qjti_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp76i_qjti_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp76i_qjti_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp76i_qjti_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp76i_qjti_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp76i_qjti_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp76i_qjti_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp76i_qjti_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp76i_qjti_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); !ok {\n                if _, ok := test_list[i][j].(int); ok {\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5k8tpwhr_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:29:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:30:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:31:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(val)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsll1gi51_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsll1gi51_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsll1gi51_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsll1gi51_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(len(test_list[i][j].(string)))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123991,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp562kmkoa_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp562kmkoa_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp562kmkoa_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp562kmkoa_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp562kmkoa_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp562kmkoa_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp562kmkoa_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp562kmkoa_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp562kmkoa_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var new_list [][]interface{}\n    for _, sub_list := range test_list {\n        var new_sub_list []interface{}\n        for _, element := range sub_list {\n            switch element.(type) {\n                case int:\n                    new_sub_list = append(new_sub_list, float64(element.(int)))\n                case float64:\n                    new_sub_list = append(new_sub_list, element)\n                case string:\n                    new_sub_list = append(new_sub_list, element)\n                default:\n                    new_sub_list = append(new_sub_list, element)\n            }\n        }\n        new_list = append(new_list, new_sub_list)\n    }\n    return new_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo57xqhge_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo57xqhge_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo57xqhge_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo57xqhge_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo57xqhge_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo57xqhge_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo57xqhge_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo57xqhge_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo57xqhge_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); ok {\n                continue\n            } else if _, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(test_list[i][j].(int))\n            } else if _, ok := test_list[i][j].(string); ok {\n                fmt.Println(test_list[i][j])\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp41lyqhm8_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41lyqhm8_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41lyqhm8_test.go:31:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41lyqhm8_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41lyqhm8_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41lyqhm8_test.go:32:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41lyqhm8_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41lyqhm8_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41lyqhm8_test.go:33:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            default:\n                continue\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4le6xzeq_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp4le6xzeq_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4le6xzeq_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4le6xzeq_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4le6xzeq_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4le6xzeq_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4le6xzeq_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4le6xzeq_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4le6xzeq_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4le6xzeq_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4le6xzeq_test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuz9f20bi_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuz9f20bi_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuz9f20bi_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuz9f20bi_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuz9f20bi_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuz9f20bi_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuz9f20bi_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuz9f20bi_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuz9f20bi_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(v)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbv06aj4p_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = float64(0)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppjlt25yk_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppjlt25yk_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppjlt25yk_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppjlt25yk_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppjlt25yk_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppjlt25yk_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppjlt25yk_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppjlt25yk_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppjlt25yk_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6jd2o12r_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6jd2o12r_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:53:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6jd2o12r_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:54:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:55:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6jd2o12r_test.go:55:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6jd2o12r_test.go:55:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt196is5v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = test_list[i][j]\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp59zfwoex_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp59zfwoex_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp59zfwoex_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp59zfwoex_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp59zfwoex_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp59zfwoex_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp59zfwoex_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp59zfwoex_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp59zfwoex_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123991,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_wba2c8y_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_wba2c8y_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_wba2c8y_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_wba2c8y_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_wba2c8y_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpathhnetc_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpathhnetc_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpathhnetc_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphjpkonje_test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmphjpkonje_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa86yu58q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = 0.0\n            default:\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphn8rk4us_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphn8rk4us_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphn8rk4us_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphn8rk4us_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphn8rk4us_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphn8rk4us_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphn8rk4us_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphn8rk4us_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphn8rk4us_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element.(float64))\n            default:\n                new_list = append(new_list, element)\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxr_0i5bi_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxr_0i5bi_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxr_0i5bi_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxr_0i5bi_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxr_0i5bi_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxr_0i5bi_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxr_0i5bi_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxr_0i5bi_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxr_0i5bi_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, k := range v {\n            switch k.(type) {\n            case int:\n                test_list[i][j] = float64(k.(int))\n            case int8:\n                test_list[i][j] = float64(k.(int8))\n            case int16:\n                test_list[i][j] = float64(k.(int16))\n            case int32:\n                test_list[i][j] = float64(k.(int32))\n            case int64:\n                test_list[i][j] = float64(k.(int64))\n            case uint:\n                test_list[i][j] = float64(k.(uint))\n            case uint8:\n                test_list[i][j] = float64(k.(uint8))\n            case uint16:\n                test_list[i][j] = float64(k.(uint16))\n            case uint32:\n                test_list[i][j] = float64(k.(uint32))\n            case uint64:\n                test_list[i][j] = float64(k.(uint64))\n            case float32:\n                test_list[i][j] = float64(k.(float32))\n            case float64:\n                test_list[i][j] = float64(k.(float64))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_kuupgey_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_kuupgey_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_kuupgey_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_kuupgey_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_kuupgey_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_kuupgey_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_kuupgey_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_kuupgey_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_kuupgey_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsrx9uays_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsrx9uays_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsrx9uays_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsrx9uays_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsrx9uays_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsrx9uays_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsrx9uays_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsrx9uays_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsrx9uays_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element.(float64))\n            case string:\n                new_list = append(new_list, element.(string))\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgq91ql9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = test_list[i][j].(string)\n                default:\n                    fmt.Println(\"Error\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9vvx5bng_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9vvx5bng_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9vvx5bng_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9vvx5bng_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9vvx5bng_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9vvx5bng_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9vvx5bng_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9vvx5bng_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9vvx5bng_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                if test_list[i][j].(string) == \"NaN\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            default:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpivjpfh60_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivjpfh60_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivjpfh60_test.go:36:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivjpfh60_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivjpfh60_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivjpfh60_test.go:37:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivjpfh60_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivjpfh60_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivjpfh60_test.go:38:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphjpkonje_test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmphjpkonje_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphjpkonje_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphjpkonje_test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch v := test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(v)\n            case float64:\n                test_list[i][j] = v\n            case string:\n                if v == \"NaN\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            default:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ot9uxq1_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4ot9uxq1_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ot9uxq1_test.go:38:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ot9uxq1_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4ot9uxq1_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ot9uxq1_test.go:39:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ot9uxq1_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4ot9uxq1_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4ot9uxq1_test.go:40:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); ok {\n                continue\n            } else if _, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(test_list[i][j].(int))\n            } else if _, ok := test_list[i][j].(string); ok {\n                test_list[i][j] = float64(test_list[i][j].(string))\n            } else {\n                test_list[i][j] = 0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpadl_hhyx_test.go:17:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpadl_hhyx_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpadl_hhyx_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpadl_hhyx_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpadl_hhyx_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpadl_hhyx_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpadl_hhyx_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpadl_hhyx_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpadl_hhyx_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpadl_hhyx_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpadl_hhyx_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = float64(test_list[i][j].(float64))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcsy0q4s__test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcsy0q4s__test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcsy0q4s__test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcsy0q4s__test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcsy0q4s__test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp261lel6d_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, v2 := range v {\n            switch v2.(type) {\n            case int:\n                test_list[i][j] = float64(v2.(int))\n            case float64:\n                test_list[i][j] = v2.(float64)\n            case string:\n                test_list[i][j] = v2.(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp629q09_3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp629q09_3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp629q09_3_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp629q09_3_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = \"N/A\"\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2cxzurfu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2cxzurfu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2cxzurfu_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2cxzurfu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2cxzurfu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2cxzurfu_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2cxzurfu_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2cxzurfu_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2cxzurfu_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    if test_list[i][j] == \"NaN\" {\n                        test_list[i][j] = nil\n                    } else {\n                        test_list[i][j] = nil\n                    }\n                default:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj2pfv1ld_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj2pfv1ld_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj2pfv1ld_test.go:40:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj2pfv1ld_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj2pfv1ld_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj2pfv1ld_test.go:41:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj2pfv1ld_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj2pfv1ld_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj2pfv1ld_test.go:42:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                fmt.Println(\"string\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp44hpbjtz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44hpbjtz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44hpbjtz_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44hpbjtz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44hpbjtz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44hpbjtz_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44hpbjtz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44hpbjtz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44hpbjtz_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx93fdhpi_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpx93fdhpi_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx93fdhpi_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx93fdhpi_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx93fdhpi_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx93fdhpi_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt196is5v_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt196is5v_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt196is5v_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcjb4xf8d_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, v2 := range v {\n            switch v2.(type) {\n            case int:\n                test_list[i][j] = float64(v2.(int))\n            case float64:\n                test_list[i][j] = v2.(float64)\n            case string:\n                test_list[i][j] = 0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjm_dmtmm_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjm_dmtmm_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjm_dmtmm_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjm_dmtmm_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjm_dmtmm_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjm_dmtmm_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjm_dmtmm_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjm_dmtmm_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjm_dmtmm_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjladslw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case int8:\n                    test_list[i][j] = float64(test_list[i][j].(int8))\n                case int16:\n                    test_list[i][j] = float64(test_list[i][j].(int16))\n                case int32:\n                    test_list[i][j] = float64(test_list[i][j].(int32))\n                case int64:\n                    test_list[i][j] = float64(test_list[i][j].(int64))\n                case uint:\n                    test_list[i][j] = float64(test_list[i][j].(uint))\n                case uint8:\n                    test_list[i][j] = float64(test_list[i][j].(uint8))\n                case uint16:\n                    test_list[i][j] = float64(test_list[i][j].(uint16))\n                case uint32:\n                    test_list[i][j] = float64(test_list[i][j].(uint32))\n                case uint64:\n                    test_list[i][j] = float64(test_list[i][j].(uint64))\n                case float32:\n                    test_list[i][j] = float64(test_list[i][j].(float32))\n                case float64:\n                    test_list[i][j] = float64(test_list[i][j].(float64))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplrcnv88a_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrcnv88a_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrcnv88a_test.go:52:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrcnv88a_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrcnv88a_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrcnv88a_test.go:53:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrcnv88a_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrcnv88a_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrcnv88a_test.go:54:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, item := range list {\n            switch item.(type) {\n            case int:\n                new_list = append(new_list, float64(item.(int)))\n            case float64:\n                new_list = append(new_list, item)\n            case string:\n                new_list = append(new_list, item)\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9z821nrl_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9z821nrl_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9z821nrl_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9z821nrl_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9z821nrl_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9z821nrl_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9z821nrl_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9z821nrl_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9z821nrl_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    if test_list[i][j] == \"NaN\" {\n                        test_list[i][j] = nil\n                    } else {\n                        test_list[i][j] = float64(test_list[i][j].(string))\n                    }\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdc5wbl3x_test.go:20:50: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpdc5wbl3x_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdc5wbl3x_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc5wbl3x_test.go:36:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc5wbl3x_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdc5wbl3x_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc5wbl3x_test.go:37:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc5wbl3x_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdc5wbl3x_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc5wbl3x_test.go:38:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc5wbl3x_test.go:38:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph_er7ird_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph_er7ird_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph_er7ird_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph_er7ird_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph_er7ird_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph_er7ird_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph_er7ird_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph_er7ird_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph_er7ird_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = 0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1lja53rw_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1lja53rw_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1lja53rw_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1lja53rw_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1lja53rw_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1lja53rw_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1lja53rw_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1lja53rw_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1lja53rw_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                fmt.Println(\"String found\")\n                continue\n            default:\n                fmt.Println(\"Unknown type found\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaflql90n_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaflql90n_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaflql90n_test.go:38:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaflql90n_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaflql90n_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaflql90n_test.go:39:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaflql90n_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaflql90n_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaflql90n_test.go:40:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp261lel6d_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); !ok {\n                if _, ok := test_list[i][j].(int); ok {\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5k8tpwhr_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:29:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:30:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:31:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, list := range test_list {\n        for i, element := range list {\n            if value, ok := element.(int); ok {\n                list[i] = float64(value)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3zny3mqj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3zny3mqj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3zny3mqj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3zny3mqj_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8mxajopz_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8mxajopz_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8mxajopz_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8mxajopz_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8mxajopz_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8mxajopz_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8mxajopz_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8mxajopz_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8mxajopz_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeyu_8tvi_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeyu_8tvi_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeyu_8tvi_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeyu_8tvi_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, list := range test_list {\n        for i, item := range list {\n            switch item.(type) {\n            case int:\n                list[i] = float64(item.(int))\n            case string:\n                list[i] = float64(item.(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9qx1p65b_test.go:16:34: cannot convert item.(string) (type string) to type float64\n/tmp/tmp9qx1p65b_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9qx1p65b_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9qx1p65b_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9qx1p65b_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9qx1p65b_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9qx1p65b_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9qx1p65b_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9qx1p65b_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9qx1p65b_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9qx1p65b_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}