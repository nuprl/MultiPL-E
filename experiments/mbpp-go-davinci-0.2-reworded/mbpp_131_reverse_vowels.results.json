{
  "name": "mbpp_131_reverse_vowels",
  "language": "go_test.go",
  "prompt": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py",
  "prompt_terminology": "reworded",
  "tests": "func TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpch71jojy_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str1_runes := []rune(str1)\n    str1_vowels := []rune{}\n    str1_vowels_index := []int{}\n    for i, v := range str1_runes {\n        for _, vv := range vowels {\n            if v == vv {\n                str1_vowels = append(str1_vowels, v)\n                str1_vowels_index = append(str1_vowels_index, i)\n            }\n        }\n    }\n    for i, v := range str1_vowels_index {\n        str1_runes[v] = str1_vowels[len(str1_vowels)-1-i]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_indexes []int\n    var vowel_chars []string\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_indexes = append(vowel_indexes, i)\n                vowel_chars = append(vowel_chars, string(char))\n            }\n        }\n    }\n    for i, char := range str1 {\n        if contains(vowel_indexes, i) {\n            str2 += vowel_chars[len(vowel_chars)-1]\n            vowel_chars = vowel_chars[:len(vowel_chars)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphl2nq19w_test.go:23:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    // create a slice of the string\n    str1_slice := []string{}\n    // create a slice of the vowels\n    vowels_slice := []string{}\n    // loop through the string\n    for _, char := range str1 {\n        // if the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // append the character to the vowels slice\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // append the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // create a counter for the vowels slice\n    counter := 0\n    // loop through the string slice\n    for i, char := range str1_slice {\n        // if the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // replace the character with the vowel in the vowels slice\n            str1_slice[i] = vowels_slice[counter]\n            // increment the counter\n            counter++\n        }\n    }\n    // return the string slice as a string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqcr2zfz4_test.go:43:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmphh09504v_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpou6er7t__test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var stack []string\n\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            stack = append(stack, string(char))\n        }\n    }\n\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsz2w28sa_test.go:15:12: undefined: contains\n/tmp/tmpsz2w28sa_test.go:21:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpuz0w111p_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []string{}\n    var str1_vowels_runes = []rune{}\n    var str1_vowels_runes_reversed = []rune{}\n    var str1_vowels_reversed = []string{}\n    var str1_vowels_reversed_runes = []rune{}\n    var str1_vowels_reversed_runes_reversed = []rune{}\n    var str1_vowels_reversed_runes_reversed_string = \"\"\n    var str1_vowels_reversed_runes_reversed_string_runes = []rune{}\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed = []rune{}\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed_string = \"\"\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed_string_runes = []rune{}\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed_string_runes_reversed = []rune{}\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed_string_runes_reversed_string = \"\"\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed_string_runes_reversed_string_runes = []rune{}\n    var str1_vowels_reversed_runes_reversed_string_runes_reversed_string_runes_reversed_string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7w7n4l4z_test.go:26:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_runes_len = len(str1_runes)\n    var str1_runes_vowels []rune\n    var str1_runes_vowels_len int\n    var str1_runes_vowels_idx int\n    var str1_runes_vowels_idx_rev int\n    var str1_runes_vowels_idx_rev_tmp rune\n    var str1_runes_vowels_idx_tmp rune\n    var str1_runes_vowels_idx_tmp_rev int\n    var str1_runes_vowels_idx_tmp_rev_tmp rune\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx int\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp rune\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev int\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev_tmp rune\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev_tmp_idx int\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev_tmp_idx_tmp rune\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev_tmp_idx_tmp_rev int\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev_tmp_idx_tmp_rev_tmp rune\n    var str1_runes_vowels_idx_tmp_rev_tmp_idx_tmp_rev_tmp_idx_tmp\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkjgdwze8_test.go:29:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_array = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n    var i = 0\n\n    for _, char := range str1 {\n        str1_array = append(str1_array, string(char))\n    }\n\n    for _, char := range str1_array {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i = len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i = 0; i < len(str1_array); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if str1_array[i] == vowels[j] {\n                str1_array[i] = str1_vowels_reversed[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            }\n        }\n    }\n\n    for _, char := range str1_array {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x5363a0, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5363a0, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x5453e1, 0x3, 0xc00012c0aa, 0x6)\n\t/tmp/tmp43fzx7le_test.go:36 +0x7de\ncommand-line-arguments_test.TestReverse_Vowels(0xc000102600)\n\t/tmp/tmp43fzx7le_test.go:57 +0x8b\ntesting.tRunner(0xc000102600, 0x54f278)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_positions []int\n    var vowel_positions_reversed []int\n    var vowel_positions_reversed_index int\n\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_positions = append(vowel_positions, i)\n            }\n        }\n    }\n\n    for i := len(vowel_positions) - 1; i >= 0; i-- {\n        vowel_positions_reversed = append(vowel_positions_reversed, vowel_positions[i])\n    }\n\n    for i, char := range str1 {\n        if i == vowel_positions_reversed[vowel_positions_reversed_index] {\n            str2 += string(char)\n            vowel_positions_reversed_index++\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x5457df, 0x6, 0x4cd164, 0x5fa220)\n\t/tmp/tmpub8panhs_test.go:29 +0x5b6\ncommand-line-arguments_test.TestReverse_Vowels(0xc000001380)\n\t/tmp/tmpub8panhs_test.go:47 +0x53\ntesting.tRunner(0xc000001380, 0x54f1f8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Convert string to slice of runes\n    str_slice := []rune(str1)\n    // Create a slice of runes to hold the vowels\n    var vowels []rune\n    // Create a slice of runes to hold the consonants\n    var consonants []rune\n    // Iterate through the string slice\n    for _, char := range str_slice {\n        // Check if the current character is a vowel\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            // Append the current character to the vowels slice\n            vowels = append(vowels, char)\n        } else {\n            // Append the current character to the consonants slice\n            consonants = append(consonants, char)\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels)-1; i < j; i, j = i+1, j-1 {\n        vowels[i], vowels[j] = vowels[j], vowels[i]\n    }\n    // Iterate through the string slice\n    for i, char := range str_slice {\n        // Check if the current character is a vowel\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            // Replace the current character with the first character in the vowels slice\n            str_slice[i] = vowels[0]\n            // Remove the first character from the vowels slice\n            vowels = vowels[1:]\n        }\n    }\n    // Iterate through the string slice\n    for i, char := range str_slice {\n        // Check if the current character is a consonant\n        if char != 'a' && char != 'e' && char != 'i' && char != 'o' && char != 'u' {\n            // Replace the current character with the first character in the consonants slice\n            str_slice[i] = consonants[0]\n            // Remove the first character from the consonants slice\n            consonants = consonants[1:]\n        }\n    }\n    // Return the string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz69gvsbw_test.go:52:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_stack []string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfcucjlpj_test.go:14:12: undefined: contains\n/tmp/tmpfcucjlpj_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the non-vowels\n    non_vowels_slice := []string{}\n    // Create a slice of the reversed vowels\n    reversed_vowels_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1 := \"\"\n\n    // Loop through the string and add each character to the slice\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    // Loop through the slice and add each vowel to the vowels slice\n    for _, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            vowels_slice = append(vowels_slice, char)\n        } else {\n            non_vowels_slice = append(non_vowels_slice, char)\n        }\n    }\n\n    // Reverse the vowels slice\n    for i := len(vowels_slice) - 1; i >= 0; i-- {\n        reversed_vowels_slice = append(reversed_vowels_slice, vowels_slice[i])\n    }\n\n    // Loop through the string slice and add the reversed vowels and non-vowels to the reversed string slice\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            reversed_str1_slice = append(reversed_str1_slice, reversed_vowels_slice[0])\n            reversed_vowels_slice = reversed_vowels_slice[1:]\n        } else {\n            reversed_str1_slice = append(reversed_str1_slice,\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzks9rvt7_test.go:51:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    str1_array := []string{}\n    for _, char := range str1 {\n        str1_array = append(str1_array, string(char))\n    }\n    start := 0\n    end := len(str1_array) - 1\n    for start < end {\n        if !contains(vowels, str1_array[start]) {\n            start += 1\n        } else if !contains(vowels, str1_array[end]) {\n            end -= 1\n        } else {\n            str1_array[start], str1_array[end] = str1_array[end], str1_array[start]\n            start += 1\n            end -= 1\n        }\n    }\n    return strings.Join(str1_array, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwu_xoqmh_test.go:18:13: undefined: contains\n/tmp/tmpwu_xoqmh_test.go:20:20: undefined: contains\n/tmp/tmpwu_xoqmh_test.go:28:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_vowels_reversed_string string\n    var str1_vowels_reversed_string_final string\n    var str1_vowels_reversed_string_final_array []string\n    var str1_vowels_reversed_string_final_array_index int\n    var str1_vowels_reversed_string_final_array_index_final int\n    var str1_vowels_reversed_string_final_array_index_final_string string\n    var str1_vowels_reversed_string_final_array_index_final_string_final string\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array []string\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index int\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index_final int\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index_final_string string\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index_final_string_final string\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index_final_string_final_array []string\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index_final_string_final_array_index int\n    var str1_vowels_reversed_string_final_array_index_final_string_final_array_index_final_string_final_array_index_final int\n    var str1_vowels_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp99y7elgu_test.go:28:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []rune(str1)\n    var i, j int = 0, len(str2) - 1\n    for i < j {\n        if is_vowel(str2[i]) && is_vowel(str2[j]) {\n            str2[i], str2[j] = str2[j], str2[i]\n            i++\n            j--\n        } else if is_vowel(str2[i]) {\n            j--\n        } else {\n            i++\n        }\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9if2u8zk_test.go:13:12: undefined: is_vowel\n/tmp/tmp9if2u8zk_test.go:17:19: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the reversed vowels\n    reversed_vowels_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1 := \"\"\n    // Loop through the string\n    for _, char := range str1 {\n        // Append the string to the string slice\n        str1_slice = append(str1_slice, string(char))\n        // Check if the string is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // Append the vowel to the vowels slice\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels slice\n    for i := len(vowels_slice) - 1; i >= 0; i-- {\n        reversed_vowels_slice = append(reversed_vowels_slice, vowels_slice[i])\n    }\n    // Loop through the string slice\n    for _, char := range str1_slice {\n        // Check if the string is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // Append the reversed vowel to the reversed string slice\n            reversed_str1_slice = append(reversed_str1_slice, reversed_vowels_slice[0])\n            // Remove the vowel from the reversed vowels slice\n            reversed_vowels_slice = reversed_vowels_slice[1:]\n        } else {\n            // Append the string to the reversed string slice\n            reversed_str1_slice = append(reversed_str1_slice, string(char))\n        }\n    }\n    // Loop through the reversed string slice\n    for\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpth2b_uii_test.go:51:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // create a slice of the vowels\n    str1_vowels := []string{}\n    for _, char := range str1_slice {\n        if vowels[char] {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n    // reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n    // replace the vowels in the original string with the reversed vowels\n    for i, char := range str1_slice {\n        if vowels[char] {\n            str1_slice[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n    // return the reversed string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc9rlo7w3_test.go:42:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the non-vowels\n    non_vowels_slice := []string{}\n    // Create a slice of the reversed vowels\n    reversed_vowels_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1 := \"\"\n\n    // Iterate through the string\n    for _, char := range str1 {\n        // Append the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n        // If the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // Append the character to the vowels slice\n            vowels_slice = append(vowels_slice, string(char))\n        } else {\n            // Append the character to the non-vowels slice\n            non_vowels_slice = append(non_vowels_slice, string(char))\n        }\n    }\n\n    // Iterate through the vowels slice\n    for i := len(vowels_slice) - 1; i >= 0; i-- {\n        // Append the character to the reversed vowels slice\n        reversed_vowels_slice = append(reversed_vowels_slice, vowels_slice[i])\n    }\n\n    // Iterate through the string slice\n    for _, char := range str1_slice {\n        // If the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // Append the character to the reversed string slice\n            reversed_str1_slice = append(reversed_str1_slice, reversed_vowels_slice[0])\n            // Remove the character from the reversed vowels\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvigx9vsg_test.go:52:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_positions []int\n    var vowel_letters []string\n    var vowel_letters_reversed []string\n    var str1_runes []rune\n    var str2_runes []rune\n\n    for i, c := range str1 {\n        if contains(vowels, string(c)) {\n            vowel_positions = append(vowel_positions, i)\n            vowel_letters = append(vowel_letters, string(c))\n        }\n    }\n\n    for i := len(vowel_letters) - 1; i >= 0; i-- {\n        vowel_letters_reversed = append(vowel_letters_reversed, vowel_letters[i])\n    }\n\n    str1_runes = []rune(str1)\n    for i, c := range str1_runes {\n        if contains(vowels, string(c)) {\n            str1_runes[i] = rune(vowel_letters_reversed[0][0])\n            vowel_letters_reversed = vowel_letters_reversed[1:]\n        }\n    }\n\n    str2_runes = str1_runes\n    str2 = string(str2_runes)\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzyo1iv_o_test.go:19:12: undefined: contains\n/tmp/tmpzyo1iv_o_test.go:31:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if string(str1[i]) == vowels[j] {\n                str2 = str2 + string(str1[i])\n            }\n        }\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 = str3 + string(str2[i])\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpivhgt_9f_test.go:41: expected 'Python', got 'o'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpivhgt_9f_test.go:41: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpivhgt_9f_test.go:41: expected 'ab', got 'a'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_reversed string\n    var str1_vowels_reversed_index int\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_reversed += str1_vowels_reversed[str1_vowels_reversed_index]\n                str1_vowels_reversed_index++\n            } else {\n                str1_reversed += string(char)\n            }\n        }\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpohleveao_test.go:57: expected 'Python', got 'PPPPPyyyyyttttthhhhhooooonnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpohleveao_test.go:57: expected 'ASU', got 'UUUUUSSSSSAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpohleveao_test.go:57: expected 'ab', got 'aaaaabbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final_final_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n    indexes_slice_reverse_final_final_final_final_final_final_final_final_final_final := []int{}\n    // Create a slice of the indexes of the vowels\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc6w8llk3_test.go:42:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str1_runes := []rune(str1)\n    var str1_vowels []rune\n    var str1_non_vowels []rune\n    for _, char := range str1_runes {\n        if contains(vowels, char) {\n            str1_vowels = append(str1_vowels, char)\n        } else {\n            str1_non_vowels = append(str1_non_vowels, char)\n        }\n    }\n    for i, char := range str1_non_vowels {\n        str1_runes[i] = char\n    }\n    for i, char := range str1_vowels {\n        str1_runes[len(str1_non_vowels) + i] = char\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeijzyn27_test.go:15:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69 = \"\"\n    var str70 = \"\"\n    var str71 =\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphm0snka9_test.go:81:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels []string\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var e int\n    var i int\n    var o int\n    var u int\n    var y int\n    var A int\n    var E int\n    var I int\n    var O int\n    var U int\n    var Y int\n    var vowels []string\n    var vowels_reversed []string\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpd5sqlwl5_test.go:100:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    str1_runes := []rune(str1)\n    str1_vowels := []string{}\n    for _, str1_rune := range str1_runes {\n        for _, vowel := range vowels {\n            if string(str1_rune) == vowel {\n                str1_vowels = append(str1_vowels, string(str1_rune))\n            }\n        }\n    }\n    str1_vowels_reversed := []string{}\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n    str1_vowels_reversed_index := 0\n    for i, str1_rune := range str1_runes {\n        for _, vowel := range vowels {\n            if string(str1_rune) == vowel {\n                str1_runes[i] = []rune(str1_vowels_reversed[str1_vowels_reversed_index])[0]\n                str1_vowels_reversed_index++\n            }\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var str83 string\n    var str84 string\n    var str85 string\n    var str86 string\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfj62w66__test.go:96:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var vowels_list []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_list = append(vowels_list, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowels_list[len(vowels_list)-1]\n            vowels_list = vowels_list[:len(vowels_list)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpdrd95s39_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_pos []int\n    var vowel_chars []string\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_pos = append(vowel_pos, i)\n                vowel_chars = append(vowel_chars, string(char))\n            }\n        }\n    }\n    for i, char := range str1 {\n        if len(vowel_pos) > 0 && i == vowel_pos[0] {\n            str2 += vowel_chars[len(vowel_chars)-1]\n            vowel_pos = vowel_pos[1:]\n            vowel_chars = vowel_chars[:len(vowel_chars)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []rune(str1)\n    i := 0\n    j := len(str2) - 1\n    for i < j {\n        if str2[i] == 'a' || str2[i] == 'e' || str2[i] == 'i' || str2[i] == 'o' || str2[i] == 'u' {\n            for j > i {\n                if str2[j] == 'a' || str2[j] == 'e' || str2[j] == 'i' || str2[j] == 'o' || str2[j] == 'u' {\n                    str2[i], str2[j] = str2[j], str2[i]\n                    j--\n                    break\n                }\n                j--\n            }\n        }\n        i++\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp054y5_ox_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str2 string\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if vowels[string(str1[i])] {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp94shiyxl_test.go:51: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    var str1_vowels_index = []int{}\n    var str1_vowels_index_reverse = []int{}\n    var str1_vowels_reverse = []rune{}\n    var str1_vowels_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxqg63mnd_test.go:30:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str1_runes := []rune(str1)\n    str1_runes_len := len(str1_runes)\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowels_len := len(vowels)\n    vowels_map := make(map[rune]bool)\n    for i := 0; i < vowels_len; i++ {\n        vowels_map[vowels[i]] = true\n    }\n    i := 0\n    j := str1_runes_len - 1\n    for i < j {\n        for i < j && !vowels_map[str1_runes[i]] {\n            i++\n        }\n        for i < j && !vowels_map[str1_runes[j]] {\n            j--\n        }\n        if i < j {\n            str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n            i++\n            j--\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_stack []string\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsjenzlfp_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    // Create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    // Create a slice of the vowels\n    str1_vowels := []string{}\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str1_vowels = append(str1_vowels, string(char))\n        }\n    }\n\n    // Reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n\n    // Replace the vowels in the original slice with the reversed vowels\n    for i, char := range str1_slice {\n        if vowels[char] {\n            str1_slice[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n\n    // Return the joined slice\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprb293zt7_test.go:47:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 []string\n    var str3 []string\n    var str4 []string\n    var str5 []string\n    var str6 []string\n    var str7 []string\n    var str8 []string\n    var str9 []string\n    var str10 []string\n    var str11 []string\n    var str12 []string\n    var str13 []string\n    var str14 []string\n    var str15 []string\n    var str16 []string\n    var str17 []string\n    var str18 []string\n    var str19 []string\n    var str20 []string\n    var str21 []string\n    var str22 []string\n    var str23 []string\n    var str24 []string\n    var str25 []string\n    var str26 []string\n    var str27 []string\n    var str28 []string\n    var str29 []string\n    var str30 []string\n    var str31 []string\n    var str32 []string\n    var str33 []string\n    var str34 []string\n    var str35 []string\n    var str36 []string\n    var str37 []string\n    var str38 []string\n    var str39 []string\n    var str40 []string\n    var str41 []string\n    var str42 []string\n    var str43 []string\n    var str44 []string\n    var str45 []string\n    var str46 []string\n    var str47 []string\n    var str48 []string\n    var str49 []string\n    var str50 []string\n    var str51 []string\n    var str52 []string\n    var str53 []string\n    var str54 []string\n    var str55 []string\n    var str56 []string\n    var str57 []string\n    var str58 []string\n    var str59 []string\n    var str60 []string\n    var str61 []string\n    var str62 []string\n    var str63 []string\n    var str64 []string\n    var str65 []string\n    var str66 []string\n    var str67 []string\n    var str68 []string\n    var str69\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbowx6pq8_test.go:78:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_positions []int\n    var vowel_letters []string\n\n    for i := 0; i < len(str1); i++ {\n        for _, v := range vowels {\n            if string(str1[i]) == v {\n                vowel_positions = append(vowel_positions, i)\n                vowel_letters = append(vowel_letters, string(str1[i]))\n            }\n        }\n    }\n\n    for i := 0; i < len(str1); i++ {\n        if len(vowel_positions) > 0 && i == vowel_positions[0] {\n            str2 += vowel_letters[len(vowel_letters) - 1]\n            vowel_positions = vowel_positions[1:]\n            vowel_letters = vowel_letters[:len(vowel_letters) - 1]\n        } else {\n            str2 += string(str1[i])\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_array = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    // Convert string to array\n    for _, char := range str1 {\n        str1_array = append(str1_array, string(char))\n    }\n\n    // Get all vowels\n    for _, char := range str1_array {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    // Reverse vowels\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    // Replace vowels in original string with reversed vowels\n    for i, char := range str1_array {\n        for j, vowel := range str1_vowels {\n            if char == vowel {\n                str1_array[i] = str1_vowels_reversed[j]\n            }\n        }\n    }\n\n    // Convert array to string\n    for _, char := range str1_array {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpwzpzzpsh_test.go:67: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // Create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n    // Reverse the slice of vowels\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Replace the vowels in the string slice with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoel0yz2y_test.go:42:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_vowels_reversed_index int\n    var str1_vowels_reversed_index_max int\n    var str1_vowels_reversed_index_min int\n    var str1_vowels_reversed_index_delta int\n    var str1_vowels_reversed_index_delta_max int\n    var str1_vowels_reversed_index_delta_min int\n    var str1_vowels_reversed_index_delta_delta int\n    var str1_vowels_reversed_index_delta_delta_max int\n    var str1_vowels_reversed_index_delta_delta_min int\n    var str1_vowels_reversed_index_delta_delta_delta int\n    var str1_vowels_reversed_index_delta_delta_delta_max int\n    var str1_vowels_reversed_index_delta_delta_delta_min int\n    var str1_vowels_reversed_index_delta_delta_delta_delta int\n    var str1_vowels_reversed_index_delta_delta_delta_delta_max int\n    var str1_vowels_reversed_index_delta_delta_delta_delta_min int\n    var str1_vowels_reversed_index_delta_delta_delta_delta_delta int\n    var str1_vowels_reversed_index_delta_delta_delta_delta_delta_max int\n    var str1_vowels_reversed_index_delta_delta_delta_delta_delta_min int\n    var str1_vowels_reversed_index_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0efc1z_w_test.go:31:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    str1_arr := []string{}\n    for _, char := range str1 {\n        str1_arr = append(str1_arr, string(char))\n    }\n    str1_len := len(str1_arr)\n    for i := 0; i < str1_len; i++ {\n        for j := i; j < str1_len; j++ {\n            if contains(vowels, str1_arr[j]) {\n                str1_arr[i], str1_arr[j] = str1_arr[j], str1_arr[i]\n                break\n            }\n        }\n    }\n    return strings.Join(str1_arr, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2l02e80a_test.go:18:16: undefined: contains\n/tmp/tmp2l02e80a_test.go:24:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpc6017cqk_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Convert string to rune slice\n    str1_runes := []rune(str1)\n    // Create a map of vowels\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}\n    // Create a slice of the indexes of the vowels\n    vowel_indexes := []int{}\n    for i, char := range str1_runes {\n        if _, ok := vowels[char]; ok {\n            vowel_indexes = append(vowel_indexes, i)\n        }\n    }\n    // Reverse the vowels\n    for i := 0; i < len(vowel_indexes)/2; i++ {\n        str1_runes[vowel_indexes[i]], str1_runes[vowel_indexes[len(vowel_indexes)-1-i]] = str1_runes[vowel_indexes[len(vowel_indexes)-1-i]], str1_runes[vowel_indexes[i]]\n    }\n    // Return the reversed string\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp1qwdvevn_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmphh09504v_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_indexes []int\n    var vowel_values []string\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_indexes = append(vowel_indexes, i)\n                vowel_values = append(vowel_values, string(char))\n            }\n        }\n    }\n    for i, char := range str1 {\n        if len(vowel_indexes) > 0 && i == vowel_indexes[len(vowel_indexes)-1] {\n            str2 += vowel_values[len(vowel_values)-1]\n            vowel_indexes = vowel_indexes[:len(vowel_indexes)-1]\n            vowel_values = vowel_values[:len(vowel_values)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpogoi2r4v_test.go:49: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Iterate over the string and add the vowels to the vowels slice\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate over the string and add the vowels to the vowels slice\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice = append(str1_slice, vowels_slice[0])\n            vowels_slice = vowels_slice[1:]\n        } else {\n            str1_slice = append(str1_slice, string(char))\n        }\n    }\n    // Return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsgylyp0u_test.go:36:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    str1_runes := []rune(str1)\n    str1_vowels := []string{}\n    for _, v := range str1_runes {\n        for _, vv := range vowels {\n            if string(v) == vv {\n                str1_vowels = append(str1_vowels, string(v))\n            }\n        }\n    }\n    str1_vowels_reversed := reverse(str1_vowels)\n    for i, v := range str1_runes {\n        for _, vv := range vowels {\n            if string(v) == vv {\n                str1_runes[i] = []rune(str1_vowels_reversed[0])[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            }\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg_zeau39_test.go:20:29: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    var str1_runes = []rune(str1)\n    var str2_runes = []rune(str2)\n    var str1_len = len(str1_runes)\n    var str2_len = len(str2_runes)\n    var str1_vowels = []rune{}\n    var str1_vowels_len = len(str1_vowels)\n    var str1_vowels_index = 0\n    var str1_vowels_index_max = str1_vowels_len - 1\n    var str1_vowels_index_min = 0\n    var str1_vowels_index_mid = str1_vowels_index_min + (str1_vowels_index_max - str1_vowels_index_min) / 2\n    var str1_vowels_index_mid_value string\n    var str1_vowels_index_mid_value_rune rune\n    var str1_vowels_index_mid_value_rune_string string\n    var str1_vowels_index_mid_value_rune_string_exists bool\n    var str1_vowels_index_mid_value_rune_string_exists_not bool\n    var str1_vowels_index_mid_value_rune_string_exists_not_bool bool\n    var str1_vowels_index_mid_value_rune_string_exists_not_bool_not bool\n    var str1_vowels_index_mid_value_rune_string_exists_not_bool_not_bool bool\n    var str1_vowels_index_mid_value_rune_string_exists_not_bool_not_bool_not bool\n    var str1_vowels_index_mid_value_rune_string_exists_not_bool_not_bool_not\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmac8wuui_test.go:31:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n\n    // Create a slice of runes\n    runes := []rune(str1)\n\n    // Create a slice of runes to hold the vowels\n    var vowels_runes []rune\n\n    // Iterate over the runes\n    for _, r := range runes {\n        // Check if the rune is a vowel\n        if _, ok := vowels[string(r)]; ok {\n            // Append the rune to the vowels slice\n            vowels_runes = append(vowels_runes, r)\n        }\n    }\n\n    // Reverse the slice of vowels\n    for i, j := 0, len(vowels_runes)-1; i < j; i, j = i+1, j-1 {\n        vowels_runes[i], vowels_runes[j] = vowels_runes[j], vowels_runes[i]\n    }\n\n    // Iterate over the runes\n    for i, r := range runes {\n        // Check if the rune is a vowel\n        if _, ok := vowels[string(r)]; ok {\n            // Replace the rune with the reversed vowel\n            runes[i] = vowels_runes[0]\n            // Remove the vowel from the slice\n            vowels_runes = vowels_runes[1:]\n        }\n    }\n\n    // Return the reversed string\n    return string(runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpq9yxrphe_test.go:63: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Convert string to slice of runes\n    str := []rune(str1)\n    // Create a map of vowels\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}\n    // Create a slice of runes to hold the vowels\n    var vowel_slice []rune\n    // Loop through the string\n    for _, char := range str {\n        // If the character is a vowel, add it to the vowel slice\n        if vowels[char] {\n            vowel_slice = append(vowel_slice, char)\n        }\n    }\n    // Reverse the slice of vowels\n    for i, j := 0, len(vowel_slice)-1; i < j; i, j = i+1, j-1 {\n        vowel_slice[i], vowel_slice[j] = vowel_slice[j], vowel_slice[i]\n    }\n    // Loop through the string again\n    for i, char := range str {\n        // If the character is a vowel, replace it with the reversed vowel\n        if vowels[char] {\n            str[i] = vowel_slice[0]\n            // Remove the vowel from the slice\n            vowel_slice = vowel_slice[1:]\n        }\n    }\n    // Return the string\n    return string(str)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpx4ky7rzf_test.go:55: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    for _, c := range str1 {\n        if _, ok := vowels[string(c)]; ok {\n            str2 = string(c) + str2\n        }\n    }\n\n    var str3 string\n    var j int = 0\n    for _, c := range str1 {\n        if _, ok := vowels[string(c)]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(c)\n        }\n    }\n\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpif1nv2vh_test.go:54: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo3csepx8_test.go:14:12: undefined: contains\n/tmp/tmpo3csepx8_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_positions []int\n    var vowel_positions_reversed []int\n    var str1_runes = []rune(str1)\n    var str2_runes = []rune(str2)\n    var str1_len = len(str1_runes)\n    var str2_len = len(str2_runes)\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj17n1c_b_test.go:87:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_indexes []int\n    var vowel_chars []string\n\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_indexes = append(vowel_indexes, i)\n                vowel_chars = append(vowel_chars, string(char))\n            }\n        }\n    }\n\n    for i, char := range str1 {\n        if contains(vowel_indexes, i) {\n            str2 += vowel_chars[len(vowel_chars) - 1]\n            vowel_chars = vowel_chars[:len(vowel_chars) - 1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp75nmswjc_test.go:25:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_positions []int\n    var vowel_values []string\n    var vowel_index int\n\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_positions = append(vowel_positions, i)\n                vowel_values = append(vowel_values, string(char))\n            }\n        }\n    }\n\n    for i, char := range str1 {\n        for _, vowel_position := range vowel_positions {\n            if i == vowel_position {\n                str2 += vowel_values[vowel_index]\n                vowel_index++\n            } else {\n                str2 += string(char)\n            }\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpc3vwos3j_test.go:54: expected 'ASU', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_indices []int\n    var vowel_chars []string\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_indices = append(vowel_indices, i)\n                vowel_chars = append(vowel_chars, string(char))\n            }\n        }\n    }\n    for i, char := range str1 {\n        if len(vowel_indices) > 0 && i == vowel_indices[0] {\n            str2 += vowel_chars[len(vowel_chars)-1]\n            vowel_indices = vowel_indices[1:]\n            vowel_chars = vowel_chars[:len(vowel_chars)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_index []int\n    var str1_vowels_index_reverse []int\n    var str1_vowels_reverse []string\n    var str1_vowels_reverse_index []int\n    var str1_vowels_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_final []int\n    var str1_vowels_reverse_index_reverse_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final_final_final_final_final_final []int\n    var str1_vowels_reverse_index_reverse_final_final_final_final_final_final_final_final_final_final_final_final_final []int\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv4lspiwp_test.go:31:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    // Create a slice of the string\n    str2 := []string{}\n    // Create a slice of the vowels\n    vowels_str := []string{}\n    // Create a slice of the indices of the vowels\n    vowels_idx := []int{}\n    // Iterate over the string\n    for i, s := range str1 {\n        // If the character is a vowel\n        if _, ok := vowels[string(s)]; ok {\n            // Append the character to the slice of vowels\n            vowels_str = append(vowels_str, string(s))\n            // Append the index to the slice of indices\n            vowels_idx = append(vowels_idx, i)\n        }\n        // Append the character to the slice of the string\n        str2 = append(str2, string(s))\n    }\n    // Reverse the slice of vowels\n    for i, j := 0, len(vowels_str)-1; i < j; i, j = i+1, j-1 {\n        vowels_str[i], vowels_str[j] = vowels_str[j], vowels_str[i]\n    }\n    // Iterate over the slice of indices\n    for i, idx := range vowels_idx {\n        // Replace the character at the index with the corresponding vowel\n        str2[idx] = vowels_str[i]\n    }\n    // Return the string\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1pj2_g___test.go:40:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, v := range str1 {\n        str2 = append(str2, string(v))\n    }\n    for _, v := range str2 {\n        if vowels[v] {\n            str3 = append(str3, v)\n        }\n    }\n    for i, v := range str2 {\n        if vowels[v] {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgin_0yfp_test.go:33:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69 = \"\"\n    var str70 = \"\"\n    var str71 =\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphm0snka9_test.go:81:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var str3 string\n    var str4 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = str2 + string(c)\n        } else {\n            str3 = str3 + string(c)\n        }\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str4 = str4 + string(str2[i])\n    }\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + string(str4[0])\n            str4 = str4[1:]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4hyaje3o_test.go:47: expected 'Python', got 'Pythno'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4hyaje3o_test.go:47: expected 'ASU', got 'USA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4hyaje3o_test.go:47: expected 'ab', got 'ba'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []string{}\n    var str1_non_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1_runes {\n        var char_str = string(char)\n        if is_vowel(char_str, vowels) {\n            str1_vowels = append(str1_vowels, char_str)\n        } else {\n            str1_non_vowels = append(str1_non_vowels, char_str)\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i := 0; i < len(str1_runes); i++ {\n        if is_vowel(str1_non_vowels[i], vowels) {\n            str1_reversed += str1_vowels_reversed[0]\n            str1_vowels_reversed = str1_vowels_reversed[1:]\n        } else {\n            str1_reversed += str1_non_vowels[i]\n        }\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp08zsnvzl_test.go:19:12: undefined: is_vowel\n/tmp/tmp08zsnvzl_test.go:31:12: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str2 += str1_vowels[len(str1_vowels)-1]\n                str1_vowels = str1_vowels[:len(str1_vowels)-1]\n            } else {\n                str2 += string(char)\n            }\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp_2ujdgze_test.go:48: expected 'Python', got 'PPPPPyyyyyttttthhhhhooooonnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp_2ujdgze_test.go:48: expected 'ASU', got 'UUUUUSSSSSAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp_2ujdgze_test.go:48: expected 'ab', got 'aaaaabbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    // Convert string to a slice of runes\n    str := []rune(str1)\n\n    // Create a slice to store the vowels\n    var v []rune\n\n    // Loop through the string\n    for i := 0; i < len(str); i++ {\n        // Check if the current rune is a vowel\n        if _, ok := vowels[string(str[i])]; ok {\n            // If it is, add it to the slice of vowels\n            v = append(v, str[i])\n        }\n    }\n\n    // Reverse the slice of vowels\n    for i := 0; i < len(v)/2; i++ {\n        j := len(v) - i - 1\n        v[i], v[j] = v[j], v[i]\n    }\n\n    // Loop through the string again\n    for i := 0; i < len(str); i++ {\n        // Check if the current rune is a vowel\n        if _, ok := vowels[string(str[i])]; ok {\n            // If it is, replace it with the next vowel in the slice\n            str[i] = v[0]\n            v = v[1:]\n        }\n    }\n\n    // Return the string\n    return string(str)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpmjwgnutu_test.go:69: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpe1l2501d_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n\n    for _, v := range str1 {\n        if contains(vowels, string(v)) {\n            str2 = string(v) + str2\n        }\n    }\n\n    var str3 string\n    var j int = 0\n\n    for _, v := range str1 {\n        if contains(vowels, string(v)) {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(v)\n        }\n    }\n\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxsy31xc6_test.go:14:12: undefined: contains\n/tmp/tmpxsy31xc6_test.go:23:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    var vowel_stack []string\n\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpm8vc1ij6_test.go:47: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // create a slice of the string\n    str1_slice := []string{}\n    // create a slice of the vowels\n    vowels_slice := []string{}\n    // create a slice of the reversed vowels\n    reversed_vowels := []string{}\n    // create a slice of the reversed string\n    reversed_str1 := []string{}\n    // create a slice of the reversed string\n    reversed_str1_slice := []string{}\n    // create a slice of the reversed string\n    reversed_str1_slice_final := []string{}\n    // create a slice of the reversed string\n    reversed_str1_final := \"\"\n\n    // loop through the string\n    for _, char := range str1 {\n        // if the character is a vowel, add it to the slice of vowels\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // add the character to the slice of the string\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    // reverse the slice of vowels\n    for i := len(vowels_slice) - 1; i >= 0; i-- {\n        reversed_vowels = append(reversed_vowels, vowels_slice[i])\n    }\n\n    // loop through the slice of the string\n    for _, char := range str1_slice {\n        // if the character is a vowel, add the reversed vowel to the slice of the reversed string\n        if _, ok := vowels[char]; ok {\n            reversed_str1 = append(reversed_str1, reversed_vowels[0])\n            reversed_vowels = reversed_vowels[1:]\n        } else {\n            // if the character is not a vowel, add the character to the slice of the reversed string\n            reversed_str1 = append(reversed_str1, char)\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzst07s1b_test.go:51:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels []rune\n    var str1_consonants []rune\n    var str1_vowels_reversed []rune\n    var str1_reversed []rune\n\n    for _, char := range str1_runes {\n        if contains(vowels, string(char)) {\n            str1_vowels = append(str1_vowels, char)\n        } else {\n            str1_consonants = append(str1_consonants, char)\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i := 0; i < len(str1_runes); i++ {\n        if contains(vowels, string(str1_runes[i])) {\n            str1_reversed = append(str1_reversed, str1_vowels_reversed[0])\n            str1_vowels_reversed = str1_vowels_reversed[1:]\n        } else {\n            str1_reversed = append(str1_reversed, str1_consonants[0])\n            str1_consonants = str1_consonants[1:]\n        }\n    }\n\n    return string(str1_reversed)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj9mhny4r_test.go:18:12: undefined: contains\n/tmp/tmpj9mhny4r_test.go:30:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var i = 0\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str3 += string(str2[i])\n            i++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpdx6auhm6_test.go:51: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var str1_vowels []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += str1_vowels[len(str1_vowels)-1]\n            str1_vowels = str1_vowels[:len(str1_vowels)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8ffz4fxu_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Convert string to rune array\n    str2 := []rune(str1)\n    // Create a map of vowels\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}\n    // Create a slice of vowels\n    var vowels_slice []rune\n    // Iterate through the string and add vowels to the slice\n    for _, char := range str2 {\n        if vowels[char] {\n            vowels_slice = append(vowels_slice, char)\n        }\n    }\n    // Reverse the slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate through the string and replace vowels with the reversed slice\n    for i, char := range str2 {\n        if vowels[char] {\n            str2[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the reversed string\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpuiu4jtu1_test.go:52: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 []string\n    var str3 []string\n    var str4 []string\n    var str5 []string\n    var str6 []string\n    var str7 []string\n    var str8 []string\n    var str9 []string\n    var str10 []string\n    var str11 []string\n    var str12 []string\n    var str13 []string\n    var str14 []string\n    var str15 []string\n    var str16 []string\n    var str17 []string\n    var str18 []string\n    var str19 []string\n    var str20 []string\n    var str21 []string\n    var str22 []string\n    var str23 []string\n    var str24 []string\n    var str25 []string\n    var str26 []string\n    var str27 []string\n    var str28 []string\n    var str29 []string\n    var str30 []string\n    var str31 []string\n    var str32 []string\n    var str33 []string\n    var str34 []string\n    var str35 []string\n    var str36 []string\n    var str37 []string\n    var str38 []string\n    var str39 []string\n    var str40 []string\n    var str41 []string\n    var str42 []string\n    var str43 []string\n    var str44 []string\n    var str45 []string\n    var str46 []string\n    var str47 []string\n    var str48 []string\n    var str49 []string\n    var str50 []string\n    var str51 []string\n    var str52 []string\n    var str53 []string\n    var str54 []string\n    var str55 []string\n    var str56 []string\n    var str57 []string\n    var str58 []string\n    var str59 []string\n    var str60 []string\n    var str61 []string\n    var str62 []string\n    var str63 []string\n    var str64 []string\n    var str65 []string\n    var str66 []string\n    var str67 []string\n    var str68 []string\n    var str69\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbowx6pq8_test.go:78:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_slice := []string{}\n    str1_vowels := []string{}\n    str1_vowels_reversed := []string{}\n    str1_reversed := \"\"\n\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    for _, char := range str1_slice {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_slice {\n        for j, vowel := range str1_vowels {\n            if char == vowel {\n                str1_slice[i] = str1_vowels_reversed[j]\n            }\n        }\n    }\n\n    for _, char := range str1_slice {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpvd50dmv4_test.go:62: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        str2 = str2 + string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str3 = string(char) + str3\n            }\n        }\n    }\n    for _, char := range str2 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str2 = strings.Replace(str2, string(char), str3[:1], 1)\n                str3 = str3[1:]\n            }\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn2ot07sl_test.go:24:24: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str1_vowels []string\n    var str1_consonants []string\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str1_vowels = append(str1_vowels, string(char))\n        } else {\n            str1_consonants = append(str1_consonants, string(char))\n        }\n    }\n    for i, char := range str1 {\n        if vowels[string(char)] {\n            str2 += str1_vowels[len(str1_vowels)-1-i]\n        } else {\n            str2 += str1_consonants[i-len(str1_vowels)]\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x5364c0, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5364c0, 0xc00015a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x545abf, 0x6, 0x4cd164, 0x5fa520)\n\t/tmp/tmpzvjaf02v_test.go:31 +0x665\ncommand-line-arguments_test.TestReverse_Vowels(0xc000102600)\n\t/tmp/tmpzvjaf02v_test.go:44 +0x53\ntesting.tRunner(0xc000102600, 0x54f4d8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the reversed vowels\n    reversed_vowels_slice := []string{}\n    // Create a slice of the reversed string\n    reversed_str1_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_vowels_slice := []string{}\n    // Create a slice of the reversed string with the reversed vowels\n    reversed_str1_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8mxcovac_test.go:44:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_nonvowels []string\n    var str1_vowels_reversed []string\n\n    for _, char := range str1 {\n        if string(char) == \"a\" || string(char) == \"e\" || string(char) == \"i\" || string(char) == \"o\" || string(char) == \"u\" {\n            str1_vowels = append(str1_vowels, string(char))\n        } else {\n            str1_nonvowels = append(str1_nonvowels, string(char))\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1 {\n        if string(char) == \"a\" || string(char) == \"e\" || string(char) == \"i\" || string(char) == \"o\" || string(char) == \"u\" {\n            str2 += str1_vowels_reversed[i]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptapwpemk_test.go:11:9: vowels declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_arr = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_arr = append(str1_arr, string(char))\n    }\n\n    for _, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_arr[i] = str1_vowels_reversed[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            }\n        }\n    }\n\n    for _, char := range str1_arr {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []rune(str1)\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var vowel_pos []int\n    for i, char := range str2 {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowel_pos = append(vowel_pos, i)\n            }\n        }\n    }\n    for i, j := 0, len(vowel_pos)-1; i < j; i, j = i+1, j-1 {\n        str2[vowel_pos[i]], str2[vowel_pos[j]] = str2[vowel_pos[j]], str2[vowel_pos[i]]\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq_4r7r1f_test.go:14:12: undefined: contains\n/tmp/tmpq_4r7r1f_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    // Convert string to rune slice\n    str1_runes := []rune(str1)\n\n    // Create a slice to hold the vowels\n    var vowels_runes []rune\n\n    // Iterate over the string and add the vowels to the slice\n    for _, char := range str1_runes {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_runes = append(vowels_runes, char)\n        }\n    }\n\n    // Reverse the slice\n    for i := len(vowels_runes)/2-1; i >= 0; i-- {\n        opp := len(vowels_runes)-1-i\n        vowels_runes[i], vowels_runes[opp] = vowels_runes[opp], vowels_runes[i]\n    }\n\n    // Iterate over the string and replace the vowels\n    for i, char := range str1_runes {\n        if _, ok := vowels[string(char)]; ok {\n            str1_runes[i] = vowels_runes[0]\n            vowels_runes = vowels_runes[1:]\n        }\n    }\n\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp84gp12lu_test.go:64: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += string(char)\n        }\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 += string(str2[i])\n    }\n    var str4 string\n    var j int = 0\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str4 += string(str3[j])\n            j++\n        } else {\n            str4 += string(char)\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpll13_i9a_test.go:49: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str_runes := []rune(str1)\n    var vowel_runes []rune\n    for i := 0; i < len(str_runes); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if str_runes[i] == vowels[j] {\n                vowel_runes = append(vowel_runes, str_runes[i])\n            }\n        }\n    }\n    for i := 0; i < len(str_runes); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if str_runes[i] == vowels[j] {\n                str_runes[i] = vowel_runes[len(vowel_runes) - 1]\n                vowel_runes = vowel_runes[:len(vowel_runes) - 1]\n            }\n        }\n    }\n    return string(str_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x54535a, 0x3, 0xc00019e080, 0x6)\n\t/tmp/tmpbrgks9y0_test.go:23 +0x253\ncommand-line-arguments_test.TestReverse_Vowels(0xc000186300)\n\t/tmp/tmpbrgks9y0_test.go:39 +0x8b\ntesting.tRunner(0xc000186300, 0x54f1f0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // initialize a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // initialize a slice of the string\n    str1_slice := []string{}\n    // initialize a slice of the vowels in the string\n    str1_vowels := []string{}\n    // initialize a slice of the reversed vowels in the string\n    str1_vowels_reversed := []string{}\n    // initialize a slice of the reversed string\n    str1_reversed := []string{}\n    // initialize a string to hold the reversed string\n    str1_reversed_string := \"\"\n\n    // iterate over the string and add each character to the slice\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    // iterate over the slice and add each vowel to the vowel slice\n    for _, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n\n    // reverse the vowels slice\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    // iterate over the slice of the string and add each character to the reversed string slice\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_reversed = append(str1_reversed, str1_vowels_reversed[0])\n            str1_vowels_reversed = str1_vowels_reversed[1:]\n        } else {\n            str1_reversed = append(str1_reversed, char)\n        }\n    }\n\n    // iterate over the reversed string slice and add each character to the reversed string\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpapbc3975_test.go:52:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmph3pp0zt0_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // create a slice of the vowels\n    str1_vowels := []string{}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, string(char))\n        }\n    }\n    // reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n    // replace the vowels in the string slice with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n    // return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihkrylxs_test.go:36:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_count int = 0\n    var vowel_pos = make([]int, len(str1))\n    var vowel_map = make(map[int]string)\n\n    for i := 0; i < len(str1); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if string(str1[i]) == vowels[j] {\n                vowel_pos[vowel_count] = i\n                vowel_map[i] = string(str1[i])\n                vowel_count++\n            }\n        }\n    }\n\n    for i := 0; i < len(str1); i++ {\n        if vowel_map[i] != \"\" {\n            str2 += vowel_map[vowel_pos[vowel_count-1]]\n            vowel_count--\n        } else {\n            str2 += string(str1[i])\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpafvx9vcy_test.go:53: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp53rfp1l9_test.go:14:12: undefined: contains\n/tmp/tmp53rfp1l9_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, i := range str1 {\n        if i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' {\n            str2 = string(i) + str2\n        } else {\n            str2 = str2 + string(i)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpwxac2oil_test.go:36: expected 'Python', got 'oPythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpwxac2oil_test.go:36: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_indexes []int\n    var vowel_chars []string\n\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_indexes = append(vowel_indexes, i)\n                vowel_chars = append(vowel_chars, string(char))\n            }\n        }\n    }\n\n    for i, char := range str1 {\n        if len(vowel_indexes) > 0 && i == vowel_indexes[len(vowel_indexes) - 1] {\n            str2 += vowel_chars[len(vowel_chars) - 1]\n            vowel_indexes = vowel_indexes[:len(vowel_indexes) - 1]\n            vowel_chars = vowel_chars[:len(vowel_chars) - 1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmponbk_900_test.go:52: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyu780zao_test.go:90:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_vowels_reversed_string string\n    var str1_vowels_reversed_index int\n\n    for i := 0; i < len(str1); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if string(str1[i]) == vowels[j] {\n                str1_vowels = append(str1_vowels, string(str1[i]))\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i := 0; i < len(str1); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if string(str1[i]) == vowels[j] {\n                str1_vowels_reversed_string += str1_vowels_reversed[str1_vowels_reversed_index]\n                str1_vowels_reversed_index++\n            } else {\n                str1_vowels_reversed_string += string(str1[i])\n            }\n        }\n    }\n\n    return str1_vowels_reversed_string\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpo7vz4dwh_test.go:57: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpo7vz4dwh_test.go:57: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpo7vz4dwh_test.go:57: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels []string\n    var index int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    for i = 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            vowels = append(vowels, string(str1[i]))\n        }\n    }\n\n    for j = 0; j < len(str1); j++ {\n        if str1[j] == 'a' || str1[j] == 'e' || str1[j] == 'i' || str1[j] == 'o' || str1[j] == 'u' {\n            str2 += vowels[len(vowels) - index - 1]\n            index++\n        } else {\n            str2 += string(str1[j])\n        }\n    }\n\n    for k = 0; k < len(str1); k++ {\n        if str1[k] == 'A' || str1[k] == 'E' || str1[k] == 'I' || str1[k] == 'O' || str1[k] == 'U' {\n            vowels = append(vowels, string(str1[k]))\n        }\n    }\n\n    for l = 0; l < len(str1); l++ {\n        if str1[l] == 'A' || str1[l] == 'E' || str1[l] == 'I' || str1[l] == 'O' || str1[l] == 'U' {\n            str2 += vowels[len(vowels) - index - 1]\n            index++\n        } else {\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp0_m2iis_test.go:58:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpc6017cqk_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := \"aeiou\"\n    str1_runes := []rune(str1)\n    str1_vowels := []rune{}\n    str1_non_vowels := []rune{}\n\n    for _, r := range str1_runes {\n        if strings.ContainsRune(vowels, r) {\n            str1_vowels = append(str1_vowels, r)\n        } else {\n            str1_non_vowels = append(str1_non_vowels, r)\n        }\n    }\n\n    str1_vowels_reversed := []rune{}\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    str1_reversed := []rune{}\n    for i, r := range str1_non_vowels {\n        str1_reversed = append(str1_reversed, r)\n        if i < len(str1_vowels_reversed) {\n            str1_reversed = append(str1_reversed, str1_vowels_reversed[i])\n        }\n    }\n\n    return string(str1_reversed)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkodb14fd_test.go:16:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n\n    // create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    // create a slice of the vowels\n    vowels_slice := []string{}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n\n    // reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n\n    // replace the vowels in the string slice with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n\n    // return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp88bnafxc_test.go:41:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Iterate over the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // Add the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate over the string slice\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the corresponding reversed vowel\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string slice as a string\n    return fmt.Sprintf(\"%s\", str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp2ti0zx1y_test.go:56: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp2ti0zx1y_test.go:56: expected 'ASU', got '[U S A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp2ti0zx1y_test.go:56: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq_4r7r1f_test.go:14:12: undefined: contains\n/tmp/tmpq_4r7r1f_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str2 = string(char) + str2\n            }\n        }\n    }\n\n    var j = 0\n    for i := 0; i < len(str1); i++ {\n        for _, vowel := range vowels {\n            if string(str1[i]) == vowel {\n                str3 += string(str2[j])\n                j++\n            } else {\n                str3 += string(str1[i])\n            }\n        }\n    }\n\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpaimjq75b_test.go:52: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpaimjq75b_test.go:52: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpaimjq75b_test.go:52: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // Convert string to slice of runes\n    str1_runes := []rune(str1)\n    // Create a slice to hold the vowels\n    var str1_vowels []rune\n    // Loop through the slice of runes\n    for _, char := range str1_runes {\n        // Convert the rune to a string\n        char_str := string(char)\n        // Check if the character is a vowel\n        if vowels[char_str] {\n            // If it is a vowel, add it to the slice of vowels\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n    // Reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n    // Loop through the slice of runes\n    for i, char := range str1_runes {\n        // Convert the rune to a string\n        char_str := string(char)\n        // Check if the character is a vowel\n        if vowels[char_str] {\n            // If it is a vowel, replace the character with the first character in the slice of vowels\n            str1_runes[i] = str1_vowels[0]\n            // Remove the first character from the slice of vowels\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n    // Return the string\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp2mtt9pkd_test.go:67: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, v := range str1 {\n        if contains(vowels, string(v)) {\n            str2 += string(v)\n        }\n    }\n    for _, v := range str1 {\n        if contains(vowels, string(v)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(v)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq4nbaxmn_test.go:14:12: undefined: contains\n/tmp/tmpq4nbaxmn_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_vowels_reversed_str string\n    var str1_reversed string\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    str1_vowels_reversed_str = strings.Join(str1_vowels_reversed, \"\")\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_reversed += string(str1_vowels_reversed_str[0])\n                str1_vowels_reversed_str = str1_vowels_reversed_str[1:]\n            } else {\n                str1_reversed += string(char)\n            }\n        }\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8zcrwr5m_test.go:28:32: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 []string\n    var str3 []string\n    var str4 []string\n    var str5 []string\n    var str6 []string\n    var str7 []string\n    var str8 []string\n    var str9 []string\n    var str10 []string\n    var str11 []string\n    var str12 []string\n    var str13 []string\n    var str14 []string\n    var str15 []string\n    var str16 []string\n    var str17 []string\n    var str18 []string\n    var str19 []string\n    var str20 []string\n    var str21 []string\n    var str22 []string\n    var str23 []string\n    var str24 []string\n    var str25 []string\n    var str26 []string\n    var str27 []string\n    var str28 []string\n    var str29 []string\n    var str30 []string\n    var str31 []string\n    var str32 []string\n    var str33 []string\n    var str34 []string\n    var str35 []string\n    var str36 []string\n    var str37 []string\n    var str38 []string\n    var str39 []string\n    var str40 []string\n    var str41 []string\n    var str42 []string\n    var str43 []string\n    var str44 []string\n    var str45 []string\n    var str46 []string\n    var str47 []string\n    var str48 []string\n    var str49 []string\n    var str50 []string\n    var str51 []string\n    var str52 []string\n    var str53 []string\n    var str54 []string\n    var str55 []string\n    var str56 []string\n    var str57 []string\n    var str58 []string\n    var str59 []string\n    var str60 []string\n    var str61 []string\n    var str62 []string\n    var str63 []string\n    var str64 []string\n    var str65 []string\n    var str66 []string\n    var str67 []string\n    var str68 []string\n    var str69\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbowx6pq8_test.go:78:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // create a slice of the string\n    str1_slice := []string{}\n    // create a slice of the vowels\n    vowels_slice := []string{}\n    // iterate through the string\n    for _, char := range str1 {\n        // if the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // append it to the vowels slice\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // append the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // iterate through the string slice\n    for i, char := range str1_slice {\n        // if the character is a vowel\n        if _, ok := vowels[char]; ok {\n            // replace the character with the last vowel in the vowels slice\n            str1_slice[i] = vowels_slice[len(vowels_slice)-1]\n            // remove the last vowel from the vowels slice\n            vowels_slice = vowels_slice[:len(vowels_slice)-1]\n        }\n    }\n    // return the string slice as a string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp05g_slxq_test.go:37:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    var str2 []rune\n    var str3 []rune\n    for _, char := range str1 {\n        if is_vowel(char, vowels) {\n            str2 = append(str2, char)\n        }\n    }\n    for _, char := range str1 {\n        if is_vowel(char, vowels) {\n            str3 = append(str3, str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 = append(str3, char)\n        }\n    }\n    return string(str3)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk26j3pkk_test.go:14:12: undefined: is_vowel\n/tmp/tmpk26j3pkk_test.go:19:12: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []byte(str1)\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    i := 0\n    j := len(str2) - 1\n    for i < j {\n        for i < j && !contains(vowels, str2[i]) {\n            i++\n        }\n        for i < j && !contains(vowels, str2[j]) {\n            j--\n        }\n        if i < j {\n            str2[i], str2[j] = str2[j], str2[i]\n            i++\n            j--\n        }\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpish24_16_test.go:15:23: undefined: contains\n/tmp/tmpish24_16_test.go:18:23: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]int{\n        \"a\": 1,\n        \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    }\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, c := range str1 {\n        str2 = append(str2, string(c))\n    }\n    for _, c := range str2 {\n        if _, ok := vowels[c]; ok {\n            str3 = append(str3, c)\n        }\n    }\n    for i, c := range str2 {\n        if _, ok := vowels[c]; ok {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq6fnr52q_test.go:33:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp_2wvx87t_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Replace the vowels in the string slice with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string\n    return fmt.Sprintf(\"%s\", str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp1x8so0di_test.go:54: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp1x8so0di_test.go:54: expected 'ASU', got '[U S A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp1x8so0di_test.go:54: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_arr := []string{}\n    str1_vowels := []string{}\n    str1_vowels_reversed := []string{}\n    str1_final := \"\"\n\n    for _, char := range str1 {\n        str1_arr = append(str1_arr, string(char))\n    }\n\n    for _, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_arr {\n        for j, vowel := range str1_vowels {\n            if char == vowel {\n                str1_arr[i] = str1_vowels_reversed[j]\n            }\n        }\n    }\n\n    for _, char := range str1_arr {\n        str1_final += char\n    }\n\n    return str1_final\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4gndfjex_test.go:62: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\n        \"a\": 1,\n        \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    }\n    for i := len(str1) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp7d82kxu3_test.go:51: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := make(map[string]bool)\n    vowels[\"a\"] = true\n    vowels[\"e\"] = true\n    vowels[\"i\"] = true\n    vowels[\"o\"] = true\n    vowels[\"u\"] = true\n\n    // Create a slice of the string\n    str1_slice := []rune(str1)\n\n    // Create a slice of the vowels\n    var vowels_slice []rune\n    for _, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, char)\n        }\n    }\n\n    // Reverse the vowels\n    for i, _ := range vowels_slice {\n        vowels_slice[i], vowels_slice[len(vowels_slice)-1-i] = vowels_slice[len(vowels_slice)-1-i], vowels_slice[i]\n    }\n\n    // Replace the vowels in the string with the reversed vowels\n    var j int\n    for i, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice[i] = vowels_slice[j]\n            j++\n        }\n    }\n\n    return string(str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpmz39hm9t_test.go:61: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 []string\n    var str3 []string\n    var str4 []string\n    var str5 []string\n    var str6 []string\n    var str7 []string\n    var str8 []string\n    var str9 []string\n    var str10 []string\n    var str11 []string\n    var str12 []string\n    var str13 []string\n    var str14 []string\n    var str15 []string\n    var str16 []string\n    var str17 []string\n    var str18 []string\n    var str19 []string\n    var str20 []string\n    var str21 []string\n    var str22 []string\n    var str23 []string\n    var str24 []string\n    var str25 []string\n    var str26 []string\n    var str27 []string\n    var str28 []string\n    var str29 []string\n    var str30 []string\n    var str31 []string\n    var str32 []string\n    var str33 []string\n    var str34 []string\n    var str35 []string\n    var str36 []string\n    var str37 []string\n    var str38 []string\n    var str39 []string\n    var str40 []string\n    var str41 []string\n    var str42 []string\n    var str43 []string\n    var str44 []string\n    var str45 []string\n    var str46 []string\n    var str47 []string\n    var str48 []string\n    var str49 []string\n    var str50 []string\n    var str51 []string\n    var str52 []string\n    var str53 []string\n    var str54 []string\n    var str55 []string\n    var str56 []string\n    var str57 []string\n    var str58 []string\n    var str59 []string\n    var str60 []string\n    var str61 []string\n    var str62 []string\n    var str63 []string\n    var str64 []string\n    var str65 []string\n    var str66 []string\n    var str67 []string\n    var str68 []string\n    var str69 []string\n    var str70 []string\n    var str71 []\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_ffff57d_test.go:80:17: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpw3wv1w94_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels string = \"aeiouAEIOU\"\n    var vowel_pos []int\n    var vowel_pos_rev []int\n    var vowel_pos_rev_idx int\n\n    for i := 0; i < len(str1); i++ {\n        if strings.Contains(vowels, string(str1[i])) {\n            vowel_pos = append(vowel_pos, i)\n        }\n    }\n\n    for i := len(vowel_pos) - 1; i >= 0; i-- {\n        vowel_pos_rev = append(vowel_pos_rev, vowel_pos[i])\n    }\n\n    for i := 0; i < len(str1); i++ {\n        if strings.Contains(vowels, string(str1[i])) {\n            str2 += string(str1[vowel_pos_rev[vowel_pos_rev_idx]])\n            vowel_pos_rev_idx++\n        } else {\n            str2 += string(str1[i])\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp4tvpg2i_test.go:17:12: undefined: strings\n/tmp/tmpp4tvpg2i_test.go:27:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // Create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Create a slice of the vowels\n    str1_vowels := []string{}\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str1_vowels = append(str1_vowels, string(char))\n        }\n    }\n    // Reverse the slice of vowels\n    str1_vowels_reversed := []string{}\n    for i := len(str1_vowels)-1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n    // Replace the vowels in the slice of the string with the reversed slice of vowels\n    for i, char := range str1_slice {\n        if vowels[char] {\n            str1_slice[i] = str1_vowels_reversed[0]\n            str1_vowels_reversed = str1_vowels_reversed[1:]\n        }\n    }\n    // Convert the slice of the string back to a string\n    str1_reversed := \"\"\n    for _, char := range str1_slice {\n        str1_reversed += char\n    }\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpx5d8c0ta_test.go:65: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Convert string to slice of runes.\n    str1_runes := []rune(str1)\n    // Create a slice of runes to hold the vowels.\n    vowels := []rune{}\n    // Create a slice of runes to hold the non-vowels.\n    non_vowels := []rune{}\n    // Create a map of vowels.\n    vowels_map := map[rune]bool{\n        'a': true,\n        'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n        'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n    }\n    // Iterate over the slice of runes.\n    for _, rune := range str1_runes {\n        // Check if the rune is a vowel.\n        if _, ok := vowels_map[rune]; ok {\n            // Append the vowel to the vowels slice.\n            vowels = append(vowels, rune)\n        } else {\n            // Append the non-vowel to the non-vowels slice.\n            non_vowels = append(non_vowels, rune)\n        }\n    }\n    // Reverse the vowels slice.\n    for i, j := 0, len(vowels) - 1; i < j; i, j = i + 1, j - 1 {\n        vowels[i], vowels[j] = vowels[j], vowels[i]\n    }\n    // Create a slice of runes to hold the reversed string.\n    reversed_str1_runes := []rune{}\n    // Iterate over the slice of runes.\n    for _, rune := range str1_runes {\n        // Check if the rune is a vowel.\n        if _, ok := vowels_map[rune]; ok {\n            // Append the vowel to the reversed string.\n            reversed_str1_runes = append(reversed_str1_runes, vowels[0])\n            // Remove the vowel from the vowels slice.\n            vowels = vow\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfe9tw3dl_test.go:54:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create an empty string to hold the new string\n    new_str := \"\"\n    // Create an empty string to hold the vowels\n    vowels_str := \"\"\n    // Iterate through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels string\n        if _, ok := vowels[string(char)]; ok {\n            vowels_str += string(char)\n        }\n    }\n    // Reverse the vowels string\n    for i := len(vowels_str) - 1; i >= 0; i-- {\n        new_str += string(vowels_str[i])\n    }\n    // Iterate through the string again\n    for i, char := range str1 {\n        // If the character is a vowel, replace it with the reversed vowel\n        if _, ok := vowels[string(char)]; ok {\n            str1 = str1[:i] + new_str[:1] + str1[i+1:]\n            new_str = new_str[1:]\n        }\n    }\n    // Return the new string\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp9_b8566f_test.go:54: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    str2 = reverse(str2)\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + string(str2[j])\n            j++\n        } else {\n            str3 = str3 + string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3t8sfl77_test.go:16:12: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_runes = []rune(str1)\n    var str1_runes_len = len(str1_runes)\n    var str1_runes_vowels []rune\n    var str1_runes_vowels_len int\n    var str1_runes_vowels_reversed []rune\n    var str1_runes_vowels_reversed_len int\n    var str1_runes_vowels_reversed_idx int\n    var str1_runes_vowels_reversed_idx_max int\n    var str1_runes_vowels_reversed_idx_min int\n    var str1_runes_vowels_reversed_idx_mid int\n    var str1_runes_vowels_reversed_idx_mid_prev int\n    var str1_runes_vowels_reversed_idx_mid_next int\n    var str1_runes_vowels_reversed_idx_mid_prev_is_vowel bool\n    var str1_runes_vowels_reversed_idx_mid_next_is_vowel bool\n    var str1_runes_vowels_reversed_idx_mid_prev_is_vowel_idx int\n    var str1_runes_vowels_reversed_idx_mid_next_is_vowel_idx int\n    var str1_runes_vowels_reversed_idx_mid_prev_is_vowel_idx_max int\n    var str1_runes_vowels_reversed_idx_mid_next_is_vowel_idx_max int\n    var str1_runes_vowels_reversed_idx_mid_prev_is_vowel_idx_min int\n    var str1_runes_vowels_reversed_idx_mid\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123560,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp02g4o17v_test.go:30:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    for _, v := range str1 {\n        str2 = str2 + string(v)\n    }\n    for _, v := range str2 {\n        for _, v2 := range vowels {\n            if string(v) == v2 {\n                str3 = str3 + string(v)\n            }\n        }\n    }\n    for i := len(str3) - 1; i >= 0; i-- {\n        str4 = str4 + string(str3[i])\n    }\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    for _, v := range str2 {\n        for _, v2 := range vowels {\n            if string(v) == v2 {\n                str5 = str5 + string(v)\n            }\n        }\n    }\n    for _, v := range str2 {\n        for _, v2 := range vowels {\n            if string(v) != v2 {\n                str6 = str6 + string(v)\n            }\n        }\n    }\n    for _, v := range str5 {\n        for _, v2 := range str4 {\n            if string(v) == string(v2) {\n                str7 = str7 + string(v)\n            }\n        }\n    }\n    for _, v := range str6 {\n        for _, v2 := range str4 {\n            if string(v) == string(v2) {\n                str8 = str8 + string(v)\n            }\n        }\n    }\n    for _, v := range str7 {\n        str9 = str9 + string(v)\n    }\n    for _, v := range str8 {\n        str9 = str9 + string(v)\n    }\n    return str9\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpw7jdngkh_test.go:84: expected 'Python', got 'oooooooooo'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpw7jdngkh_test.go:84: expected 'ASU', got 'UAUUUUUUUUUAAAAAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpw7jdngkh_test.go:84: expected 'ab', got 'aaaaaaaaaa'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Loop through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // Add the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Loop through the string slice\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the reversed vowel\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9y83r31_test.go:38:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123558,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq_4r7r1f_test.go:14:12: undefined: contains\n/tmp/tmpq_4r7r1f_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpou6er7t__test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var vowel_stack []string\n\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmppwuchejr_test.go:47: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpw3wv1w94_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpw3wv1w94_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []rune(str1)\n    // Create a slice of the vowels in the string\n    var str1_vowels []rune\n    for _, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n    // Reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n    // Replace the vowels in the string with the reversed vowels\n    var str1_reversed []rune\n    for _, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            str1_reversed = append(str1_reversed, str1_vowels[0])\n            str1_vowels = str1_vowels[1:]\n        } else {\n            str1_reversed = append(str1_reversed, char)\n        }\n    }\n    return string(str1_reversed)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpca4im9eb_test.go:53: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int = 0\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 = str3 + string(str2[j])\n            j++\n        } else {\n            str3 = str3 + string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpk8xcemm__test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, v := range str1 {\n        str2 = append(str2, string(v))\n    }\n    for _, v := range str2 {\n        if _, ok := vowels[v]; ok {\n            str3 = append(str3, v)\n        }\n    }\n    for i, v := range str2 {\n        if _, ok := vowels[v]; ok {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    var str4 = \"\"\n    for _, v := range str2 {\n        str4 += v\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpgqrxeumo_test.go:49: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels.\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    // Convert the string to a slice of runes.\n    str1_runes := []rune(str1)\n\n    // Create a slice of runes to hold the vowels.\n    vowels_runes := []rune{}\n\n    // Iterate over the string, adding the vowels to the slice.\n    for _, v := range str1_runes {\n        if _, ok := vowels[string(v)]; ok {\n            vowels_runes = append(vowels_runes, v)\n        }\n    }\n\n    // Reverse the slice of vowels.\n    for i, j := 0, len(vowels_runes)-1; i < j; i, j = i+1, j-1 {\n        vowels_runes[i], vowels_runes[j] = vowels_runes[j], vowels_runes[i]\n    }\n\n    // Iterate over the string, replacing the vowels with the reversed vowels.\n    for i, v := range str1_runes {\n        if _, ok := vowels[string(v)]; ok {\n            str1_runes[i] = vowels_runes[0]\n            vowels_runes = vowels_runes[1:]\n        }\n    }\n\n    // Return the string.\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpep9g9ss__test.go:64: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var str2 = []rune(str1)\n    var i, j = 0, len(str2) - 1\n    for i < j {\n        if !contains(vowels, str2[i]) {\n            i++\n            continue\n        }\n        if !contains(vowels, str2[j]) {\n            j--\n            continue\n        }\n        str2[i], str2[j] = str2[j], str2[i]\n        i++\n        j--\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxytstx2o_test.go:14:13: undefined: contains\n/tmp/tmpxytstx2o_test.go:18:13: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str1_runes := []rune(str1)\n    str1_vowels := []rune{}\n    str1_vowels_index := []int{}\n    for i, v := range str1_runes {\n        for _, vv := range vowels {\n            if v == vv {\n                str1_vowels = append(str1_vowels, v)\n                str1_vowels_index = append(str1_vowels_index, i)\n            }\n        }\n    }\n    for i, v := range str1_vowels_index {\n        str1_runes[v] = str1_vowels[len(str1_vowels) - i - 1]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_indexes []int\n    var vowel_chars []string\n    var vowel_index int\n    var vowel_char string\n    var i int\n\n    for i = 0; i < len(str1); i++ {\n        if contains(vowels, string(str1[i])) {\n            vowel_indexes = append(vowel_indexes, i)\n            vowel_chars = append(vowel_chars, string(str1[i]))\n        }\n    }\n\n    for i = 0; i < len(str1); i++ {\n        if contains(vowel_indexes, i) {\n            vowel_index = index(vowel_indexes, i)\n            vowel_char = vowel_chars[len(vowel_chars) - vowel_index - 1]\n            str2 += vowel_char\n        } else {\n            str2 += string(str1[i])\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt9k7a4ib_test.go:19:12: undefined: contains\n/tmp/tmpt9k7a4ib_test.go:26:12: undefined: contains\n/tmp/tmpt9k7a4ib_test.go:27:27: undefined: index\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmsxwxkqt_test.go:78:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var str3 string\n    var str4 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        } else {\n            str3 = str3 + string(char)\n        }\n    }\n    for _, char := range str3 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str4 = str4 + string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str4 = str4 + string(char)\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpx5tdytk2_test.go:46: expected 'Python', got 'Pythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpx5tdytk2_test.go:46: expected 'ASU', got 'USA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpx5tdytk2_test.go:46: expected 'ab', got 'b'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpjfuz3d3r_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels []string\n    var str1_vowels_indexes []int\n    var str1_vowels_indexes_reverse []int\n    var str1_vowels_reverse []string\n    var str1_vowels_reverse_runes []rune\n    var str1_vowels_reverse_runes_index int\n    var str1_vowels_runes []rune\n    var str1_vowels_runes_index int\n    var str1_vowels_runes_index_reverse int\n    var str1_vowels_runes_reverse []rune\n    var str1_vowels_runes_reverse_index int\n    var str1_vowels_runes_reverse_index_reverse int\n    var str1_vowels_runes_reverse_index_reverse_reverse int\n    var str1_vowels_runes_reverse_reverse []rune\n    var str1_vowels_runes_reverse_reverse_index int\n    var str1_vowels_runes_reverse_reverse_index_reverse int\n    var str1_vowels_runes_reverse_reverse_index_reverse_reverse int\n    var str1_vowels_runes_reverse_reverse_reverse []rune\n    var str1_vowels_runes_reverse_reverse_reverse_index int\n    var str1_vowels_runes_reverse_reverse_reverse_index_reverse int\n    var str1_vowels_runes_reverse_reverse_reverse_index_reverse_reverse int\n    var str1_vowels_runes_reverse_reverse_reverse_reverse []rune\n    var str1_vowels_runes_reverse_reverse_reverse_reverse_index int\n    var str1_vowels_runes_reverse_reverse_reverse_reverse_index_reverse int\n    var str1_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwzhe9o4n_test.go:36:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    for i := len(str1) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp41_1l23y_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Loop through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // Add the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Loop through the string slice\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the reversed vowel\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            // Remove the vowel from the reversed vowels slice\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the joined string slice\n    return fmt.Sprintf(\"%s\", str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpw3up3znf_test.go:57: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpw3up3znf_test.go:57: expected 'ASU', got '[U S A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpw3up3znf_test.go:57: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_count = 0\n    var vowel_index = make([]int, 0)\n\n    for i := 0; i < len(str1); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if str1[i:i+1] == vowels[j] {\n                vowel_count++\n                vowel_index = append(vowel_index, i)\n            }\n        }\n    }\n\n    for i := 0; i < len(str1); i++ {\n        if vowel_count == 0 {\n            str2 = str1\n            break\n        } else if vowel_count == 1 {\n            str2 = str1[:vowel_index[0]] + str1[vowel_index[0]:vowel_index[0]+1] + str1[vowel_index[0]+1:]\n            break\n        } else {\n            if i == vowel_index[0] {\n                str2 = str2 + str1[vowel_index[vowel_count-1]:vowel_index[vowel_count-1]+1]\n                vowel_index = vowel_index[1:]\n                vowel_count--\n            } else {\n                str2 = str2 + str1[i:i+1]\n            }\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4bl9couc_test.go:60: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_consonants []string\n    var str1_vowels_reversed []string\n    var str1_consonants_reversed []string\n    var str1_reversed []string\n    var str1_reversed_string string\n\n    for _, char := range str1 {\n        if string(char) == \"a\" || string(char) == \"e\" || string(char) == \"i\" || string(char) == \"o\" || string(char) == \"u\" {\n            str1_vowels = append(str1_vowels, string(char))\n        } else {\n            str1_consonants = append(str1_consonants, string(char))\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i := len(str1_consonants) - 1; i >= 0; i-- {\n        str1_consonants_reversed = append(str1_consonants_reversed, str1_consonants[i])\n    }\n\n    for i := 0; i < len(str1_vowels_reversed); i++ {\n        str1_reversed = append(str1_reversed, str1_vowels_reversed[i])\n    }\n\n    for i := 0; i < len(str1_consonants_reversed); i++ {\n        str1_reversed = append(str1_reversed, str1_consonants_reversed[i])\n    }\n\n    for _, char := range str1_reversed {\n        str1_reversed_string += char\n    }\n\n    return str1_reversed_string\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxzxvb2xa_test.go:10:9: str2 declared but not used\n/tmp/tmpxzxvb2xa_test.go:11:9: vowels declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string characters\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Create a slice of the vowels in the string\n    str1_vowels := []string{}\n    for _, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n    // Reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n    // Replace the vowels in the string with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n    // Return the reversed string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvwrupa8u_test.go:36:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Iterate through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if vowels[string(char)] {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // Add the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate through the string slice\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the vowel from the reversed slice\n        if vowels[char] {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string slice as a string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkw4i_une_test.go:38:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n\n    // Create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n\n    // Create a slice of the vowels\n    str1_vowels := []string{}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, string(char))\n        }\n    }\n\n    // Reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n\n    // Replace the vowels in the slice of the string with the reversed slice of vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n\n    // Convert the slice of the string back to a string\n    str1 = \"\"\n    for _, char := range str1_slice {\n        str1 += char\n    }\n\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmplujvcawg_test.go:64: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123562,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1y7y4ho4_test.go:90:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123561,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmsxwxkqt_test.go:78:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if string(char) == \"y\" {\n            str2 += \"y\"\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str3 += string(char)\n                }\n            }\n        }\n    }\n    str3 = reverse(str3)\n    var str4 string\n    var j int = 0\n    for _, char := range str1 {\n        if string(char) == \"y\" {\n            str4 += \"y\"\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str4 += string(str3[j])\n                    j++\n                }\n            }\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufax82om_test.go:24:12: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // create a slice of the string\n    str1_slice := []rune(str1)\n    // create a slice of the vowels\n    var str1_vowels []rune\n    // iterate over the string and add the vowels to the slice\n    for _, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n    // reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n    // iterate over the string and replace the vowels with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n    // return the string\n    return string(str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4831d7ec_test.go:52: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    var str1_len = len(str1)\n    var str1_vowels = make([]string, 0)\n    var str1_vowels_len = 0\n    var str1_non_vowels = make([]string, 0)\n    var str1_non_vowels_len = 0\n    var str1_vowels_index = 0\n    var str1_non_vowels_index = 0\n\n    for i := 0; i < str1_len; i++ {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str1_vowels = append(str1_vowels, string(str1[i]))\n            str1_vowels_len++\n        } else {\n            str1_non_vowels = append(str1_non_vowels, string(str1[i]))\n            str1_non_vowels_len++\n        }\n    }\n\n    for i := 0; i < str1_len; i++ {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str2 += str1_vowels[str1_vowels_len - str1_vowels_index - 1]\n            str1_vowels_index++\n        } else {\n            str2 += str1_non_vowels[str1_non_vowels_index]\n            str1_non_vowels_index++\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp7z_lhzot_test.go:58: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    // Create a slice of the string\n    str_slice := []string{}\n    for _, char := range str1 {\n        str_slice = append(str_slice, string(char))\n    }\n\n    // Create a slice of the vowels\n    vowel_slice := []string{}\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            vowel_slice = append(vowel_slice, string(char))\n        }\n    }\n\n    // Reverse the slice of vowels\n    for i, j := 0, len(vowel_slice)-1; i < j; i, j = i+1, j-1 {\n        vowel_slice[i], vowel_slice[j] = vowel_slice[j], vowel_slice[i]\n    }\n\n    // Replace the vowels in the string slice with the reversed vowels\n    for i, char := range str_slice {\n        if vowels[char] {\n            str_slice[i] = vowel_slice[0]\n            vowel_slice = vowel_slice[1:]\n        }\n    }\n\n    // Return the string\n    return strings.Join(str_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd6y5vxni_test.go:47:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels.\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of strings to hold the vowels.\n    var vowel_slice []string\n    // Create a slice of strings to hold the consonants.\n    var consonant_slice []string\n    // Create a slice of strings to hold the reversed string.\n    var reversed_slice []string\n    // Create a slice of strings to hold the reversed vowels.\n    var reversed_vowel_slice []string\n    // Create a slice of strings to hold the reversed consonants.\n    var reversed_consonant_slice []string\n    // Create a slice of strings to hold the reversed string.\n    var reversed_string []string\n    // Iterate through the string.\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowel slice.\n        if _, ok := vowels[string(char)]; ok {\n            vowel_slice = append(vowel_slice, string(char))\n        } else {\n            // If the character is a consonant, add it to the consonant slice.\n            consonant_slice = append(consonant_slice, string(char))\n        }\n    }\n    // Reverse the vowel slice.\n    for i := len(vowel_slice) - 1; i >= 0; i-- {\n        reversed_vowel_slice = append(reversed_vowel_slice, vowel_slice[i])\n    }\n    // Reverse the consonant slice.\n    for i := len(consonant_slice) - 1; i >= 0; i-- {\n        reversed_consonant_slice = append(reversed_consonant_slice, consonant_slice[i])\n    }\n    // Reverse the string.\n    for i := len(str1) - 1; i >= 0; i-- {\n        reversed_slice = append(reversed_slice, string(str1[i]))\n    }\n    // Iterate through the reversed string.\n    for _, char := range reversed_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123563,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkq0fs4af_test.go:47:35: expected '{', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        str2 += string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str3 += string(char)\n            }\n        }\n    }\n    var str4 string\n    for _, char := range str2 {\n        for _, vowel := range str3 {\n            if string(char) == string(vowel) {\n                str4 += string(vowel)\n            } else {\n                str4 += string(char)\n            }\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmprwhoyk6f_test.go:49: expected 'ASU', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowel_stack []string\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_stack = append(vowel_stack, string(char))\n            }\n        }\n    }\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str2 += vowel_stack[len(vowel_stack)-1]\n                vowel_stack = vowel_stack[:len(vowel_stack)-1]\n            } else {\n                str2 += string(char)\n            }\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp8wskippe_test.go:48: expected 'Python', got 'PPPPPyyyyyttttthhhhhooooonnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8wskippe_test.go:48: expected 'ASU', got 'UUUUUSSSSSAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp8wskippe_test.go:48: expected 'ab', got 'aaaaabbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123557,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpe1l2501d_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []rune(str1)\n    var i, j int = 0, len(str2)-1\n    for i < j {\n        if !is_vowel(str2[i]) {\n            i++\n            continue\n        }\n        if !is_vowel(str2[j]) {\n            j--\n            continue\n        }\n        str2[i], str2[j] = str2[j], str2[i]\n        i++\n        j--\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx0tqo59b_test.go:13:13: undefined: is_vowel\n/tmp/tmpx0tqo59b_test.go:17:13: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var str83 string\n    var str84 string\n    var str85 string\n    var str86 string\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfj62w66__test.go:96:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_indexes []int\n    var vowel_chars []string\n    var vowel_index int\n    var vowel_char string\n    var i int\n    var j int\n    var k int\n    var l int\n\n    for i = 0; i < len(str1); i++ {\n        for j = 0; j < len(vowels); j++ {\n            if str1[i:i+1] == vowels[j] {\n                vowel_indexes = append(vowel_indexes, i)\n                vowel_chars = append(vowel_chars, str1[i:i+1])\n            }\n        }\n    }\n\n    for k = 0; k < len(str1); k++ {\n        for l = 0; l < len(vowel_indexes); l++ {\n            if k == vowel_indexes[l] {\n                vowel_index = len(vowel_indexes) - 1 - l\n                vowel_char = vowel_chars[vowel_index]\n                str2 = str2 + vowel_char\n            }\n        }\n        if k != vowel_indexes[l] {\n            str2 = str2 + str1[k:k+1]\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x5363a0, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5363a0, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x545862, 0x6, 0x4cd224, 0x5fa2f8)\n\t/tmp/tmprbjthlyf_test.go:38 +0x4cd\ncommand-line-arguments_test.TestReverse_Vowels(0xc000001380)\n\t/tmp/tmprbjthlyf_test.go:53 +0x53\ntesting.tRunner(0xc000001380, 0x54f278)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpuz0w111p_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowels_found []string\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowels_found = append(vowels_found, string(char))\n            }\n        }\n    }\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str2 += vowels_found[len(vowels_found)-1]\n                vowels_found = vowels_found[:len(vowels_found)-1]\n            } else {\n                str2 += string(char)\n            }\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpb8roew1w_test.go:48: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpb8roew1w_test.go:48: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpb8roew1w_test.go:48: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_list := []string{}\n    vowels_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowels_list = append(vowels_list, string(char))\n            }\n        }\n    }\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[i] = vowels_list[len(vowels_list)-1]\n                vowels_list = vowels_list[:len(vowels_list)-1]\n            }\n        }\n    }\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzpz_2ezb_test.go:29:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7fa7s69_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_index []int\n    var str1_vowels_index_reverse []int\n    var str1_vowels_reverse []string\n    var str1_vowels_reverse_index []int\n    var str1_vowels_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_sorted []int\n    var str1_vowels_reverse_index_reverse_sorted_index []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index_reverse []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index []int\n    var str1_vowels_reverse_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index_reverse_sorted_index_reverse []int\n    var str1_vowels_reverse_index_reverse\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi9_guzfh_test.go:29:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str_arr = []rune(str1)\n    var str_len = len(str_arr)\n    var i = 0\n    var j = str_len - 1\n    for i < j {\n        if _, ok := vowels[string(str_arr[i])]; !ok {\n            i++\n            continue\n        }\n        if _, ok := vowels[string(str_arr[j])]; !ok {\n            j--\n            continue\n        }\n        str_arr[i], str_arr[j] = str_arr[j], str_arr[i]\n        i++\n        j--\n    }\n    return string(str_arr)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpvdwz0mhw_test.go:52: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str2 := []rune(str1)\n    var i, j int\n    for i, j = 0, len(str2)-1; i < j; i, j = i+1, j-1 {\n        for i < j && !contains(vowels, str2[i]) {\n            i++\n        }\n        for i < j && !contains(vowels, str2[j]) {\n            j--\n        }\n        str2[i], str2[j] = str2[j], str2[i]\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpphljjvx8_test.go:14:23: undefined: contains\n/tmp/tmpphljjvx8_test.go:17:23: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // Create a slice of the string\n    str1_slice := []rune(str1)\n    // Create a slice of the vowels in the string\n    vowels_slice := []rune{}\n    for _, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, char)\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Replace the vowels in the original string with the reversed vowels\n    for i, char := range str1_slice {\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    return string(str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpey4ksubw_test.go:56: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_array = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_array = append(str1_array, string(char))\n    }\n\n    for _, char := range str1_array {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for _, char := range str1_array {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_reversed += str1_vowels_reversed[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            } else {\n                str1_reversed += char\n            }\n        }\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpl4aimhe3_test.go:61: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpl4aimhe3_test.go:61: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpl4aimhe3_test.go:61: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    for i := len(str1) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str2 += string(str1[i])\n        }\n    }\n    for i := 0; i < len(str1); i++ {\n        if _, ok := vowels[string(str1[i])]; ok {\n            str1 = str1[:i] + string(str2[0]) + str1[i+1:]\n            str2 = str2[1:]\n        }\n    }\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp873o8a63_test.go:47: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_map = make(map[string]int)\n    for i, v := range vowels {\n        vowel_map[v] = i\n    }\n    for _, v := range str1 {\n        if _, ok := vowel_map[string(v)]; ok {\n            str2 = string(v) + str2\n        }\n    }\n    var str3 string\n    var j int\n    for _, v := range str1 {\n        if _, ok := vowel_map[string(v)]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(v)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpgihjvxby_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmplqfuat9u_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp__89hllm_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var str83 string\n    var str84 string\n    var str85 string\n    var str86 string\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfj62w66__test.go:96:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_arr = []string(str1)\n    var str1_vowels []string\n    var str1_vowels_index []int\n    var str1_vowels_index_reverse []int\n    var str1_vowels_reverse []string\n    var str1_vowels_reverse_index []int\n    var str1_vowels_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_index []int\n    var str1_vowels_reverse_index_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index []int\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse []int\n    var str1_vowels_reverse_index_reverse_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123564,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq2kp31xt_test.go:30:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, v := range str1 {\n        str2 = append(str2, string(v))\n    }\n    for _, v := range str1 {\n        if vowels[string(v)] {\n            str3 = append(str3, string(v))\n        }\n    }\n    for i, v := range str2 {\n        if vowels[v] {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpymu5y8do_test.go:27:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    var vowels_list []string\n    var str1_list []string\n    var str1_list_len int\n    var i int\n    var j int\n    var k int\n\n    str1_list = strings.Split(str1, \"\")\n    str1_list_len = len(str1_list)\n\n    for i = 0; i < str1_list_len; i++ {\n        if _, ok := vowels[str1_list[i]]; ok {\n            vowels_list = append(vowels_list, str1_list[i])\n        }\n    }\n\n    for i = 0; i < str1_list_len; i++ {\n        if _, ok := vowels[str1_list[i]]; ok {\n            str1_list[i] = vowels_list[len(vowels_list)-1-j]\n            j++\n        }\n    }\n\n    for k = 0; k < str1_list_len; k++ {\n        str2 += str1_list[k]\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjjqequ90_test.go:19:17: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123559,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmph3pp0zt0_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        } else {\n            str2 = str2 + string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpo7zqz6ev_test.go:36: expected 'Python', got 'oPythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpo7zqz6ev_test.go:36: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of the string\n    str1_slice := []rune(str1)\n    // Create a slice of the vowels\n    vowels_slice := []rune{}\n    // Iterate through the string\n    for _, char := range str1_slice {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, char)\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate through the string\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the reversed vowel\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string\n    return string(str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpz65bven1_test.go:54: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels.\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // Create a slice of the string.\n    str1_slice := []rune(str1)\n    // Create a slice of the vowels.\n    vowels_slice := []rune{}\n    // Iterate through the string.\n    for _, char := range str1_slice {\n        // If the character is a vowel, append it to the vowels slice.\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, char)\n        }\n    }\n    // Reverse the vowels slice.\n    for i := 0; i < len(vowels_slice)/2; i++ {\n        j := len(vowels_slice) - i - 1\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate through the string.\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the next vowel in the reversed vowels slice.\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string.\n    return string(str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp158wmmho_test.go:61: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    for _, char := range str1 {\n        str2 = str2 + string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str3 = string(char) + str3\n            }\n        }\n    }\n    for _, char := range str2 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str4 = str4 + string(str3[0])\n                str3 = str3[1:]\n            } else {\n                str4 = str4 + string(char)\n            }\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123565,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpcqg6eso7_test.go:50: expected 'Python', got 'PPPPPyyyyyttttthhhhhooooonnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpcqg6eso7_test.go:50: expected 'ASU', got 'UUUUUSSSSSAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpcqg6eso7_test.go:50: expected 'ab', got 'aaaaabbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}